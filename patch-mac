=== modified file 'Makefile.in'
*** Makefile.in	2012-05-02 07:01:36 +0000
--- Makefile.in	2012-05-17 03:14:53 +0000
*************** VPATH=@srcdir@
*** 168,173 ****
--- 168,176 ----
  # Where to find the application default.
  x_default_search_path=@x_default_search_path@
  
+ # Location to install Emacs.app on Mac OS X
+ mac_appdir=@mac_appdir@
+ 
  # Location to install Emacs.app under NeXT/Open/GNUstep / Cocoa
  ns_appbindir=@ns_appbindir@
  ns_appresdir=@ns_appresdir@
*************** install-arch-dep: mkdir
*** 476,481 ****
--- 479,490 ----
  	-chmod 1755 $(DESTDIR)${bindir}/$(EMACSFULL)
  	rm -f $(DESTDIR)${bindir}/$(EMACS)
  	-ln $(DESTDIR)${bindir}/$(EMACSFULL) $(DESTDIR)${bindir}/$(EMACS)
+ 	if test "${mac_appdir}" != ""; then \
+ 	  umask 022; mkdir -p $(DESTDIR)${mac_appdir}/Emacs.app; \
+ 	  (cd mac/Emacs.app; (tar -chf - . | \
+ 		(cd $(DESTDIR)${mac_appdir}/Emacs.app; umask 022; tar -xvf - \
+ 			&& cat > /dev/null))) || exit 1; \
+ 	fi
  	if test "${ns_appresdir}" != ""; then \
  	  ( cd ${ns_appresdir} ; \
  	    if test -d share/emacs ; then dir=share/emacs/*/*; $(MV_DIRS); fi;\

=== modified file 'configure.in'
*** configure.in	2012-06-01 09:51:00 +0000
--- configure.in	2012-06-10 07:58:38 +0000
*************** OPTION_DEFAULT_ON([m17n-flt],[don't use 
*** 168,173 ****
--- 168,174 ----
  OPTION_DEFAULT_ON([toolkit-scroll-bars],[don't use Motif or Xaw3d scroll bars])
  OPTION_DEFAULT_ON([xaw3d],[don't use Xaw3d])
  OPTION_DEFAULT_ON([xim],[don't use X11 XIM])
+ OPTION_DEFAULT_OFF([mac],[use GUI on Mac OS X.])
  OPTION_DEFAULT_OFF([ns],[use NeXTstep (Cocoa or GNUstep) windowing system])
  
  OPTION_DEFAULT_ON([gpm],[don't use -lgpm for mouse support on a GNU/Linux console])
*************** test "X${with_gameuser}" != X && test "$
*** 216,221 ****
--- 217,228 ----
    && gameuser="${with_gameuser}"
  test "X$gameuser" = X && gameuser=games
  
+ AC_ARG_ENABLE(mac-app,
+ [AS_HELP_STRING([--enable-mac-app@<:@=DIR@:>@],
+                 [specify install directory for Emacs.app on Mac OS X
+ 		 [DIR=/Application]])],
+ [ mac_appdir_x=${enableval}])
+ 
  AC_ARG_WITH([gnustep-conf],dnl
  [AS_HELP_STRING([--with-gnustep-conf=PATH],[path to GNUstep.conf; default $GNUSTEP_CONFIG_FILE, or /etc/GNUstep/GNUstep.conf])])
  test "X${with_gnustep_conf}" != X && test "${with_gnustep_conf}" != yes && \
*************** else
*** 1487,1492 ****
--- 1494,1505 ----
    fi
  fi
  
+ HAVE_MACGUI=no
+ if test "${with_mac}" != no; then
+   AC_CHECK_HEADER(Carbon/Carbon.h, HAVE_MACGUI=yes)
+   test "${HAVE_MACGUI}" = yes && window_system=mac
+ fi
+ 
  HAVE_NS=no
  NS_IMPL_COCOA=no
  NS_IMPL_GNUSTEP=no
*************** fail;
*** 1564,1573 ****
--- 1577,1599 ----
  fi
  AC_SUBST(TEMACS_LDFLAGS2)
  
+ mac_frag=/dev/null
+ MAC_OBJ=
+ MAC_OBJC_OBJ=
+ if test "${HAVE_MACGUI}" = yes; then
+   mac_frag=$srcdir/src/mac.mk
+   MAC_OBJ="mac.o macterm.o macfns.o macmenu.o macselect.o macfont.o fontset.o fringe.o image.o"
+   MAC_OBJC_OBJ="macappkit.o"
+ fi
+ AC_SUBST(MAC_OBJ)
+ AC_SUBST(MAC_OBJC_OBJ)
+ AC_SUBST_FILE(mac_frag)
+ 
  ns_frag=/dev/null
  NS_OBJ=
  NS_OBJC_OBJ=
  if test "${HAVE_NS}" = yes; then
+   test "${window_system}" = mac && HAVE_MACGUI=no
    if test "$with_toolkit_scroll_bars" = "no"; then
      AC_MSG_ERROR([Non-toolkit scroll bars are not implemented for Nextstep.])
    fi
*************** dnl use the toolkit if we have gtk, or X
*** 1610,1616 ****
        * ) USE_X_TOOLKIT=maybe ;;
      esac
    ;;
!   nextstep | none )
      HAVE_X_WINDOWS=no
      HAVE_X11=no
      USE_X_TOOLKIT=none
--- 1636,1642 ----
        * ) USE_X_TOOLKIT=maybe ;;
      esac
    ;;
!   mac | nextstep | none )
      HAVE_X_WINDOWS=no
      HAVE_X11=no
      USE_X_TOOLKIT=none
*************** fi
*** 1877,1883 ****
  
  ### Use -lrsvg-2 if available, unless `--with-rsvg=no' is specified.
  HAVE_RSVG=no
! if test "${HAVE_X11}" = "yes" || test "${HAVE_NS}" = "yes"; then
    if test "${with_rsvg}" != "no"; then
      RSVG_REQUIRED=2.11.0
      RSVG_MODULE="librsvg-2.0 >= $RSVG_REQUIRED"
--- 1903,1909 ----
  
  ### Use -lrsvg-2 if available, unless `--with-rsvg=no' is specified.
  HAVE_RSVG=no
! if test "${HAVE_X11}" = "yes" || test "${HAVE_MACGUI}" = "yes" || test "${HAVE_NS}" = "yes"; then
    if test "${with_rsvg}" != "no"; then
      RSVG_REQUIRED=2.11.0
      RSVG_MODULE="librsvg-2.0 >= $RSVG_REQUIRED"
*************** if test "${HAVE_X11}" = "yes" || test "$
*** 1895,1901 ****
  fi
  
  HAVE_IMAGEMAGICK=no
! if test "${HAVE_X11}" = "yes"; then
    if test "${with_imagemagick}" != "no"; then
      ## 6.2.8 is the earliest version known to work, but earlier versions
      ## might work - let us know if you find one.
--- 1921,1927 ----
  fi
  
  HAVE_IMAGEMAGICK=no
! if test "${HAVE_X11}" = "yes" || test "${HAVE_MACGUI}" = "yes"; then
    if test "${with_imagemagick}" != "no"; then
      ## 6.2.8 is the earliest version known to work, but earlier versions
      ## might work - let us know if you find one.
*************** if test "${with_toolkit_scroll_bars}" !=
*** 2262,2267 ****
--- 2288,2296 ----
    elif test "${HAVE_GTK}" = "yes"; then
      AC_DEFINE(USE_TOOLKIT_SCROLL_BARS)
      USE_TOOLKIT_SCROLL_BARS=yes
+   elif test "${HAVE_MACGUI}" = "yes"; then
+     AC_DEFINE(USE_TOOLKIT_SCROLL_BARS)
+     USE_TOOLKIT_SCROLL_BARS=yes
    elif test "${HAVE_NS}" = "yes"; then
      AC_DEFINE(USE_TOOLKIT_SCROLL_BARS)
      USE_TOOLKIT_SCROLL_BARS=yes
*************** dnl Check for malloc/malloc.h on darwin
*** 2593,2598 ****
--- 2622,2647 ----
  AC_CHECK_HEADER(malloc/malloc.h, [AC_DEFINE(HAVE_MALLOC_MALLOC_H, 1, [Define to 1 if you have the <malloc/malloc.h> header file.])])
  
  C_SWITCH_X_SYSTEM=
+ ### Use Mac OS X GUI.
+ if test "${HAVE_MACGUI}" = "yes"; then
+   AC_DEFINE(HAVE_MACGUI, 1, [Define to 1 if you are using GUI on Mac OS X.])
+   AC_CHECK_HEADERS(AvailabilityMacros.h)
+   C_SWITCH_X_SYSTEM="-fconstant-cfstrings"
+   ## Specify the install directory
+   mac_appdir=
+   if test "${mac_appdir_x}" != ""; then
+     case ${mac_appdir_x} in
+       y | ye | yes)  mac_appdir=/Applications ;;
+       * ) mac_appdir=${mac_appdir_x} ;;
+     esac
+   fi
+   # We also have mouse menus.
+   HAVE_MENUS=yes
+   # Tell src/Makefile.in to create files in the Mac OS X application
+   # bundle mac/Emacs.app.
+   OTHER_FILES=macosx-app
+ fi
+ 
  ### Use NeXTstep API to implement GUI.
  if test "${HAVE_NS}" = "yes"; then
    AC_DEFINE(HAVE_NS, 1, [Define to 1 if you are using the NeXTstep API, either GNUstep or Cocoa on Mac OS X.])
*************** case "$opsys" in
*** 2850,2860 ****
    ##  The ncurses library has been moved out of the System framework in
    ##  Mac OS X 10.2.  So if configure detects it, set the command-line
    ##  option to use it.
!   darwin|gnu*)
      ## (HAVE_LIBNCURSES was not always true, but is since 2010-03-18.)
      if test "x$HAVE_LIBNCURSES" = "xyes"; then
        TERMINFO=yes
        LIBS_TERMCAP="-lncurses"
      fi
      ;;
  
--- 2899,2927 ----
    ##  The ncurses library has been moved out of the System framework in
    ##  Mac OS X 10.2.  So if configure detects it, set the command-line
    ##  option to use it.
!   darwin)
      ## (HAVE_LIBNCURSES was not always true, but is since 2010-03-18.)
      if test "x$HAVE_LIBNCURSES" = "xyes"; then
        TERMINFO=yes
        LIBS_TERMCAP="-lncurses"
+       if test "${HAVE_MACGUI}" = "yes"; then
+         AC_MSG_CHECKING(Mac OS X version min required >= 10.4)
+         AC_CACHE_VAL(emacs_cv_mac_os_x_min_required_10_4,
+         [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+ #ifdef HAVE_AVAILABILITYMACROS_H
+ #include <AvailabilityMacros.h>
+ #endif]],
+ [[#if MAC_OS_X_VERSION_MIN_REQUIRED < 1040 && MAC_OS_X_VERSION_MIN_REQUIRED >= 1020
+ fail;
+ #endif
+ ]])], emacs_cv_mac_os_x_min_required_10_4=yes, emacs_cv_mac_os_x_min_required_10_4=no)])
+         if test $emacs_cv_mac_os_x_min_required_10_4 = yes; then
+           AC_MSG_RESULT(10.4 or later)
+         else
+           AC_MSG_RESULT(before 10.4)
+           LIBS_TERMCAP="-lncurses.5"
+         fi
+       fi
      fi
      ;;
  
*************** fail;
*** 2877,2882 ****
--- 2944,2957 ----
      fi
      ;;
  
+   gnu*)
+     ## (HAVE_LIBNCURSES was not always true, but is since 2010-03-18.)
+     if test "x$HAVE_LIBNCURSES" = "xyes"; then
+       TERMINFO=yes
+       LIBS_TERMCAP="-lncurses"
+     fi
+     ;;
+ 
    netbsd)
      if test "x$LIBS_TERMCAP" = "x-lterminfo"; then
        TERMINFO=yes
*************** fi
*** 3236,3241 ****
--- 3311,3317 ----
  S_FILE="\$(srcdir)/${opsysfile}"
  AC_SUBST(M_FILE)
  AC_SUBST(S_FILE)
+ AC_SUBST(mac_appdir)
  AC_SUBST(ns_appdir)
  AC_SUBST(ns_appbindir)
  AC_SUBST(ns_appresdir)
*************** case "$opsys" in
*** 3415,3428 ****
     ## end of the header for adding load commands.  Needed for dumping.
     ## 0x690 is the total size of 30 segment load commands (at 56
     ## each); under Cocoa 31 commands are required.
!    if test "$HAVE_NS" = "yes"; then
!      libs_nsgui="-framework AppKit"
       headerpad_extra=6C8
     else
!      libs_nsgui=
       headerpad_extra=690
     fi
!    LD_SWITCH_SYSTEM_TEMACS="-fno-pie -prebind $libs_nsgui -Xlinker -headerpad -Xlinker $headerpad_extra"
  
     ## This is here because src/Makefile.in did some extra fiddling around
     ## with LD_SWITCH_SYSTEM.  The cpp logic was:
--- 3491,3547 ----
     ## end of the header for adding load commands.  Needed for dumping.
     ## 0x690 is the total size of 30 segment load commands (at 56
     ## each); under Cocoa 31 commands are required.
!    if test "$HAVE_MACGUI" = "yes"; then
!      # Check if the Image I/O framework is always available at
!      # runtime.  If not, fall back on QuickTime.
!      AC_MSG_CHECKING(Mac OS X version >= 10.4)
!      AC_CACHE_VAL(emacs_cv_mac_os_x_10_4,
!      [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
! #ifdef HAVE_AVAILABILITYMACROS_H
! #include <AvailabilityMacros.h>
! #endif]],
! [[#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1040 && (MAC_OS_X_VERSION_MIN_REQUIRED >= 1040 || MAC_OS_X_VERSION_MIN_REQUIRED < 1020)
! fail;
! #endif
! ]])], emacs_cv_mac_os_x_10_4=no, emacs_cv_mac_os_x_10_4=yes)])
!      if test $emacs_cv_mac_os_x_10_4 = yes; then
!        AC_MSG_RESULT(always 10.4 or later)
!        AC_DEFINE(USE_MAC_IMAGE_IO, 1, [Define if use the Image I/O framework for reading images.])
!        libs_image="-framework WebKit"
!      else
!        AC_MSG_RESULT(not always 10.4 or later)
!        libs_image="-framework QuickTime"
!      fi
!      # Check if the Quartz Core framework is necessary and always
!      # available at runtime.
!      AC_MSG_CHECKING(Mac OS X version max allowed >= 10.5)
!      AC_CACHE_VAL(emacs_cv_mac_os_x_max_allowed_10_5,
!      [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
! #ifdef HAVE_AVAILABILITYMACROS_H
! #include <AvailabilityMacros.h>
! #endif]],
! [[#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1050 && MAC_OS_X_VERSION_MIN_REQUIRED > 1020
! fail;
! #endif
! ]])], emacs_cv_mac_os_x_max_allowed_10_5=no, emacs_cv_mac_os_x_max_allowed_10_5=yes)])
!      if test $emacs_cv_mac_os_x_max_allowed_10_5 = yes; then
!        AC_MSG_RESULT(10.5 or later)
!        libs_quartz_core="-framework QuartzCore"
!      else
!        AC_MSG_RESULT(before 10.5)
!        libs_quartz_core=
!      fi
!      # Whether to use the Cocoa framework.
!      libs_macgui="-framework Carbon $libs_image $libs_quartz_core -framework Cocoa"
!      headerpad_extra=690
!    elif test "$HAVE_NS" = "yes"; then
!      libs_macgui="-framework AppKit"
       headerpad_extra=6C8
     else
!      libs_macgui=
       headerpad_extra=690
     fi
!    LD_SWITCH_SYSTEM_TEMACS="-fno-pie -prebind $libs_macgui -Xlinker -headerpad -Xlinker $headerpad_extra"
  
     ## This is here because src/Makefile.in did some extra fiddling around
     ## with LD_SWITCH_SYSTEM.  The cpp logic was:
*************** AC_SUBST(LIB_GCC)
*** 3540,3546 ****
  
  
  ## If we're using X11/GNUstep, define some consequences.
! if test "$HAVE_X_WINDOWS" = "yes" || test "$HAVE_NS" = "yes"; then
    AC_DEFINE(HAVE_WINDOW_SYSTEM, 1, [Define if you have a window system.])
    AC_DEFINE(HAVE_MOUSE, 1, [Define if you have mouse support.])
  fi
--- 3659,3665 ----
  
  
  ## If we're using X11/GNUstep, define some consequences.
! if test "$HAVE_X_WINDOWS" = "yes" || test "$HAVE_MACGUI" = "yes" || test "$HAVE_NS" = "yes"; then
    AC_DEFINE(HAVE_WINDOW_SYSTEM, 1, [Define if you have a window system.])
    AC_DEFINE(HAVE_MOUSE, 1, [Define if you have mouse support.])
  fi

=== modified file 'doc/emacs/Makefile.in'
*** doc/emacs/Makefile.in	2012-04-07 19:23:53 +0000
--- doc/emacs/Makefile.in	2012-04-28 00:30:28 +0000
*************** EMACSSOURCES= \
*** 102,107 ****
--- 102,108 ----
  	${srcdir}/cmdargs.texi \
  	${srcdir}/xresources.texi \
  	${srcdir}/anti.texi \
+ 	${srcdir}/macport.texi \
  	${srcdir}/macos.texi \
  	${srcdir}/msdog.texi \
  	${srcdir}/gnu.texi \

=== modified file 'doc/emacs/anti.texi'
*** doc/emacs/anti.texi	2012-01-23 06:52:18 +0000
--- doc/emacs/anti.texi	2012-02-27 23:43:09 +0000
***************
*** 2,8 ****
  @c Copyright (C) 2005-2012 Free Software Foundation, Inc.
  @c See file emacs.texi for copying conditions.
  
! @node Antinews, Mac OS / GNUstep, X Resources, Top
  @appendix Emacs 23 Antinews
  @c Update the emacs.texi Antinews menu entry with the above version number.
  
--- 2,8 ----
  @c Copyright (C) 2005-2012 Free Software Foundation, Inc.
  @c See file emacs.texi for copying conditions.
  
! @node Antinews, Mac Port, X Resources, Top
  @appendix Emacs 23 Antinews
  @c Update the emacs.texi Antinews menu entry with the above version number.
  

=== modified file 'doc/emacs/emacs.texi'
*** doc/emacs/emacs.texi	2012-05-01 07:38:15 +0000
--- doc/emacs/emacs.texi	2012-05-17 03:14:53 +0000
*************** Appendices
*** 222,227 ****
--- 222,228 ----
  * Emacs Invocation::    Hairy startup options.
  * X Resources::         X resources for customizing Emacs.
  * Antinews::            Information about Emacs version 23.
+ * Mac Port::            Using Emacs under Mac OS X with the Mac port.
  * Mac OS / GNUstep::    Using Emacs under Mac OS and GNUstep.
  * Microsoft Windows::   Using Emacs on Microsoft Windows and MS-DOS.
  * Manifesto::           What's GNU?  Gnu's Not Unix!
*************** Lisp programming.
*** 1543,1548 ****
--- 1544,1550 ----
  @include xresources.texi
  
  @include anti.texi
+ @include macport.texi
  @include macos.texi
  @c Includes msdog-xtra.
  @include msdog.texi

=== modified file 'doc/emacs/macos.texi'
*** doc/emacs/macos.texi	2012-04-10 06:54:43 +0000
--- doc/emacs/macos.texi	2012-04-28 00:30:28 +0000
***************
*** 1,7 ****
  @c This is part of the Emacs manual.
  @c Copyright (C) 2000-2012 Free Software Foundation, Inc.
  @c See file emacs.texi for copying conditions.
! @node Mac OS / GNUstep, Microsoft Windows, Antinews, Top
  @appendix Emacs and Mac OS / GNUstep
  @cindex Mac OS X
  @cindex Macintosh
--- 1,7 ----
  @c This is part of the Emacs manual.
  @c Copyright (C) 2000-2012 Free Software Foundation, Inc.
  @c See file emacs.texi for copying conditions.
! @node Mac OS / GNUstep, Microsoft Windows, Mac Port, Top
  @appendix Emacs and Mac OS / GNUstep
  @cindex Mac OS X
  @cindex Macintosh

=== added file 'doc/emacs/macport.texi'
*** doc/emacs/macport.texi	1970-01-01 00:00:00 +0000
--- doc/emacs/macport.texi	2012-06-10 07:58:38 +0000
***************
*** 0 ****
--- 1,366 ----
+ @c This is part of the Emacs Mac port manual.
+ @c Copyright (C) 2000, 2001, 2002, 2003, 2004,
+ @c   2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+ @c Copyright (C) 2012  YAMAMOTO Mitsuharu
+ @c See file emacs.texi for copying conditions.
+ @node Mac Port, Mac OS / GNUstep, Antinews, Top
+ @appendix Emacs and Mac OS X with the Mac port
+ @cindex Mac port
+ 
+   This section briefly describes the peculiarities of using Emacs
+ under Mac OS X with the Mac port.  This port provides a native GUI
+ support for Mac OS X 10.4 -- 10.7.  Note that Emacs 23 and later
+ already contain the official GUI support via the NS (Cocoa) port for
+ Mac OS X 10.4 and later (@pxref{Mac OS / GNUstep}).  So if it is good
+ enough for you, then you don't need to try this.
+ 
+   The Mac port is a descendant of the following ports for Mac OS X:
+ 
+ @itemize
+ @item
+ Carbon port for Emacs 22 (aka "Carbon Emacs", don't confuse it with
+ ``Carbon Emacs Package''): this is a part of the official GNU Emacs 22
+ distribution and provides native GUI support for Mac OS.  It has been
+ used in almost all the Emacs 22 distributions/packages for Mac OS X
+ with its native GUI.
+ 
+   The Carbon port was initiated by Andrew Choi, using his Mac OS 8/9
+ port as a basis.  He had been the maintainer of Mac OS port of GNU
+ Emacs and participated in the development until late 2003.
+ 
+ @item
+ Carbon+AppKit port for Emacs 22.3: this is a port of the Carbon port
+ above.  The two ports differ in the GUI implementation basis: the
+ Carbon port uses Carbon HIToolbox, but the Carbon+AppKit port uses the
+ Cocoa Application Kit framework (AppKit).  The Carbon+AppKit port
+ inherits the code of the non-GUI part of the Carbon port, such as
+ drawing, font and image handling.  So in this sense, the Carbon+AppKit
+ port can be regarded as a variant of the Carbon port.  Obviously, this
+ is not a backport of the Cocoa/GNUstep port (aka ``Emacs.app'' or the
+ NS port).
+ @end itemize
+ 
+   The Mac port doesn't support multi-tty with GUI.  The developer has
+ no idea how to detach Emacs as a GUI application from Window Server or
+ Dock without separating a GUI process (not thread) from the main Emacs
+ (Lisp evaluator) process.  TTY-only multi-tty is supposed to work.
+ 
+ @menu
+ * Mac Invocation::		Invocation of Emacs Mac port.
+ * Mac Input::                   Keyboard and mouse input on the Mac port.
+ * Mac Fonts::                   Specifying fonts on the Mac port.
+ * Mac Functions::               Lisp functions specific to the Mac port.
+ @end menu
+ 
+ @node Mac Invocation
+ @section Invocation of Emacs Mac Port
+ @cindex Emacs invocation (Mac port)
+ 
+   When Emacs Mac port is run from a terminal, it inherits the values
+ of environment variables from the shell from which it is invoked.
+ This also applies to an invocation via the @command{open} command on
+ Mac OS X 10.4 and later.
+ 
+   When it is run from the Finder as a GUI application, how the
+ environment variables are inherited depends on whether the file
+ @file{~/.MacOSX/environment.plist} exists or not.  If it exists, then
+ the Mac port inherits environment variable values defined in the file,
+ and it affects all the applications invoked from the Finder as well as
+ Emacs.  If it doesn't exist, then the Mac port inherits those defined
+ in user's login shell, so settings in @file{/etc/profile},
+ @file{~/.bash_profile}, etc. are in effect if you use bash as your
+ login shell.
+ 
+   Command line arguments are specified like
+ 
+ @example
+ /Applications/Emacs.app/Contents/MacOS/Emacs -g 80x25 &
+ @end example
+ 
+ @noindent
+ if the Mac port is installed at @file{/Applications/Emacs.app}.  In
+ addition to the standard command line options (@pxref{Emacs
+ Invocation}), you can also specify temporary Preference settings,
+ which are only applied to a specific invocation, as command line
+ options just as in other Cocoa applications (e.g.,
+ @samp{-AppleAntiAliasingThreshold 14}).  An alternative way to specify
+ command line options on Mac OS X 10.6 and later is to use the
+ @samp{--args} option in the @command{open} command.
+ 
+   Holding shift key on startup is recognized as the @samp{-Q} option,
+ which means to start Emacs with minimum customizations.
+ 
+   On Mac OS X 10.7, @samp{fullscreen} and @samp{fullboth} values for
+ the @samp{fullscreen} frame parameter have different meanings: the
+ former means a new system-wide full screen mode with a dedicated
+ desktop (or Space), while the latter means making the frame fullscreen
+ in a desktop (or Space) shared with the other applications.  Because
+ the command line option @samp{-fs} or @samp{--fullscreen} corresponds
+ to @samp{fullboth}, it means the latter on all versions of Mac OS X.
+ 
+ @cindex Preferences (Mac port)
+   Although the Mac port does not support X resources (@pxref{X
+ Resources}) directly, one can use the Preferences system in place of X
+ resources.  For example, adding the line
+ 
+ @example
+ Emacs.cursorType: bar
+ @end example
+ 
+ @noindent
+ to @file{~/.Xresources} in X11 corresponds to the execution of
+ 
+ @example
+ defaults write org.gnu.Emacs Emacs.cursorType bar
+ @end example
+ 
+ @noindent
+ on Mac OS X.  One can use boolean or numeric values as well as string
+ values as follows:
+ 
+ @example
+ defaults write org.gnu.Emacs Emacs.toolBar -bool false
+ defaults write org.gnu.Emacs Emacs.lineSpacing -int 3
+ @end example
+ 
+ @noindent
+ Try @kbd{M-x man RET defaults RET} for the usage of the
+ @command{defaults} command.  Alternatively, if you have Developer
+ Tools installed on Mac OS X, you can use Property List Editor to edit
+ the file @file{~/Library/Preferences/org.gnu.Emacs.plist}.
+ 
+ @cindex language environments (Mac port)
+   The default language environment (@pxref{Language Environments}) is
+ set according to the locale setting at the startup time.  On Mac OS X,
+ the locale setting is consulted in the following order:
+ 
+ @enumerate
+ @item
+ Environment variables @env{LC_ALL}, @env{LC_CTYPE} and @env{LANG} as
+ in other systems.
+ 
+ @item
+ Preference @code{AppleLocale} that is set by default on Mac OS X 10.3
+ and later.
+ 
+ @item
+ Preference @code{AppleLanguages} that is set by default on Mac OS X
+ 10.1 and later.
+ 
+ @item
+ (32-bit only) Variable @code{mac-system-locale} that is derived from
+ the system language and region codes.
+ @end enumerate
+ 
+   The default values of almost all variables about coding systems are
+ also set according to the language environment.  So usually you don't
+ have to customize these variables manually.
+ 
+ @node Mac Input
+ @section Keyboard and Mouse Input on the Mac Port
+ @cindex Meta (Mac port)
+ 
+ @vindex mac-control-modifier
+ @vindex mac-command-modifier
+ @vindex mac-option-modifier
+ @vindex mac-function-modifier
+   On the Mac port, Emacs can use @key{control}, @key{command},
+ @key{option}, and laptop @key{function} keys as any of Emacs modifier
+ keys except @key{SHIFT} (i.e., @key{ALT}, @key{CTRL}, @key{HYPER},
+ @key{META}, and @key{SUPER}).  The assignment is controlled by the
+ variables @code{mac-control-modifier}, @code{mac-command-modifier},
+ @code{mac-option-modifier}, and @code{mac-function-modifier}.  The
+ value for each of these variables can be one of the following symbols:
+ @code{alt}, @code{control}, @code{hyper}, @code{meta}, @code{super},
+ and @code{nil} (no particular assignment).  By default, the
+ @key{control} key works as @key{CTRL}, and the @key{command} key as
+ @key{META}.
+ 
+   For the @key{option} key, if @code{mac-option-modifier} is set to
+ @code{nil}, which is the default, the key works as the normal
+ @key{option} key, i.e., dead-key processing will work.  This is useful
+ for entering non-@acronym{ASCII} Latin characters directly from the
+ Mac keyboard, for example.
+ 
+   The Mac port recognizes the setting in the International system
+ preference pane and supports international and alternative keyboard
+ layouts (e.g., Dvorak).  Selecting one of the layouts from the
+ keyboard layout pull-down menu will affect how the keys typed on the
+ keyboard are interpreted.
+ 
+ @vindex mac-pass-command-to-system
+ @vindex mac-pass-control-to-system
+   Mac OS X intercepts and handles certain key combinations. These will
+ not be passed to Emacs.  One can disable this interception by setting
+ @code{mac-pass-command-to-system} or @code{mac-pass-control-to-system}
+ to @code{nil}.
+ 
+ @vindex mac-emulate-three-button-mouse
+   Especially for one-button mice, the multiple button feature can be
+ emulated by setting @code{mac-emulate-three-button-mouse} to @code{t}
+ or @code{reverse}.  If set to @code{t} (@code{reverse}, respectively),
+ pressing the mouse button with the @key{option} key is recognized as
+ the second (third) button, and that with the @key{command} key is
+ recognized as the third (second) button.
+ 
+ @vindex mac-wheel-button-is-mouse-2
+   For multi-button mice, the wheel button and the secondary button are
+ recognized as the second and the third button, respectively.  If
+ @code{mac-wheel-button-is-mouse-2} is set to @code{nil}, their roles
+ are exchanged.
+ 
+ @vindex mac-mouse-wheel-smooth-scroll
+   Pixel-based mouse wheel smooth scrolling is enabled by default for
+ newer mice/trackpads.  You can turn it off by setting
+ @code{mac-mouse-wheel-smooth-scroll} to @code{nil}.
+ 
+   Just as in many Cocoa applications (and some Carbon applications
+ like Carbon Emacs), you can use @samp{Command-Control-D} for looking
+ up a word under the mouse pointer in the selected window on Mac OS X
+ 10.4 and later.  The same functionality is provided by double-tapping
+ a trackpad with three fingers on Mac OS X 10.7.
+ 
+   In addition to the standard Emacs events, the Mac port also accepts
+ several gesture events on newer mice/trackpads, and some gestures have
+ default bindings.  For example, fullscreen can be turned on/off by
+ pinching out/in on a newer trackpad with the shift key on Mac OS X
+ 10.5.2 and later.
+ 
+   The Mac port also provides Apple event sending with (a)synchronous
+ reply handling.  @acronym{ODB} Editor Suite support is added as an
+ example.
+ 
+ @node Mac Fonts
+ @section Specifying Fonts on the Mac Port
+ @cindex fonts (Mac port)
+ 
+   The way of specifying fonts on the Mac port is basically the same as
+ in other platforms.  @xref{Fonts}.  Clicking on @samp{Set Default
+ Font} in the @samp{Options} menu brings us the modal font selection
+ dialog.  You can also use the non-modal font panel via @samp{Font
+ Panel} in the @samp{Show/Hide} submenu in the @samp{Options} menu.
+ 
+   The Mac port recognizes three formats as a string representation of
+ a font name: Fontconfig pattern, GTK font description, and X Logical
+ Font Description (XLFD).  In a Fontconfig pattern, you can use the
+ following properties as well as the standard ones like @samp{slant},
+ @samp{weight}, etc.
+ 
+ @table @samp
+ @item antialias
+ One of @samp{true}, @samp{false}, @samp{on} or @samp{off}, meaning
+ whether the font is antialiased or not.  Not specifying this property
+ means to use the value of the @samp{AppleAntiAliasingThreshold}
+ Preference as the threshold.
+ 
+ @item minspace
+ One of @samp{true}, @samp{false}, @samp{on} or @samp{off}, meaning
+ whether the font ignores the leading value in font metrics.
+ 
+ @item destination
+ The value 1 means the destination is video text as in the XLFD
+ Conventions, and screen font metrics are used in that case.  For
+ example, you can see the difference between the following examples:
+ 
+ @smallexample
+ (make-frame '((font . "Monaco-9:antialias=off")))
+ (make-frame '((font . "Monaco-9:antialias=off:destination=1")))
+ @end smallexample
+ @end table
+ 
+   As Quickdraw-style font rendering is considered obsolete as of Mac
+ OS X 10.5, the variable @code{mac-allow-anti-aliasing}, which was
+ supported in the preceding ports (under a somewhat inappropriate
+ name), is no longer supported in the Mac port.  If you want to control
+ anti-aliasing, then you can set it with either from the Appearance
+ pane of the System Preferences@footnote{Change of text smoothing
+ threshold setting in the Appearance pane of the System Preferences is
+ reflected immediately.}, or the @code{AppleAntiAliasingThreshold}
+ Preference that can be set with the @command{defaults} command.
+ 
+ @example
+ defaults write org.gnu.Emacs AppleAntiAliasingThreshold @var{n}
+ @end example
+ 
+   The bold variant of a font is displayed as a synthetic one, if it
+ lacks genuine bold (e.g., Monaco).  Unfortunately, synthetic bold
+ looks thinner if the background is darker than the foreground and the
+ @acronym{LCD} font smoothing is turned on.  In such cases, you can
+ turn off synthetic bold for particular fonts and use overstriking
+ instead by customizing the variable @code{face-ignored-fonts}:
+ 
+ @example
+ (add-to-list 'face-ignored-fonts "\\`-[^-]*-monaco-bold-")
+ @end example
+ 
+ @vindex mac-text-scale-standard-width
+   If you are using newer trackpads with Mac OS X 10.5.2 and later,
+ then you can scale text size by pinch out/in.  On Mac OS X 10.7,
+ double-tapping either a touch-sensitive mouse with one finger or a
+ trackpad with two fingers changes the buffer text scaling to unscaled
+ if previously scaled.  And if previously unscaled, then the buffer
+ text is scaled so the default font occupies at least
+ @code{mac-text-scale-standard-width} columns in the tapped window.
+ 
+   The Mac port provides several font backends, @code{mac-ct} using the
+ Core Text framework introduced in Mac OS X 10.5, @code{mac-fd} using
+ NSFontDescriptor expanded in Mac OS X 10.4, and @code{mac-fm} using
+ NSFontManager.  An appropriate font backend is selected automatically
+ depending on the @acronym{OS} version at startup, and one backend is
+ used at a time.
+ 
+   All these backends support Unicode character display including
+ non-@acronym{BMP} ones, Complex Text Layout such as Devanagari, and
+ glyph selection with variation selectors.  Most of Adobe-Japan1
+ ideographic glyphs are accessible via @acronym{IVSes} (Ideographic
+ Variation Sequences) even for the OS-bundled Hiragino fonts, which do
+ not contain the @acronym{UVS} subtable in their cmap table as of Mac
+ OS X 10.6.  If compiled and executed on Mac OS X 10.7, then the Mac
+ port can also display color bitmap fonts such as Apple Color Emoji.
+ 
+   They also use non-integral x positions for displaying antialiased
+ proportional fonts.  You can see the difference by putting the box
+ cursor over Helvetica 12pt @samp{I}, whose ideal width is 3.33398 but
+ displayed with the rounded width 3, for example.
+ 
+ @node Mac Functions
+ @section Lisp Functions Specific to the Mac Port
+ @cindex Lisp functions (Mac port)
+ 
+ @findex do-applescript
+   The function @code{do-applescript} takes a string argument,
+ executes it as an AppleScript command, and returns the result as a
+ string.
+ 
+ @findex mac-set-file-creator
+ @findex mac-get-file-creator
+ @findex mac-set-file-type
+ @findex mac-get-file-type
+ @findex mac-file-alias-p
+   The functions @code{mac-set-file-creator},
+ @code{mac-get-file-creator}, @code{mac-set-file-type}, and
+ @code{mac-get-file-type} can be used to set and get creator and file
+ codes.  The function @code{mac-file-alias-p} can be used to check if
+ the specified file name is a name of an alias file, and if so, which
+ file it is referring to.
+ 
+ @findex mac-get-preference
+ @findex mac-convert-property-list
+   The function @code{mac-get-preference} returns the Preferences value
+ converted to a Lisp object for a specified key and application.  The
+ function @code{mac-convert-property-list} converts a Core Foundation
+ property list, which is typically used in a @samp{.plist} file,
+ between several formats (@acronym{XML}, binary, or Lisp
+ representation).
+ 
+ @findex mac-start-animation
+   The function @code{mac-start-animation} starts animation effect
+ using Core Animation on Mac OS X 10.5 and later.
+ 
+ The Mac port provides an image type symbol @code{image-io}, which is
+ parallel to another image type symbol @code{imagemagick}
+ (@pxref{ImageMagick Images,,, elisp}), but using the Image I/O
+ framework on Mac OS X 10.4 and later.  It also works as a fallback of
+ @code{imagemagick} if the Mac port is not compiled with the
+ ImageMagick support, so you can scale and rotate images even without
+ ImageMagick.

=== modified file 'doc/emacs/xresources.texi'
*** doc/emacs/xresources.texi	2012-04-28 07:45:03 +0000
--- doc/emacs/xresources.texi	2012-05-17 03:14:53 +0000
*************** When Emacs is built without GTK+ support
*** 21,27 ****
  widgets is determined by additional X resources.
  
    On MS-Windows, you can customize some of the same aspects using the
! system registry (@pxref{MS-Windows Registry}).
  
  @menu
  * Resources::           Using X resources with Emacs (in general).
--- 21,29 ----
  widgets is determined by additional X resources.
  
    On MS-Windows, you can customize some of the same aspects using the
! system registry (@pxref{MS-Windows Registry}).  Likewise, the Mac port
! emulates X resources using the Preferences system.  @xref{Mac
! Invocation}.
  
  @menu
  * Resources::           Using X resources with Emacs (in general).

=== modified file 'doc/lispref/display.texi'
*** doc/lispref/display.texi	2012-05-15 15:43:06 +0000
--- doc/lispref/display.texi	2012-05-17 03:14:53 +0000
*************** apply to.  Here are the possible values 
*** 1968,1975 ****
  @item type
  The kind of window system the frame uses---either @code{graphic} (any
  graphics-capable display), @code{x}, @code{pc} (for the MS-DOS console),
! @code{w32} (for MS Windows 9X/NT/2K/XP), or @code{tty} 
! (a non-graphics-capable display).
  @xref{Window Systems, window-system}.
  
  @item class
--- 1968,1975 ----
  @item type
  The kind of window system the frame uses---either @code{graphic} (any
  graphics-capable display), @code{x}, @code{pc} (for the MS-DOS console),
! @code{w32} (for MS Windows 9X/NT/2K/XP), @code{mac} (for the Mac OS X
! display), or @code{tty} (a non-graphics-capable display).
  @xref{Window Systems, window-system}.
  
  @item class
*************** Emacs is using for displaying the frame.
*** 6179,6184 ****
--- 6179,6186 ----
  Emacs is displaying the frame using X.
  @item w32
  Emacs is displaying the frame using native MS-Windows GUI.
+ @item mac
+ Emacs is displaying the frame using native Mac OS X GUI.
  @item ns
  Emacs is displaying the frame using the Nextstep interface (used on
  GNUstep and Mac OS X).

=== modified file 'doc/lispref/frames.texi'
*** doc/lispref/frames.texi	2012-05-15 09:38:50 +0000
--- doc/lispref/frames.texi	2012-05-17 03:16:24 +0000
*************** The frame is displayed on a text termina
*** 55,60 ****
--- 55,62 ----
  The frame is displayed on an X graphical terminal.
  @item w32
  The frame is displayed on a MS-Windows graphical terminal.
+ @item mac
+ The frame is displayed on a Mac OS X graphical terminal.
  @item ns
  The frame is displayed on a GNUstep or Macintosh Cocoa graphical
  terminal.
*************** The terminal and keyboard coding systems
*** 181,187 ****
  @item
  The kind of display associated with the terminal.  This is the symbol
  returned by the function @code{terminal-live-p} (i.e.@: @code{x},
! @code{t}, @code{w32}, @code{ns}, or @code{pc}).  @xref{Frames}.
  
  @item
  A list of terminal parameters.  @xref{Terminal Parameters}.
--- 183,189 ----
  @item
  The kind of display associated with the terminal.  This is the symbol
  returned by the function @code{terminal-live-p} (i.e.@: @code{x},
! @code{t}, @code{w32}, @code{mac}, @code{ns}, or @code{pc}).  @xref{Frames}.
  
  @item
  A list of terminal parameters.  @xref{Terminal Parameters}.
*************** and @code{x-set-selection} on MS-Windows
*** 1978,1983 ****
--- 1980,2008 ----
  only; if the clipboard holds other types of data, Emacs treats the
  clipboard as empty.
  
+ @cindex pasteboard support (for Mac OS X)
+ On Mac OS X, selection-like data transfer between applications is
+ performed through a mechanism called @dfn{pasteboards}.  The clipboard
+ is a particular pasteboard named @code{Apple CFPasteboard general}.
+ Types of pasteboard data are called @dfn{pasteboard data types}, which
+ are identified by strings such as @code{NSStringPboardType}.  The Mac
+ port of Emacs associates a selection with a pasteboard, and a
+ selection type with a pasteboard data type via
+ @code{mac-pasteboard-name} and @code{mac-pasteboard-data-type}
+ properties, respectively.
+ 
+ @example
+ (get 'CLIPBOARD 'mac-pasteboard-name)
+      @result{} "Apple CFPasteboard general"
+ (get 'NSStringPboardType 'mac-pasteboard-data-type)
+      @result{} "NSStringPboardType"
+ @end example
+ 
+ Conventionally, selection types for pasteboard data types on Mac OS X
+ are named according to the identifiers defined in the NSPasteboard
+ class, (e.g., @code{NSStringPboardType}, @code{NSTIFFPboardType}, and
+ @code{NSFilenamesPboardType}).
+ 
  @node Drag and Drop
  @section Drag and Drop
  

=== modified file 'lib-src/makefile.w32-in'
*** lib-src/makefile.w32-in	2012-05-29 16:15:12 +0000
--- lib-src/makefile.w32-in	2012-06-01 10:57:00 +0000
*************** $(BLD)/ctags.$(O): ctags.c
*** 123,129 ****
  #
  obj =   dosfns.o msdos.o \
  	xterm.o xfns.o xmenu.o xselect.o xrdb.o xsmfns.o fringe.o image.o \
! 	fontset.o menu.o \
  	w32.o w32console.o w32fns.o w32heap.o w32inevt.o \
  	w32menu.o w32proc.o w32reg.o w32select.o w32term.o w32xfns.o \
  	font.o w32font.o w32uniscribe.o \
--- 123,129 ----
  #
  obj =   dosfns.o msdos.o \
  	xterm.o xfns.o xmenu.o xselect.o xrdb.o xsmfns.o fringe.o image.o \
! 	mac.o macterm.o macfns.o macmenu.o macselect.o fontset.o menu.o \
  	w32.o w32console.o w32fns.o w32heap.o w32inevt.o \
  	w32menu.o w32proc.o w32reg.o w32select.o w32term.o w32xfns.o \
  	font.o w32font.o w32uniscribe.o \

=== modified file 'lisp/cus-edit.el'
*** lisp/cus-edit.el	2012-06-01 09:51:00 +0000
--- lisp/cus-edit.el	2012-06-01 10:57:00 +0000
***************
*** 435,440 ****
--- 435,447 ----
    :link '(custom-manual "(emacs)Windows")
    :group 'environment)
  
+ (defgroup mac nil
+   "Mac specific features."
+   :link '(custom-manual "(emacs)Mac Port")
+   :group 'environment
+   :version "22.1"
+   :prefix "mac-")
+ 
  ;;; Custom mode keymaps
  
  (defvar custom-mode-map
*************** and `face'."
*** 2116,2122 ****
  ;;; The `custom' Widget.
  
  (defface custom-button
!   '((((type x w32 ns) (class color))	; Like default modeline
       (:box (:line-width 2 :style released-button)
  	   :background "lightgrey" :foreground "black"))
      (t
--- 2123,2129 ----
  ;;; The `custom' Widget.
  
  (defface custom-button
!   '((((type x w32 mac ns) (class color))	; Like default modeline
       (:box (:line-width 2 :style released-button)
  	   :background "lightgrey" :foreground "black"))
      (t
*************** and `face'."
*** 2127,2133 ****
  (define-obsolete-face-alias 'custom-button-face 'custom-button "22.1")
  
  (defface custom-button-mouse
!   '((((type x w32 ns) (class color))
       (:box (:line-width 2 :style released-button)
  	   :background "grey90" :foreground "black"))
      (t
--- 2134,2140 ----
  (define-obsolete-face-alias 'custom-button-face 'custom-button "22.1")
  
  (defface custom-button-mouse
!   '((((type x w32 mac ns) (class color))
       (:box (:line-width 2 :style released-button)
  	   :background "grey90" :foreground "black"))
      (t
*************** and `face'."
*** 2152,2158 ****
        (if custom-raised-buttons 'custom-button-mouse 'highlight))
  
  (defface custom-button-pressed
!   '((((type x w32 ns) (class color))
       (:box (:line-width 2 :style pressed-button)
  	   :background "lightgrey" :foreground "black"))
      (t
--- 2159,2165 ----
        (if custom-raised-buttons 'custom-button-mouse 'highlight))
  
  (defface custom-button-pressed
!   '((((type x w32 mac ns) (class color))
       (:box (:line-width 2 :style pressed-button)
  	   :background "lightgrey" :foreground "black"))
      (t
*************** OS/2 Presentation Manager.")
*** 3272,3277 ****
--- 3279,3288 ----
  					   :sibling-args (:help-echo "\
  Windows NT/9X.")
  					   w32)
+ 				    (const :format "MAC "
+ 					   :sibling-args (:help-echo "\
+ Mac OS.")
+ 					   mac)
  				    (const :format "NS "
  					   :sibling-args (:help-echo "\
  GNUstep or Macintosh OS Cocoa interface.")

=== modified file 'lisp/cus-face.el'
*** lisp/cus-face.el	2012-01-19 07:21:25 +0000
--- lisp/cus-face.el	2012-02-27 23:16:05 +0000
***************
*** 38,50 ****
        (unless facep
  	;; If the user has already created the face, respect that.
  	(let ((value (or (get face 'saved-face) spec))
! 	      (have-window-system (memq initial-window-system '(x w32))))
  	  ;; Create global face.
  	  (make-empty-face face)
  	  ;; Create frame-local faces
  	  (dolist (frame (frame-list))
  	    (face-spec-set-2 face frame value)
! 	    (when (memq (window-system frame) '(x w32 ns))
  	      (setq have-window-system t)))
  	  ;; When making a face after frames already exist
  	  (if have-window-system
--- 38,50 ----
        (unless facep
  	;; If the user has already created the face, respect that.
  	(let ((value (or (get face 'saved-face) spec))
! 	      (have-window-system (memq initial-window-system '(x w32 mac))))
  	  ;; Create global face.
  	  (make-empty-face face)
  	  ;; Create frame-local faces
  	  (dolist (frame (frame-list))
  	    (face-spec-set-2 face frame value)
! 	    (when (memq (window-system frame) '(x w32 mac ns))
  	      (setq have-window-system t)))
  	  ;; When making a face after frames already exist
  	  (if have-window-system

=== modified file 'lisp/cus-start.el'
*** lisp/cus-start.el	2012-03-07 05:53:51 +0000
--- lisp/cus-start.el	2012-04-02 05:56:16 +0000
*************** Leaving \"Default\" unchecked is equival
*** 263,268 ****
--- 263,305 ----
  	     (suggest-key-bindings keyboard (choice (const :tag "off" nil)
  						    (integer :tag "time" 2)
  						    (other :tag "on")))
+ 	     ;; mac.c
+ 	     (mac-system-move-file-to-trash-use-finder mac boolean "23.4")
+ 	     ;; macselect.c
+ 	     (mac-dnd-known-types mac (repeat string) "22.1")
+ 	     ;; macterm.c
+ 	     (mac-control-modifier mac (choice (const :tag "No modifier" nil)
+ 					       (const control) (const meta)
+ 					       (const alt) (const hyper)
+ 					       (const super)) "22.1")
+ 	     (mac-command-modifier mac (choice (const :tag "No modifier" nil)
+ 					       (const control) (const meta)
+ 					       (const alt) (const hyper)
+ 					       (const super)) "22.1")
+ 	     (mac-option-modifier mac (choice (const :tag "No modifier (work as option)" nil)
+ 					      (const control) (const meta)
+ 					      (const alt) (const hyper)
+ 					      (const super)) "22.1")
+ 	     (mac-function-modifier mac
+ 				    (choice (const :tag "No modifier (work as function)" nil)
+ 					    (const control) (const meta)
+ 					    (const alt) (const hyper)
+ 					    (const super)) "22.1")
+ 	     (mac-emulate-three-button-mouse mac
+ 					     (choice (const :tag "No emulation" nil)
+ 						     (const :tag "Option->2, Command->3" t)
+ 						     (const :tag "Command->2, Option->3" reverse))
+ 				    "22.1")
+ 	     (mac-wheel-button-is-mouse-2 mac boolean "22.1")
+ 	     (mac-pass-command-to-system mac boolean "22.1")
+ 	     (mac-pass-control-to-system mac boolean "22.1")
+ 	     (mac-ts-script-language-on-focus mac
+ 					      (choice (const :tag "System default behavior" nil)
+ 						      (const :tag "Restore to script/language used in the last focus frame" t)
+ 						      (cons :tag "Specify script/language"
+ 							    (integer :tag "Script code")
+ 							    (integer :tag "Language code")))
+ 					      "22.1")
               (debug-on-event debug
                               (choice (const :tag "None" nil)
                                       (const :tag "When sent SIGUSR1" sigusr1)
*************** since it could result in memory overflow
*** 498,503 ****
--- 535,542 ----
  		       (eq system-type 'ms-dos))
  		      ((string-match "\\`w32-" (symbol-name symbol))
  		       (eq system-type 'windows-nt))
+  		      ((string-match "\\`mac-" (symbol-name symbol))
+ 		       (boundp 'mac-carbon-version-string))
  		      ((string-match "\\`ns-" (symbol-name symbol))
  		       (featurep 'ns))
  		      ((string-match "\\`x-.*gtk" (symbol-name symbol))
*************** since it could result in memory overflow
*** 511,517 ****
  		      ((string-match "fringe" (symbol-name symbol))
  		       (fboundp 'define-fringe-bitmap))
  		      ((string-match "\\`imagemagick" (symbol-name symbol))
! 		       (fboundp 'imagemagick-types))
  		      ((equal "font-use-system-font" (symbol-name symbol))
  		       (featurep 'system-font-setting))
  		      ;; Conditioned on x-create-frame, because that's
--- 550,559 ----
  		      ((string-match "fringe" (symbol-name symbol))
  		       (fboundp 'define-fringe-bitmap))
  		      ((string-match "\\`imagemagick" (symbol-name symbol))
! 		       ;; The function `imagemagick-types' exists in
! 		       ;; imagemagick emulation by image-io, but the
! 		       ;; variable `imagemagick-render-type' doesn't.
! 		       (boundp 'imagemagick-render-type))
  		      ((equal "font-use-system-font" (symbol-name symbol))
  		       (featurep 'system-font-setting))
  		      ;; Conditioned on x-create-frame, because that's

=== modified file 'lisp/disp-table.el'
*** lisp/disp-table.el	2012-01-19 07:21:25 +0000
--- lisp/disp-table.el	2012-02-27 23:16:05 +0000
*************** in the default way after this call."
*** 176,182 ****
    "Display character C as character SC in the g1 character set.
  This function assumes that your terminal uses the SO/SI characters;
  it is meaningless for an X frame."
!   (if (memq window-system '(x w32 ns))
        (error "Cannot use string glyphs in a windowing system"))
    (or standard-display-table
        (setq standard-display-table (make-display-table)))
--- 176,182 ----
    "Display character C as character SC in the g1 character set.
  This function assumes that your terminal uses the SO/SI characters;
  it is meaningless for an X frame."
!   (if (memq window-system '(x w32 mac ns))
        (error "Cannot use string glyphs in a windowing system"))
    (or standard-display-table
        (setq standard-display-table (make-display-table)))
*************** it is meaningless for an X frame."
*** 188,194 ****
    "Display character C as character GC in graphics character set.
  This function assumes VT100-compatible escapes; it is meaningless for an
  X frame."
!   (if (memq window-system '(x w32 ns))
        (error "Cannot use string glyphs in a windowing system"))
    (or standard-display-table
        (setq standard-display-table (make-display-table)))
--- 188,194 ----
    "Display character C as character GC in graphics character set.
  This function assumes VT100-compatible escapes; it is meaningless for an
  X frame."
!   (if (memq window-system '(x w32 mac ns))
        (error "Cannot use string glyphs in a windowing system"))
    (or standard-display-table
        (setq standard-display-table (make-display-table)))
*************** in `.emacs'."
*** 276,282 ****
        (progn
  	(standard-display-default
  	 (unibyte-char-to-multibyte 160) (unibyte-char-to-multibyte 255))
! 	(unless (or (memq window-system '(x w32 ns)))
  	  (and (terminal-coding-system)
  	       (set-terminal-coding-system nil))))
  
--- 276,282 ----
        (progn
  	(standard-display-default
  	 (unibyte-char-to-multibyte 160) (unibyte-char-to-multibyte 255))
! 	(unless (or (memq window-system '(x w32 mac ns)))
  	  (and (terminal-coding-system)
  	       (set-terminal-coding-system nil))))
  
*************** in `.emacs'."
*** 288,294 ****
      ;; unless some other has been specified.
      (if (equal current-language-environment "English")
  	(set-language-environment "latin-1"))
!     (unless (or noninteractive (memq window-system '(x w32 ns)))
        ;; Send those codes literally to a character-based terminal.
        ;; If we are using single-byte characters,
        ;; it doesn't matter which coding system we use.
--- 288,294 ----
      ;; unless some other has been specified.
      (if (equal current-language-environment "English")
  	(set-language-environment "latin-1"))
!     (unless (or noninteractive (memq window-system '(x w32 mac ns)))
        ;; Send those codes literally to a character-based terminal.
        ;; If we are using single-byte characters,
        ;; it doesn't matter which coding system we use.

=== modified file 'lisp/erc/erc.el'
*** lisp/erc/erc.el	2012-01-19 07:21:25 +0000
--- lisp/erc/erc.el	2012-02-27 23:30:14 +0000
*************** the message given by REASON."
*** 3349,3354 ****
--- 3349,3355 ----
  				   ((featurep 'gtk)
  				    (concat ", GTK+ Version "
  					    gtk-version-string))
+ 				   ((featurep 'mac) ", Mac")
  				   ((featurep 'x-toolkit) ", X toolkit")
  				   (t ""))
  			     (if (and (boundp 'x-toolkit-scroll-bars)

=== modified file 'lisp/faces.el'
*** lisp/faces.el	2012-03-21 07:02:13 +0000
--- lisp/faces.el	2012-04-02 05:51:12 +0000
*************** specifies an invalid attribute."
*** 315,321 ****
  
  (defun set-face-attributes-from-resources (face frame)
    "Set attributes of FACE from X resources for FRAME."
!   (when (memq (framep frame) '(x w32))
      (dolist (definition face-x-resources)
        (let ((attribute (car definition)))
  	(dolist (entry (cdr definition))
--- 315,321 ----
  
  (defun set-face-attributes-from-resources (face frame)
    "Set attributes of FACE from X resources for FRAME."
!   (when (memq (framep frame) '(x w32 mac))
      (dolist (definition face-x-resources)
        (let ((attribute (car definition)))
  	(dolist (entry (cdr definition))
*************** of a global face.  Value is the new attr
*** 1122,1128 ****
  	       ;; explicitly in VALID, using color approximation code
  	       ;; in tty-colors.el.
  	       (when (and (memq attribute '(:foreground :background))
! 			  (not (memq (window-system frame) '(x w32 ns)))
  			  (not (member new-value
  				       '("unspecified"
  					 "unspecified-fg" "unspecified-bg"))))
--- 1122,1128 ----
  	       ;; explicitly in VALID, using color approximation code
  	       ;; in tty-colors.el.
  	       (when (and (memq attribute '(:foreground :background))
! 			  (not (memq (window-system frame) '(x w32 mac ns)))
  			  (not (member new-value
  				       '("unspecified"
  					 "unspecified-fg" "unspecified-bg"))))
*************** If FRAME is nil, the current FRAME is us
*** 1444,1450 ****
  	    match (cond ((eq req 'type)
  			 (or (memq (window-system frame) options)
  			     (and (memq 'graphic options)
! 				  (memq (window-system frame) '(x w32 ns)))
  			     ;; FIXME: This should be revisited to use
  			     ;; display-graphic-p, provided that the
  			     ;; color selection depends on the number
--- 1444,1450 ----
  	    match (cond ((eq req 'type)
  			 (or (memq (window-system frame) options)
  			     (and (memq 'graphic options)
! 				  (memq (window-system frame) '(x w32 mac ns)))
  			     ;; FIXME: This should be revisited to use
  			     ;; display-graphic-p, provided that the
  			     ;; color selection depends on the number
*************** The argument FRAME specifies which frame
*** 1646,1652 ****
  The value may be different for frames on different display types.
  If FRAME doesn't support colors, the value is nil.
  If FRAME is nil, that stands for the selected frame."
!   (if (memq (framep (or frame (selected-frame))) '(x w32 ns))
        (xw-defined-colors frame)
      (mapcar 'car (tty-color-alist frame))))
  (defalias 'x-defined-colors 'defined-colors)
--- 1646,1652 ----
  The value may be different for frames on different display types.
  If FRAME doesn't support colors, the value is nil.
  If FRAME is nil, that stands for the selected frame."
!   (if (memq (framep (or frame (selected-frame))) '(x w32 mac ns))
        (xw-defined-colors frame)
      (mapcar 'car (tty-color-alist frame))))
  (defalias 'x-defined-colors 'defined-colors)
*************** If COLOR is the symbol `unspecified' or 
*** 1660,1666 ****
  \"unspecified-fg\" or \"unspecified-bg\", the value is nil."
    (if (member color '(unspecified "unspecified-bg" "unspecified-fg"))
        nil
!     (if (member (framep (or frame (selected-frame))) '(x w32 ns))
  	(xw-color-defined-p color frame)
        (numberp (tty-color-translate color frame)))))
  (defalias 'x-color-defined-p 'color-defined-p)
--- 1660,1666 ----
  \"unspecified-fg\" or \"unspecified-bg\", the value is nil."
    (if (member color '(unspecified "unspecified-bg" "unspecified-fg"))
        nil
!     (if (member (framep (or frame (selected-frame))) '(x w32 mac ns))
  	(xw-color-defined-p color frame)
        (numberp (tty-color-translate color frame)))))
  (defalias 'x-color-defined-p 'color-defined-p)
*************** return value is nil."
*** 1686,1692 ****
    (cond
     ((member color '(unspecified "unspecified-fg" "unspecified-bg"))
      nil)
!    ((memq (framep (or frame (selected-frame))) '(x w32 ns))
      (xw-color-values color frame))
     (t
      (tty-color-values color frame))))
--- 1686,1692 ----
    (cond
     ((member color '(unspecified "unspecified-fg" "unspecified-bg"))
      nil)
!    ((memq (framep (or frame (selected-frame))) '(x w32 mac ns))
      (xw-color-values color frame))
     (t
      (tty-color-values color frame))))
*************** return value is nil."
*** 1700,1706 ****
  The optional argument DISPLAY specifies which display to ask about.
  DISPLAY should be either a frame or a display name (a string).
  If omitted or nil, that stands for the selected frame's display."
!   (if (memq (framep-on-display display) '(x w32 ns))
        (xw-display-color-p display)
      (tty-display-color-p display)))
  (defalias 'x-display-color-p 'display-color-p)
--- 1700,1706 ----
  The optional argument DISPLAY specifies which display to ask about.
  DISPLAY should be either a frame or a display name (a string).
  If omitted or nil, that stands for the selected frame's display."
!   (if (memq (framep-on-display display) '(x w32 mac ns))
        (xw-display-color-p display)
      (tty-display-color-p display)))
  (defalias 'x-display-color-p 'display-color-p)
*************** If omitted or nil, that stands for the s
*** 1711,1717 ****
    "Return non-nil if frames on DISPLAY can display shades of gray."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 ns))
        (x-display-grayscale-p display))
       (t
        (> (tty-color-gray-shades display) 2)))))
--- 1711,1717 ----
    "Return non-nil if frames on DISPLAY can display shades of gray."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 mac ns))
        (x-display-grayscale-p display))
       (t
        (> (tty-color-gray-shades display) 2)))))
*************** Calculate the face definitions using the
*** 1932,1938 ****
  settings, X resources, and `face-new-frame-defaults'.
  Finally, apply any relevant face attributes found amongst the
  frame parameters in PARAMETERS."
!   (let ((window-system-p (memq (window-system frame) '(x w32))))
      ;; The `reverse' is so that `default' goes first.
      (dolist (face (nreverse (face-list)))
        (condition-case ()
--- 1932,1938 ----
  settings, X resources, and `face-new-frame-defaults'.
  Finally, apply any relevant face attributes found amongst the
  frame parameters in PARAMETERS."
!   (let ((window-system-p (memq (window-system frame) '(x w32 mac))))
      ;; The `reverse' is so that `default' goes first.
      (dolist (face (nreverse (face-list)))
        (condition-case ()
*************** Note: Other faces cannot inherit from th
*** 2401,2407 ****
    '((default
       :box (:line-width 1 :style released-button)
       :foreground "black")
!     (((type x w32 ns) (class color))
       :background "grey75")
      (((type x) (class mono))
       :background "grey"))
--- 2401,2407 ----
    '((default
       :box (:line-width 1 :style released-button)
       :foreground "black")
!     (((type x w32 mac ns) (class color))
       :background "grey75")
      (((type x) (class mono))
       :background "grey"))

=== modified file 'lisp/frame.el'
*** lisp/frame.el	2012-02-01 08:13:02 +0000
--- lisp/frame.el	2012-02-27 23:16:05 +0000
*************** recently selected windows nor the buffer
*** 762,768 ****
    (select-frame frame norecord)
    (raise-frame frame)
    ;; Ensure, if possible, that FRAME gets input focus.
!   (when (memq (window-system frame) '(x w32 ns))
      (x-focus-frame frame))
    ;; Move mouse cursor if necessary.
    (cond
--- 762,768 ----
    (select-frame frame norecord)
    (raise-frame frame)
    ;; Ensure, if possible, that FRAME gets input focus.
!   (when (memq (window-system frame) '(x mac w32 ns))
      (x-focus-frame frame))
    ;; Move mouse cursor if necessary.
    (cond
*************** Calls `suspend-emacs' if invoked from th
*** 816,822 ****
    (interactive)
    (let ((type (framep (selected-frame))))
      (cond
!      ((memq type '(x ns w32)) (iconify-or-deiconify-frame))
       ((eq type t)
        (if (controlling-tty-p)
  	  (suspend-emacs)
--- 816,822 ----
    (interactive)
    (let ((type (framep (selected-frame))))
      (cond
!      ((memq type '(x ns w32 mac)) (iconify-or-deiconify-frame))
       ((eq type t)
        (if (controlling-tty-p)
  	  (suspend-emacs)
*************** frame's display)."
*** 1263,1270 ****
       ((eq system-type 'windows-nt)
        (with-no-warnings
         (> w32-num-mouse-buttons 0)))
!      ((memq frame-type '(x ns))
!       t)    ;; We assume X and NeXTstep *always* have a pointing device
       (t
        (or (and (featurep 'xt-mouse)
  	       xterm-mouse-mode)
--- 1263,1270 ----
       ((eq system-type 'windows-nt)
        (with-no-warnings
         (> w32-num-mouse-buttons 0)))
!      ((memq frame-type '(x mac ns))
!       t)    ;; We assume X, Mac, and NeXTstep *always* have a pointing device
       (t
        (or (and (featurep 'xt-mouse)
  	       xterm-mouse-mode)
*************** frame's display).
*** 1279,1285 ****
  Support for popup menus requires that the mouse be available."
    (and
     (let ((frame-type (framep-on-display display)))
!      (memq frame-type '(x w32 pc ns)))
     (display-mouse-p display)))
  
  (defun display-graphic-p (&optional display)
--- 1279,1285 ----
  Support for popup menus requires that the mouse be available."
    (and
     (let ((frame-type (framep-on-display display)))
!      (memq frame-type '(x w32 pc mac ns)))
     (display-mouse-p display)))
  
  (defun display-graphic-p (&optional display)
*************** frames and several different fonts at on
*** 1289,1295 ****
  that use a window system such as X, and false for text-only terminals.
  DISPLAY can be a display name, a frame, or nil (meaning the selected
  frame's display)."
!   (not (null (memq (framep-on-display display) '(x w32 ns)))))
  
  (defun display-images-p (&optional display)
    "Return non-nil if DISPLAY can display images.
--- 1289,1295 ----
  that use a window system such as X, and false for text-only terminals.
  DISPLAY can be a display name, a frame, or nil (meaning the selected
  frame's display)."
!   (not (null (memq (framep-on-display display) '(x w32 mac ns)))))
  
  (defun display-images-p (&optional display)
    "Return non-nil if DISPLAY can display images.
*************** frame's display)."
*** 1316,1322 ****
        ;; the Windows' DOS Box.
        (with-no-warnings
         (not (null dos-windows-version))))
!      ((memq frame-type '(x w32 ns))
        t)    ;; FIXME?
       (t
        nil))))
--- 1316,1322 ----
        ;; the Windows' DOS Box.
        (with-no-warnings
         (not (null dos-windows-version))))
!      ((memq frame-type '(x w32 mac ns))
        t)    ;; FIXME?
       (t
        nil))))
*************** frame's display)."
*** 1327,1333 ****
    "Return the number of screens associated with DISPLAY."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 ns))
        (x-display-screens display))
       (t
        1))))
--- 1327,1333 ----
    "Return the number of screens associated with DISPLAY."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 mac ns))
        (x-display-screens display))
       (t
        1))))
*************** frame's display)."
*** 1339,1345 ****
  For character terminals, each character counts as a single pixel."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 ns))
        (x-display-pixel-height display))
       (t
        (frame-height (if (framep display) display (selected-frame)))))))
--- 1339,1345 ----
  For character terminals, each character counts as a single pixel."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 mac ns))
        (x-display-pixel-height display))
       (t
        (frame-height (if (framep display) display (selected-frame)))))))
*************** For character terminals, each character 
*** 1351,1357 ****
  For character terminals, each character counts as a single pixel."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 ns))
        (x-display-pixel-width display))
       (t
        (frame-width (if (framep display) display (selected-frame)))))))
--- 1351,1357 ----
  For character terminals, each character counts as a single pixel."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 mac ns))
        (x-display-pixel-width display))
       (t
        (frame-width (if (framep display) display (selected-frame)))))))
*************** displays not explicitly specified."
*** 1380,1386 ****
    "Return the height of DISPLAY's screen in millimeters.
  System values can be overridden by `display-mm-dimensions-alist'.
  If the information is unavailable, value is nil."
!   (and (memq (framep-on-display display) '(x w32 ns))
         (or (cddr (assoc (or display (frame-parameter nil 'display))
  			display-mm-dimensions-alist))
  	   (cddr (assoc t display-mm-dimensions-alist))
--- 1380,1386 ----
    "Return the height of DISPLAY's screen in millimeters.
  System values can be overridden by `display-mm-dimensions-alist'.
  If the information is unavailable, value is nil."
!   (and (memq (framep-on-display display) '(x w32 mac ns))
         (or (cddr (assoc (or display (frame-parameter nil 'display))
  			display-mm-dimensions-alist))
  	   (cddr (assoc t display-mm-dimensions-alist))
*************** If the information is unavailable, value
*** 1392,1398 ****
    "Return the width of DISPLAY's screen in millimeters.
  System values can be overridden by `display-mm-dimensions-alist'.
  If the information is unavailable, value is nil."
!   (and (memq (framep-on-display display) '(x w32 ns))
         (or (cadr (assoc (or display (frame-parameter nil 'display))
  			display-mm-dimensions-alist))
  	   (cadr (assoc t display-mm-dimensions-alist))
--- 1392,1398 ----
    "Return the width of DISPLAY's screen in millimeters.
  System values can be overridden by `display-mm-dimensions-alist'.
  If the information is unavailable, value is nil."
!   (and (memq (framep-on-display display) '(x w32 mac ns))
         (or (cadr (assoc (or display (frame-parameter nil 'display))
  			display-mm-dimensions-alist))
  	   (cadr (assoc t display-mm-dimensions-alist))
*************** The value may be `always', `when-mapped'
*** 1406,1412 ****
  the question is inapplicable to a certain kind of display."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 ns))
        (x-display-backing-store display))
       (t
        'not-useful))))
--- 1406,1412 ----
  the question is inapplicable to a certain kind of display."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 mac ns))
        (x-display-backing-store display))
       (t
        'not-useful))))
*************** the question is inapplicable to a certai
*** 1417,1423 ****
    "Return non-nil if DISPLAY's screen supports the SaveUnder feature."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 ns))
        (x-display-save-under display))
       (t
        'not-useful))))
--- 1417,1423 ----
    "Return non-nil if DISPLAY's screen supports the SaveUnder feature."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 mac ns))
        (x-display-save-under display))
       (t
        'not-useful))))
*************** the question is inapplicable to a certai
*** 1428,1434 ****
    "Return the number of planes supported by DISPLAY."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 ns))
        (x-display-planes display))
       ((eq frame-type 'pc)
        4)
--- 1428,1434 ----
    "Return the number of planes supported by DISPLAY."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 mac ns))
        (x-display-planes display))
       ((eq frame-type 'pc)
        4)
*************** the question is inapplicable to a certai
*** 1441,1447 ****
    "Return the number of color cells supported by DISPLAY."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 ns))
        (x-display-color-cells display))
       ((eq frame-type 'pc)
        16)
--- 1441,1447 ----
    "Return the number of color cells supported by DISPLAY."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 mac ns))
        (x-display-color-cells display))
       ((eq frame-type 'pc)
        16)
*************** The value is one of the symbols `static-
*** 1456,1462 ****
  `static-color', `pseudo-color', `true-color', or `direct-color'."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 ns))
        (x-display-visual-class display))
       ((and (memq frame-type '(pc t))
  	   (tty-display-color-p display))
--- 1456,1462 ----
  `static-color', `pseudo-color', `true-color', or `direct-color'."
    (let ((frame-type (framep-on-display display)))
      (cond
!      ((memq frame-type '(x w32 mac ns))
        (x-display-visual-class display))
       ((and (memq frame-type '(pc t))
  	   (tty-display-color-p display))
*************** terminals, cursor blinking is controlled
*** 1638,1644 ****
    :init-value (not (or noninteractive
  		       no-blinking-cursor
  		       (eq system-type 'ms-dos)
! 		       (not (memq window-system '(x w32 ns)))))
    :initialize 'custom-initialize-delay
    :group 'cursor
    :global t
--- 1638,1644 ----
    :init-value (not (or noninteractive
  		       no-blinking-cursor
  		       (eq system-type 'ms-dos)
! 		       (not (memq window-system '(x w32 mac ns)))))
    :initialize 'custom-initialize-delay
    :group 'cursor
    :global t

=== modified file 'lisp/info.el'
*** lisp/info.el	2012-03-21 16:56:55 +0000
--- lisp/info.el	2012-04-02 05:51:12 +0000
*************** the variable `Info-file-list-for-emacs'.
*** 4457,4463 ****
            ;; This is a serious problem for trying to handle multiple
            ;; frame types at once.  We want this text to be invisible
            ;; on frames that can display the font above.
!           (when (memq (framep (selected-frame)) '(x pc w32 ns))
              (add-text-properties (1- (match-beginning 2)) (match-end 2)
                                   '(invisible t front-sticky nil rear-nonsticky t)))))
  
--- 4457,4463 ----
            ;; This is a serious problem for trying to handle multiple
            ;; frame types at once.  We want this text to be invisible
            ;; on frames that can display the font above.
!           (when (memq (framep (selected-frame)) '(x pc w32 mac ns))
              (add-text-properties (1- (match-beginning 2)) (match-end 2)
                                   '(invisible t front-sticky nil rear-nonsticky t)))))
  

=== modified file 'lisp/international/mule-cmds.el'
*** lisp/international/mule-cmds.el	2012-04-14 18:14:01 +0000
--- lisp/international/mule-cmds.el	2012-04-28 00:30:28 +0000
***************
*** 35,41 ****
  (defvar dos-codepage)
  (autoload 'widget-value "wid-edit")
  
! (defvar mac-system-coding-system)
  
  ;;; MULE related key bindings and menus.
  
--- 35,41 ----
  (defvar dos-codepage)
  (autoload 'widget-value "wid-edit")
  
! (defvar mac-system-locale)
  
  ;;; MULE related key bindings and menus.
  
***************
*** 94,100 ****
          :help ,(purecopy "How to decode keyboard input")))
      (define-key-after map [set-terminal-coding-system]
        `(menu-item ,(purecopy "For Terminal") set-terminal-coding-system
!         :enable (null (memq initial-window-system '(x w32 ns)))
          :help ,(purecopy "How to encode terminal output")))
      (define-key-after map [separator-3] menu-bar-separator)
  
--- 94,100 ----
          :help ,(purecopy "How to decode keyboard input")))
      (define-key-after map [set-terminal-coding-system]
        `(menu-item ,(purecopy "For Terminal") set-terminal-coding-system
!         :enable (null (memq initial-window-system '(x w32 mac ns)))
          :help ,(purecopy "How to encode terminal output")))
      (define-key-after map [separator-3] menu-bar-separator)
  
*************** See also `locale-charset-language-names'
*** 2561,2566 ****
--- 2561,2578 ----
  		    (= 0 (length locale))) ; nil or empty string
  	  (setq locale (getenv (pop vars) frame)))))
  
+     (unless locale
+       ;; The two tests are kept separate so the byte-compiler sees
+       ;; that mac-get-preference is only called after checking its existence.
+       (when (fboundp 'mac-get-preference)
+         (setq locale (mac-get-preference "AppleLocale"))
+         (unless locale
+           (let ((languages (mac-get-preference "AppleLanguages")))
+             (unless (= (length languages) 0) ; nil or empty vector
+               (setq locale (aref languages 0)))))))
+     (unless (or locale (not (boundp 'mac-system-locale)))
+       (setq locale mac-system-locale))
+ 
      (when locale
        (setq locale (locale-translate locale))
  

=== modified file 'lisp/loadup.el'
*** lisp/loadup.el	2012-01-19 07:21:25 +0000
--- lisp/loadup.el	2012-02-27 23:16:05 +0000
***************
*** 226,231 ****
--- 226,235 ----
        (load "term/pc-win")
        (load "ls-lisp")
        (load "disp-table"))) ; needed to setup ibm-pc char set, see internal.el
+ (if (featurep 'mac)
+     (progn
+       (load "term/common-win")
+       (load "term/mac-win")))
  (if (featurep 'ns)
      (progn
        (load "term/common-win")

=== modified file 'lisp/mail/emacsbug.el'
*** lisp/mail/emacsbug.el	2012-04-04 01:05:29 +0000
--- lisp/mail/emacsbug.el	2012-04-28 00:30:28 +0000
***************
*** 48,53 ****
--- 48,58 ----
    :group 'emacsbug
    :type 'string)
  
+ (defcustom report-emacs-bug-mac-address "mituharu+bug-gnu-emacs-mac@math.s.chiba-u.ac.jp"
+   "Address for reporting GNU Emacs Mac port specific bugs."
+   :group 'emacsbug
+   :type 'string)
+ 
  (defcustom report-emacs-bug-no-confirmation nil
    "If non-nil, suppress the confirmations asked for the sake of novice users."
    :group 'emacsbug
*************** Prompts for bug subject.  Leaves you in 
*** 159,177 ****
        (setq topic (concat emacs-version "; " topic))
      (when (string-match "^\\(\\([.0-9]+\\)*\\)\\.[0-9]+$" emacs-version)
        (setq topic (concat (match-string 1 emacs-version) "; " topic))))
!   (let ((from-buffer (current-buffer))
!         ;; Put these properties on semantically-void text.
!         ;; report-emacs-bug-hook deletes these regions before sending.
!         (prompt-properties '(field emacsbug-prompt
!                              intangible but-helpful
!                              rear-nonsticky t))
! 	(can-insert-mail (or (report-emacs-bug-can-use-xdg-email)
! 			     (report-emacs-bug-can-use-osx-open)))
!         user-point message-end-point)
      (setq message-end-point
  	  (with-current-buffer (get-buffer-create "*Messages*")
  	    (point-max-marker)))
!     (compose-mail report-emacs-bug-address topic)
      ;; The rest of this does not execute if the user was asked to
      ;; confirm and said no.
      (when (eq major-mode 'message-mode)
--- 164,186 ----
        (setq topic (concat emacs-version "; " topic))
      (when (string-match "^\\(\\([.0-9]+\\)*\\)\\.[0-9]+$" emacs-version)
        (setq topic (concat (match-string 1 emacs-version) "; " topic))))
!   (let* ((mac-port-p (featurep 'mac))
! 	 (reporting-address (if mac-port-p
! 				report-emacs-bug-mac-address
! 			      report-emacs-bug-address))
! 	 (from-buffer (current-buffer))
! 	 ;; Put these properties on semantically-void text.
! 	 ;; report-emacs-bug-hook deletes these regions before sending.
! 	 (prompt-properties '(field emacsbug-prompt
! 			      intangible but-helpful
! 			      rear-nonsticky t))
! 	 (can-insert-mail (or (report-emacs-bug-can-use-xdg-email)
! 			      (report-emacs-bug-can-use-osx-open)))
! 	 user-point message-end-point)
      (setq message-end-point
  	  (with-current-buffer (get-buffer-create "*Messages*")
  	    (point-max-marker)))
!     (compose-mail reporting-address topic)
      ;; The rest of this does not execute if the user was asked to
      ;; confirm and said no.
      (when (eq major-mode 'message-mode)
*************** Prompts for bug subject.  Leaves you in 
*** 190,198 ****
        (backward-char (length signature)))
      (unless report-emacs-bug-no-explanations
        ;; Insert warnings for novice users.
!       (if (not (equal "bug-gnu-emacs@gnu.org" report-emacs-bug-address))
! 	  (insert (format "The report will be sent to %s.\n\n"
! 			  report-emacs-bug-address))
  	(insert "This bug report will be sent to the ")
  	(insert-button
  	 "Bug-GNU-Emacs"
--- 199,215 ----
        (backward-char (length signature)))
      (unless report-emacs-bug-no-explanations
        ;; Insert warnings for novice users.
!       (if (not (equal "bug-gnu-emacs@gnu.org" reporting-address))
! 	  (progn
! 	    (insert (format "The report will be sent to %s.\n\n"
! 			    reporting-address))
! 	    (when mac-port-p
! 	      (insert "Please make sure that the bug is ")
! 	      (let ((pos (point)))
! 		(insert "specific to the Mac port")
! 		(put-text-property pos (point) 'face 'highlight))
! 	      (insert ".\nOther bugs should be sent to the place you are guided with\n"
! 		      "M-x report-emacs-bug on some official ports such as X11 or NS.\n\n")))
  	(insert "This bug report will be sent to the ")
  	(insert-button
  	 "Bug-GNU-Emacs"

=== modified file 'lisp/menu-bar.el'
*** lisp/menu-bar.el	2012-01-31 08:38:58 +0000
--- lisp/menu-bar.el	2012-02-27 23:16:05 +0000
*************** See `menu-bar-mode' for more information
*** 2203,2208 ****
--- 2203,2209 ----
  
  (declare-function x-menu-bar-open "term/x-win" (&optional frame))
  (declare-function w32-menu-bar-open "term/w32-win" (&optional frame))
+ (declare-function mac-menu-bar-open "term/mac-win" (&optional frame))
  
  (defun menu-bar-open (&optional frame)
    "Start key navigation of the menu bar in FRAME.
*************** If FRAME is nil or not given, use the se
*** 2218,2223 ****
--- 2219,2225 ----
      (cond
       ((eq type 'x) (x-menu-bar-open frame))
       ((eq type 'w32) (w32-menu-bar-open frame))
+      ((eq type 'mac) (mac-menu-bar-open frame))
       (t (with-selected-frame (or frame (selected-frame))
            (tmm-menubar))))))
  

=== modified file 'lisp/mwheel.el'
*** lisp/mwheel.el	2012-03-24 11:05:39 +0000
--- lisp/mwheel.el	2012-04-02 05:51:12 +0000
***************
*** 57,63 ****
                          'mouse-wheel-down-event
  			"22.1")
  (defcustom mouse-wheel-down-event
!   (if (or (featurep 'w32-win) (featurep 'ns-win))
        'wheel-up
      (intern (format "mouse-%s" mouse-wheel-down-button)))
    "Event used for scrolling down."
--- 57,63 ----
                          'mouse-wheel-down-event
  			"22.1")
  (defcustom mouse-wheel-down-event
!   (if (or (featurep 'w32-win) (featurep 'mac-win) (featurep 'ns-win))
        'wheel-up
      (intern (format "mouse-%s" mouse-wheel-down-button)))
    "Event used for scrolling down."
***************
*** 70,76 ****
                          'mouse-wheel-up-event
  			"22.1")
  (defcustom mouse-wheel-up-event
!   (if (or (featurep 'w32-win) (featurep 'ns-win))
        'wheel-down
      (intern (format "mouse-%s" mouse-wheel-up-button)))
    "Event used for scrolling up."
--- 70,76 ----
                          'mouse-wheel-up-event
  			"22.1")
  (defcustom mouse-wheel-up-event
!   (if (or (featurep 'w32-win) (featurep 'mac-win) (featurep 'ns-win))
        'wheel-down
      (intern (format "mouse-%s" mouse-wheel-up-button)))
    "Event used for scrolling up."

=== modified file 'lisp/simple.el'
*** lisp/simple.el	2012-04-22 07:19:29 +0000
--- lisp/simple.el	2012-04-28 00:30:28 +0000
*************** call `normal-erase-is-backspace-mode' (w
*** 6704,6710 ****
         (if (if (eq normal-erase-is-backspace 'maybe)
                 (and (not noninteractive)
                      (or (memq system-type '(ms-dos windows-nt))
! 			(memq window-system '(ns))
                          (and (memq window-system '(x))
                               (fboundp 'x-backspace-delete-keys-p)
                               (x-backspace-delete-keys-p))
--- 6704,6710 ----
         (if (if (eq normal-erase-is-backspace 'maybe)
                 (and (not noninteractive)
                      (or (memq system-type '(ms-dos windows-nt))
! 			(memq window-system '(mac ns))
                          (and (memq window-system '(x))
                               (fboundp 'x-backspace-delete-keys-p)
                               (x-backspace-delete-keys-p))
*************** See also `normal-erase-is-backspace'."
*** 6752,6758 ****
    (let ((enabled (eq 1 (terminal-parameter
                          nil 'normal-erase-is-backspace))))
  
!     (cond ((or (memq window-system '(x w32 ns pc))
  	       (memq system-type '(ms-dos windows-nt)))
  	   (let ((bindings
  		  `(([M-delete] [M-backspace])
--- 6752,6758 ----
    (let ((enabled (eq 1 (terminal-parameter
                          nil 'normal-erase-is-backspace))))
  
!     (cond ((or (memq window-system '(x w32 mac ns pc))
  	       (memq system-type '(ms-dos windows-nt)))
  	   (let ((bindings
  		  `(([M-delete] [M-backspace])

=== modified file 'lisp/startup.el'
*** lisp/startup.el	2012-04-20 09:41:27 +0000
--- lisp/startup.el	2012-04-28 00:30:28 +0000
*************** Amongst another things, it parses the co
*** 909,915 ****
        (setq menu-bar-mode nil
  	    tool-bar-mode nil
  	    no-blinking-cursor t))
!      ((memq initial-window-system '(x w32 ns))
        (let ((no-vals  '("no" "off" "false" "0")))
  	(if (member (x-get-resource "menuBar" "MenuBar") no-vals)
  	    (setq menu-bar-mode nil))
--- 909,915 ----
        (setq menu-bar-mode nil
  	    tool-bar-mode nil
  	    no-blinking-cursor t))
!      ((memq initial-window-system '(x w32 mac ns))
        (let ((no-vals  '("no" "off" "false" "0")))
  	(if (member (x-get-resource "menuBar" "MenuBar") no-vals)
  	    (setq menu-bar-mode nil))
*************** Amongst another things, it parses the co
*** 937,943 ****
    ;; only because all other settings of no-blinking-cursor are here.
    (unless (or noninteractive
  	      emacs-basic-display
! 	      (and (memq window-system '(x w32 ns))
  		   (not (member (x-get-resource "cursorBlink" "CursorBlink")
  				'("no" "off" "false" "0")))))
      (setq no-blinking-cursor t))
--- 937,943 ----
    ;; only because all other settings of no-blinking-cursor are here.
    (unless (or noninteractive
  	      emacs-basic-display
! 	      (and (memq window-system '(x w32 mac ns))
  		   (not (member (x-get-resource "cursorBlink" "CursorBlink")
  				'("no" "off" "false" "0")))))
      (setq no-blinking-cursor t))
*************** a face or button specification."
*** 1515,1521 ****
  				   (if (image-type-available-p 'xpm)
  				       "splash.xpm"
  				     "splash.pbm"))
! 				  ((image-type-available-p 'svg)
  				   "splash.svg")
  				  ((image-type-available-p 'png)
  				   "splash.png")
--- 1515,1528 ----
  				   (if (image-type-available-p 'xpm)
  				       "splash.xpm"
  				     "splash.pbm"))
! 				  ((and
! 				    ;; It takes time to setup WebKit
! 				    ;; for SVG images on the first
! 				    ;; invocation of the Mac port.  We
! 				    ;; avoid it for startup.
! 				    (or (not (eq initial-window-system 'mac))
! 					(string-match "About" (buffer-name)))
! 				    (image-type-available-p 'svg))
  				   "splash.svg")
  				  ((image-type-available-p 'png)
  				   "splash.png")

=== modified file 'lisp/term/common-win.el'
*** lisp/term/common-win.el	2012-01-19 07:21:25 +0000
--- lisp/term/common-win.el	2012-02-27 23:35:12 +0000
*************** is not used)."
*** 68,74 ****
  	 (setq ns-last-selected-text text))
  	(t
  	 ;; With multi-tty, this function may be called from a tty frame.
! 	 (when (eq (framep (selected-frame)) 'x)
  	   (when x-select-enable-primary
  	     (x-set-selection 'PRIMARY text)
  	     (setq x-last-selected-text-primary text))
--- 68,74 ----
  	 (setq ns-last-selected-text text))
  	(t
  	 ;; With multi-tty, this function may be called from a tty frame.
! 	 (when (memq (framep (selected-frame)) '(x mac))
  	   (when x-select-enable-primary
  	     (x-set-selection 'PRIMARY text)
  	     (setq x-last-selected-text-primary text))

=== modified file 'lisp/version.el'
*** lisp/version.el	2012-02-09 07:48:22 +0000
--- lisp/version.el	2012-02-27 23:16:05 +0000
*************** to the system configuration; look at `sy
*** 60,65 ****
--- 60,67 ----
  		       ((featurep 'gtk)
  			(concat ", GTK+ Version " gtk-version-string))
  		       ((featurep 'x-toolkit) ", X toolkit")
+ 		       ((boundp 'mac-carbon-version-string)
+ 			(concat ", Carbon Version " mac-carbon-version-string))
  		       ((featurep 'ns)
  			(format ", NS %s" ns-version-string))
  		       (t ""))

=== modified file 'src/Makefile.in'
*** src/Makefile.in	2012-01-19 07:21:25 +0000
--- src/Makefile.in	2012-02-28 00:22:39 +0000
*************** C_SWITCH_MACHINE=@C_SWITCH_MACHINE@
*** 74,80 ****
  ## System-specific CFLAGS.
  C_SWITCH_SYSTEM=@C_SWITCH_SYSTEM@
  
! ## Currently only set if NS_IMPL_GNUSTEP.
  ## C_SWITCH_X_SITE may override this.
  C_SWITCH_X_SYSTEM=@C_SWITCH_X_SYSTEM@
  
--- 74,80 ----
  ## System-specific CFLAGS.
  C_SWITCH_SYSTEM=@C_SWITCH_SYSTEM@
  
! ## Currently only set if HAVE_MACGUI or NS_IMPL_GNUSTEP.
  ## C_SWITCH_X_SITE may override this.
  C_SWITCH_X_SYSTEM=@C_SWITCH_X_SYSTEM@
  
*************** MSDOS_OBJ =
*** 246,251 ****
--- 246,257 ----
  ## w16select.o termcap.o if MSDOS && HAVE_X_WINDOWS.
  MSDOS_X_OBJ =
  
+ ## mac.o macterm.o macfns.o macmenu.o macselect.o macfont.o fontset.o
+ ## fringe.o image.o if HAVE_MACGUI, otherwise empty.
+ MAC_OBJ=@MAC_OBJ@
+ ## macappkit.o if HAVE_MACGUI, otherwise empty.
+ MAC_OBJC_OBJ=@MAC_OBJC_OBJ@
+ 
  ns_appdir=@ns_appdir@
  ns_appbindir=@ns_appbindir@
  ns_appsrc=@ns_appsrc@
*************** base_obj = dispnew.o frame.o scroll.o xd
*** 340,347 ****
  	process.o gnutls.o callproc.o \
  	region-cache.o sound.o atimer.o \
  	doprnt.o intervals.o textprop.o composite.o xml.o \
! 	$(MSDOS_OBJ) $(MSDOS_X_OBJ) $(NS_OBJ) $(CYGWIN_OBJ) $(FONT_OBJ)
! obj = $(base_obj) $(NS_OBJC_OBJ)
  
  ## Object files used on some machine or other.
  ## These go in the DOC file on all machines in case they are needed.
--- 346,353 ----
  	process.o gnutls.o callproc.o \
  	region-cache.o sound.o atimer.o \
  	doprnt.o intervals.o textprop.o composite.o xml.o \
! 	$(MSDOS_OBJ) $(MSDOS_X_OBJ) $(MAC_OBJ) $(NS_OBJ) $(CYGWIN_OBJ) $(FONT_OBJ)
! obj = $(base_obj) $(MAC_OBJC_OBJ) $(NS_OBJC_OBJ)
  
  ## Object files used on some machine or other.
  ## These go in the DOC file on all machines in case they are needed.
*************** obj = $(base_obj) $(NS_OBJC_OBJ)
*** 349,355 ****
  ## in the list, in case they ever add any such entries.
  SOME_MACHINE_OBJECTS = dosfns.o msdos.o \
    xterm.o xfns.o xmenu.o xselect.o xrdb.o xsmfns.o fringe.o image.o \
!   fontset.o dbusbind.o \
    nsterm.o nsfns.o nsmenu.o nsselect.o nsimage.o nsfont.o \
    w32.o w32console.o w32fns.o w32heap.o w32inevt.o \
    w32menu.o w32proc.o w32reg.o w32select.o w32term.o w32xfns.o \
--- 355,361 ----
  ## in the list, in case they ever add any such entries.
  SOME_MACHINE_OBJECTS = dosfns.o msdos.o \
    xterm.o xfns.o xmenu.o xselect.o xrdb.o xsmfns.o fringe.o image.o \
!   mac.o macterm.o macfns.o macmenu.o macselect.o fontset.o dbusbind.o \
    nsterm.o nsfns.o nsmenu.o nsselect.o nsimage.o nsfont.o \
    w32.o w32console.o w32fns.o w32heap.o w32inevt.o \
    w32menu.o w32proc.o w32reg.o w32select.o w32term.o w32xfns.o \
*************** buildobj.h: Makefile
*** 437,443 ****
  
  globals.h: gl-stamp; @true
  
! GLOBAL_SOURCES = $(base_obj:.o=.c) $(NS_OBJC_OBJ:.o=.m)
  
  gl-stamp: $(libsrc)/make-docfile$(EXEEXT) $(GLOBAL_SOURCES)
  	@rm -f gl-tmp
--- 443,449 ----
  
  globals.h: gl-stamp; @true
  
! GLOBAL_SOURCES = $(base_obj:.o=.c) $(MAC_OBJC_OBJ:.o=.m) $(NS_OBJC_OBJ:.o=.m)
  
  gl-stamp: $(libsrc)/make-docfile$(EXEEXT) $(GLOBAL_SOURCES)
  	@rm -f gl-tmp
*************** $(OLDXMENU): $(OLDXMENU_TARGET)
*** 491,496 ****
--- 497,504 ----
  
  doc.o: buildobj.h
  
+ ## If HAVE_MACGUI, some Mac-specific rules are inserted here.
+ @mac_frag@
  
  ## If HAVE_NS, some ns-specific rules (for OTHER_FILES) are inserted here.
  @ns_frag@

=== modified file 'src/alloc.c'
*** src/alloc.c	2012-03-03 04:18:09 +0000
--- src/alloc.c	2012-04-02 05:51:12 +0000
*************** static int malloc_hysteresis;
*** 204,209 ****
--- 204,212 ----
     remapping on more recent systems because this is less important
     nowadays than in the days of small memories and timesharing.  */
  
+ #ifdef PURE_SECTION
+ __attribute__((section (PURE_SECTION)))
+ #endif
  EMACS_INT pure[(PURESIZE + sizeof (EMACS_INT) - 1) / sizeof (EMACS_INT)] = {1,};
  #define PUREBEG (char *) pure
  
*************** INIT must be an integer that represents 
*** 2371,2377 ****
  	}
      }
  
!   *p = 0;
    return val;
  }
  
--- 2374,2381 ----
  	}
      }
  
!   if (nbytes)
!     *p = 0;
    return val;
  }
  

=== modified file 'src/atimer.c'
*** src/atimer.c	2012-01-19 07:21:25 +0000
--- src/atimer.c	2012-02-27 23:16:05 +0000
*************** run_timers (void)
*** 351,357 ****
--- 351,359 ----
  
        t = atimers;
        atimers = atimers->next;
+ #ifndef DARWIN_OS
        t->fn (t);
+ #endif
  
        if (t->type == ATIMER_CONTINUOUS)
  	{
*************** run_timers (void)
*** 363,368 ****
--- 365,374 ----
  	  t->next = free_atimers;
  	  free_atimers = t;
  	}
+ #ifdef DARWIN_OS
+       /* Fix for Ctrl-G.  Perhaps this should apply to all platforms. */
+       t->fn (t); 
+ #endif
  
        EMACS_GET_TIME (now);
      }

=== modified file 'src/character.h'
*** src/character.h	2012-04-06 13:10:30 +0000
--- src/character.h	2012-04-28 00:30:28 +0000
*************** along with GNU Emacs.  If not, see <http
*** 120,133 ****
    do {					\
      Lisp_Object tmp = XCAR (x);		\
      CHECK_CHARACTER (tmp);		\
-     XSETCAR ((x), tmp);			\
    } while (0)
  
  #define CHECK_CHARACTER_CDR(x) \
    do {					\
      Lisp_Object tmp = XCDR (x);		\
      CHECK_CHARACTER (tmp);		\
-     XSETCDR ((x), tmp);			\
    } while (0)
  
  /* Nonzero iff C is a character of code less than 0x100.  */
--- 120,131 ----

=== modified file 'src/deps.mk'
*** src/deps.mk	2012-01-05 09:46:05 +0000
--- src/deps.mk	2012-02-28 00:25:16 +0000
*************** intervals.o: intervals.c buffer.h $(INTE
*** 303,307 ****
--- 303,338 ----
  textprop.o: textprop.c buffer.h window.h $(INTERVALS_H) \
     lisp.h globals.h $(config_h)
  
+ ## Mac support.
+ alloc.o buffer.o bytecode.o callint.o callproc.o cm.o cmds.o coding.o \
+   composite.o data.o dispnew.o editfns.o emacs.o eval.o fileio.o fns.o font.o \
+   fontset.o frame.o fringe.o image.o indent.o insdel.o intervals.o keyboard.o \
+   keymap.o lread.o macros.o menu.o minibuf.o print.o process.o scroll.o \
+   search.o syntax.o sysdep.o term.o terminal.o textprop.o undo.o window.o \
+   xdisp.o xfaces.o: macgui.h
+ mac.o: mac.c process.h systime.h sysselect.h blockinput.h atimer.h macterm.h \
+   macgui.h frame.h dispextern.h charset.h coding.h composite.h lisp.h \
+   $(config_h)
+ macfont.o: macfont.c dispextern.h macgui.h macterm.h frame.h blockinput.h \
+   atimer.h systime.h character.h charset.h composite.h fontset.h font.h ccl.h \
+   macfont.h macuvs.h lisp.h $(config_h)
+ macfns.o: macfns.c macterm.h macgui.h frame.h $(INTERVALS_H) window.h buffer.h \
+   keyboard.h systime.h coding.h blockinput.h atimer.h epaths.h character.h \
+   charset.h fontset.h termhooks.h font.h ccl.h lisp.h $(config_h)
+ macmenu.o: macmenu.c frame.h dispextern.h macgui.h termhooks.h keyboard.h \
+   systime.h coding.h composite.h keymap.h window.h blockinput.h atimer.h \
+   buffer.h charset.h macterm.h menu.h lisp.h $(config_h)
+ macterm.o: macterm.c blockinput.h atimer.h systime.h macterm.h macgui.h \
+   frame.h $(INTERVALS_H) systty.h charset.h character.h coding.h fontset.h \
+   termhooks.h termopts.h termchar.h disptab.h buffer.h window.h keyboard.h \
+   keymap.h font.h ccl.h lisp.h $(config_h)
+ macselect.o: macselect.c macterm.h macgui.h frame.h dispextern.h blockinput.h \
+   atimer.h systime.h keymap.h lisp.h $(config_h)
+ macappkit.o: macappkit.m blockinput.h atimer.h systime.h macterm.h macgui.h \
+   frame.h $(INTERVALS_H) charset.h character.h fontset.h termhooks.h buffer.h \
+   window.h keyboard.h coding.h keymap.h macfont.h macappkit.h lisp.h $(config_h)
+ mactoolbox.o: mactoolbox.c blockinput.h atimer.h systime.h macterm.h macgui.h \
+   frame.h dispextern.h charset.h character.h coding.h composite.h fontset.h \
+   termhooks.h buffer.h window.h keyboard.h font.h ccl.h lisp.h $(config_h)
  
  ### deps.mk ends here

=== modified file 'src/dispextern.h'
*** src/dispextern.h	2012-06-01 09:14:07 +0000
--- src/dispextern.h	2012-06-01 10:57:00 +0000
*************** typedef XImage *XImagePtr;
*** 60,65 ****
--- 60,73 ----
  typedef HDC XImagePtr_or_DC;
  #endif
  
+ #ifdef HAVE_MACGUI
+ #include "macgui.h"
+ typedef struct mac_display_info Display_Info;
+ /* Mac equivalent of XImage.  */
+ typedef Pixmap XImagePtr;
+ typedef XImagePtr XImagePtr_or_DC;
+ #endif
+ 
  #ifdef HAVE_NS
  #include "nsgui.h"
  /* Following typedef needed to accommodate the MSDOS port, believe it or not.  */
*************** struct glyph_string
*** 1283,1289 ****
    unsigned padding_p : 1;
  
    /* The GC to use for drawing this glyph string.  */
! #if defined (HAVE_X_WINDOWS)
    GC gc;
  #endif
  #if defined (HAVE_NTGUI)
--- 1291,1297 ----
    unsigned padding_p : 1;
  
    /* The GC to use for drawing this glyph string.  */
! #if defined (HAVE_X_WINDOWS) || defined (HAVE_MACGUI)
    GC gc;
  #endif
  #if defined (HAVE_NTGUI)
*************** struct image
*** 2850,2855 ****
--- 2858,2868 ----
       during GC.  */
    Lisp_Object lisp_data;
  
+ #ifdef HAVE_MACGUI
+   /* A place for image types to store Core Graphics image data.  */
+   CGImageRef cg_image;
+ #endif
+ 
    /* Hash value of image specification to speed up comparisons.  */
    EMACS_UINT hash;
  
*************** void compute_fringe_widths (struct frame
*** 3139,3144 ****
--- 3152,3160 ----
  void w32_init_fringe (struct redisplay_interface *);
  void w32_reset_fringes (void);
  #endif
+ #ifdef HAVE_MACGUI
+ void mac_init_fringe (struct redisplay_interface *);
+ #endif
  
  extern unsigned row_hash (struct glyph_row *);
  
*************** void gamma_correct (struct frame *, XCol
*** 3241,3246 ****
--- 3257,3265 ----
  #ifdef WINDOWSNT
  void gamma_correct (struct frame *, COLORREF *);
  #endif
+ #ifdef HAVE_MACGUI
+ void gamma_correct (struct frame *, unsigned long *);
+ #endif
  
  #ifdef HAVE_WINDOW_SYSTEM
  

=== modified file 'src/dispnew.c'
*** src/dispnew.c	2012-04-20 14:08:55 +0000
--- src/dispnew.c	2012-04-28 00:30:28 +0000
*************** along with GNU Emacs.  If not, see <http
*** 52,57 ****
--- 52,61 ----
  #include "w32term.h"
  #endif /* HAVE_NTGUI */
  
+ #ifdef HAVE_MACGUI
+ #include "macterm.h"
+ #endif /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NS
  #include "nsterm.h"
  #endif
*************** init_display (void)
*** 6324,6329 ****
--- 6328,6343 ----
      }
  #endif /* HAVE_NTGUI */
  
+ #ifdef HAVE_MACGUI
+   if (!inhibit_window_system)
+     {
+       Vinitial_window_system = Qmac;
+       Vwindow_system_version = make_number (10);
+       adjust_frame_glyphs_initially ();
+       return;
+     }
+ #endif /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NS
    if (!inhibit_window_system
  #ifndef CANNOT_DUMP
*************** The value is a symbol:
*** 6554,6559 ****
--- 6568,6574 ----
   nil for a termcap frame (a character-only terminal),
   'x' for an Emacs frame that is really an X window,
   'w32' for an Emacs frame that is a window on MS-Windows display,
+  'mac' for an Emacs frame on a Mac display,
   'ns' for an Emacs frame on a GNUstep or Macintosh Cocoa display,
   'pc' for a direct-write MS-DOS frame.
  
*************** The value is a symbol:
*** 6567,6572 ****
--- 6582,6588 ----
   nil for a termcap frame (a character-only terminal),
   'x' for an Emacs frame that is really an X window,
   'w32' for an Emacs frame that is a window on MS-Windows display,
+  'mac' for an Emacs frame on a Mac display,
   'ns' for an Emacs frame on a GNUstep or Macintosh Cocoa display,
   'pc' for a direct-write MS-DOS frame.
  

=== modified file 'src/emacs.c'
*** src/emacs.c	2012-01-19 07:21:25 +0000
--- src/emacs.c	2012-03-03 00:28:18 +0000
*************** int fatal_error_in_progress;
*** 314,320 ****
  static void (*fatal_error_signal_hook) (void);
  
  #ifdef FORWARD_SIGNAL_TO_MAIN_THREAD
! /* When compiled with GTK and running under Gnome,
     multiple threads may be created.  Keep track of our main
     thread to make sure signals are delivered to it (see syssignal.h).  */
  
--- 314,320 ----
  static void (*fatal_error_signal_hook) (void);
  
  #ifdef FORWARD_SIGNAL_TO_MAIN_THREAD
! /* When compiled with GTK and running under Gnome, or Mac GUI,
     multiple threads may be created.  Keep track of our main
     thread to make sure signals are delivered to it (see syssignal.h).  */
  
*************** main (int argc, char **argv)
*** 718,724 ****
    int no_loadup = 0;
    char *junk = 0;
    char *dname_arg = 0;
! #ifdef NS_IMPL_COCOA
    char dname_arg2[80];
  #endif
    char *ch_to_dir;
--- 718,724 ----
    int no_loadup = 0;
    char *junk = 0;
    char *dname_arg = 0;
! #if defined (NS_IMPL_COCOA) || defined (HAVE_MACGUI)
    char dname_arg2[80];
  #endif
    char *ch_to_dir;
*************** main (int argc, char **argv)
*** 831,836 ****
--- 831,846 ----
      }
  #endif /* HAVE_PERSONALITY_LINUX32 */
  
+ #ifdef HAVE_MACGUI
+   /* Skip process serial number passed in the form -psn_x_y as
+      command-line argument.  The WindowServer adds this option when
+      Emacs is invoked from the Finder or by the `open' command.  In
+      these cases, the working directory becomes `/', so we change it
+      to the user's home directory.  */
+   if (argc > skip_args + 1 && strncmp (argv[skip_args+1], "-psn_", 5) == 0)
+     chdir (getenv ("HOME"));
+ #endif /* HAVE_MACGUI */
+ 
  #if defined (HAVE_SETRLIMIT) && defined (RLIMIT_STACK)
    /* Extend the stack space available.
       Don't do that if dumping, since some systems (e.g. DJGPP)
*************** main (int argc, char **argv)
*** 1022,1035 ****
  	  exit (1);
  	}
  
! #ifndef NS_IMPL_COCOA
  #ifdef USE_GTK
        fprintf (stderr, "\nWarning: due to a long standing Gtk+ bug\nhttp://bugzilla.gnome.org/show_bug.cgi?id=85715\n\
  Emacs might crash when run in daemon mode and the X11 connection is unexpectedly lost.\n\
  Using an Emacs configured with --with-x-toolkit=lucid does not have this problem.\n");
  #endif
        f = fork ();
! #else /* NS_IMPL_COCOA */
        /* Under Cocoa we must do fork+exec as CoreFoundation lib fails in
           forked process: http://developer.apple.com/ReleaseNotes/
                                    CoreFoundation/CoreFoundation.html)
--- 1032,1045 ----
  	  exit (1);
  	}
  
! #if !defined (NS_IMPL_COCOA) && !defined (HAVE_MACGUI)
  #ifdef USE_GTK
        fprintf (stderr, "\nWarning: due to a long standing Gtk+ bug\nhttp://bugzilla.gnome.org/show_bug.cgi?id=85715\n\
  Emacs might crash when run in daemon mode and the X11 connection is unexpectedly lost.\n\
  Using an Emacs configured with --with-x-toolkit=lucid does not have this problem.\n");
  #endif
        f = fork ();
! #else /* NS_IMPL_COCOA || HAVE_MACGUI */
        /* Under Cocoa we must do fork+exec as CoreFoundation lib fails in
           forked process: http://developer.apple.com/ReleaseNotes/
                                    CoreFoundation/CoreFoundation.html)
*************** Using an Emacs configured with --with-x-
*** 1040,1046 ****
  	  f = fork ();  /* in orig */
        else
  	  f = 0;  /* in exec'd */
! #endif /* NS_IMPL_COCOA */
        if (f > 0)
  	{
  	  int retval;
--- 1050,1056 ----
  	  f = fork ();  /* in orig */
        else
  	  f = 0;  /* in exec'd */
! #endif /* NS_IMPL_COCOA || HAVE_MACGUI */
        if (f > 0)
  	{
  	  int retval;
*************** Using an Emacs configured with --with-x-
*** 1076,1082 ****
  	  exit (1);
  	}
  
! #ifdef NS_IMPL_COCOA
        {
          /* In orig process, forked as child, OR in exec'd. */
          if (!dname_arg || !strchr (dname_arg, '\n'))
--- 1086,1092 ----
  	  exit (1);
  	}
  
! #if defined (NS_IMPL_COCOA) || defined (HAVE_MACGUI)
        {
          /* In orig process, forked as child, OR in exec'd. */
          if (!dname_arg || !strchr (dname_arg, '\n'))
*************** Using an Emacs configured with --with-x-
*** 1095,1101 ****
  
              argv[skip_args] = fdStr;
  
!             execv (argv[0], argv);
              fprintf (stderr, "emacs daemon: exec failed: %d\n", errno);
              exit (1);
            }
--- 1105,1111 ----
  
              argv[skip_args] = fdStr;
  
!             execvp (argv[0], argv);
              fprintf (stderr, "emacs daemon: exec failed: %d\n", errno);
              exit (1);
            }
*************** Using an Emacs configured with --with-x-
*** 1112,1118 ****
                  dname_arg2);
          dname_arg = *dname_arg2 ? dname_arg2 : NULL;
        }
! #endif /* NS_IMPL_COCOA */
  
        if (dname_arg)
         	daemon_name = xstrdup (dname_arg);
--- 1122,1128 ----
                  dname_arg2);
          dname_arg = *dname_arg2 ? dname_arg2 : NULL;
        }
! #endif /* NS_IMPL_COCOA || HAVE_MACGUI */
  
        if (dname_arg)
         	daemon_name = xstrdup (dname_arg);
*************** Using an Emacs configured with --with-x-
*** 1430,1435 ****
--- 1440,1450 ----
    init_ntproc ();	/* must precede init_editfns.  */
  #endif
  
+ #ifdef HAVE_MACGUI
+   if (initialized)
+     init_mac_osx_environment ();
+ #endif
+ 
  #ifdef HAVE_NS
  #ifndef CANNOT_DUMP
    if (initialized)
*************** Using an Emacs configured with --with-x-
*** 1560,1565 ****
--- 1575,1589 ----
        syms_of_fontset ();
  #endif /* HAVE_NTGUI */
  
+ #ifdef HAVE_MACGUI
+       syms_of_mac ();
+       syms_of_macterm ();
+       syms_of_macfns ();
+       syms_of_macmenu ();
+       syms_of_macselect ();
+       syms_of_fontset ();
+ #endif /* HAVE_MACGUI */
+ 
  #ifdef MSDOS
        syms_of_xmenu ();
        syms_of_dosfns ();

=== modified file 'src/eval.c'
*** src/eval.c	2012-03-12 06:34:32 +0000
--- src/eval.c	2012-04-02 05:51:12 +0000
*************** eval_sub (Lisp_Object form)
*** 2254,2261 ****
  	error ("Lisp nesting exceeds `max-lisp-eval-depth'");
      }
  
!   original_fun = Fcar (form);
!   original_args = Fcdr (form);
  
    backtrace.next = backtrace_list;
    backtrace_list = &backtrace;
--- 2254,2261 ----
  	error ("Lisp nesting exceeds `max-lisp-eval-depth'");
      }
  
!   original_fun = XCAR (form);
!   original_args = XCDR (form);
  
    backtrace.next = backtrace_list;
    backtrace_list = &backtrace;

=== modified file 'src/fileio.c'
*** src/fileio.c	2012-04-20 17:34:51 +0000
--- src/fileio.c	2012-04-28 00:30:28 +0000
*************** See also `file-exists-p' and `file-attri
*** 2564,2576 ****
  
    absname = ENCODE_FILE (absname);
  
! #if defined (DOS_NT) || defined (macintosh)
!   /* Under MS-DOS, Windows, and Macintosh, open does not work for
!      directories.  */
    if (access (SDATA (absname), 0) == 0)
      return Qt;
    return Qnil;
! #else /* not DOS_NT and not macintosh */
    flags = O_RDONLY;
  #ifdef O_NONBLOCK
    /* Opening a fifo without O_NONBLOCK can wait.
--- 2564,2575 ----
  
    absname = ENCODE_FILE (absname);
  
! #if defined (DOS_NT)
!   /* Under MS-DOS, Windows, open does not work for directories.  */
    if (access (SDATA (absname), 0) == 0)
      return Qt;
    return Qnil;
! #else /* not DOS_NT */
    flags = O_RDONLY;
  #ifdef O_NONBLOCK
    /* Opening a fifo without O_NONBLOCK can wait.
*************** See also `file-exists-p' and `file-attri
*** 2587,2593 ****
      return Qnil;
    emacs_close (desc);
    return Qt;
! #endif /* not DOS_NT and not macintosh */
  }
  
  /* Having this before file-symlink-p mysteriously caused it to be forgotten
--- 2586,2592 ----
      return Qnil;
    emacs_close (desc);
    return Qt;
! #endif /* not DOS_NT */
  }
  
  /* Having this before file-symlink-p mysteriously caused it to be forgotten
*************** The return value is only relevant for a 
*** 5536,5542 ****
  before any other event (mouse or keypress) is handled.  */)
    (void)
  {
! #if defined (USE_MOTIF) || defined (HAVE_NTGUI) || defined (USE_GTK)
    if ((NILP (last_nonmenu_event) || CONSP (last_nonmenu_event))
        && use_dialog_box
        && use_file_dialog
--- 5535,5541 ----
  before any other event (mouse or keypress) is handled.  */)
    (void)
  {
! #if defined (USE_MOTIF) || defined (HAVE_NTGUI) || defined (USE_GTK) || defined (HAVE_MACGUI)
    if ((NILP (last_nonmenu_event) || CONSP (last_nonmenu_event))
        && use_dialog_box
        && use_file_dialog

=== modified file 'src/fns.c'
*** src/fns.c	2012-02-10 08:38:22 +0000
--- src/fns.c	2012-02-27 23:16:05 +0000
*************** internal_equal (register Lisp_Object o1,
*** 2074,2079 ****
--- 2074,2089 ----
  		  && (XMARKER (o1)->buffer == 0
  		      || XMARKER (o1)->bytepos == XMARKER (o2)->bytepos));
  	}
+ #ifdef HAVE_MACGUI
+       /* Font-objects, which are subject to equality testing, may
+ 	 contain save-values in the mac font backends.  */
+       if (SAVE_VALUEP (o1))
+ 	{
+ 	  return (XSAVE_VALUE (o1)->dogc == XSAVE_VALUE (o2)->dogc
+ 		  && XSAVE_VALUE (o1)->pointer == XSAVE_VALUE (o2)->pointer
+ 		  && XSAVE_VALUE (o1)->integer == XSAVE_VALUE (o2)->integer);
+ 	}
+ #endif
        break;
  
      case Lisp_Vectorlike:

=== modified file 'src/font.c'
*** src/font.c	2012-01-19 07:21:25 +0000
--- src/font.c	2012-04-02 05:56:16 +0000
*************** along with GNU Emacs.  If not, see <http
*** 45,50 ****
--- 45,54 ----
  #include "w32term.h"
  #endif /* HAVE_NTGUI */
  
+ #ifdef HAVE_MACGUI
+ #include "macterm.h"
+ #endif /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NS
  #include "nsterm.h"
  #endif /* HAVE_NS */
*************** static struct font_driver_list *font_dri
*** 164,170 ****
  
  /* Creators of font-related Lisp object.  */
  
! static Lisp_Object
  font_make_spec (void)
  {
    Lisp_Object font_spec;
--- 168,177 ----
  
  /* Creators of font-related Lisp object.  */
  
! #ifndef HAVE_MACGUI
! static
! #endif
! Lisp_Object
  font_make_spec (void)
  {
    Lisp_Object font_spec;
*************** font_parse_fcname (char *name, Lisp_Obje
*** 1446,1453 ****
          {
            struct font_driver_list *driver_list = font_driver_list;
            for ( ; driver_list; driver_list = driver_list->next)
!             if (driver_list->driver->filter_properties)
!               (*driver_list->driver->filter_properties) (font, extra_props);
          }
  
      }
--- 1453,1468 ----
          {
            struct font_driver_list *driver_list = font_driver_list;
            for ( ; driver_list; driver_list = driver_list->next)
! 	    {
! #ifdef HAVE_MACGUI
! 	      extern Lisp_Object macfont_driver_type;
! 
! 	      if (!EQ (macfont_driver_type, driver_list->driver->type))
! 		continue;
! #endif
! 	      if (driver_list->driver->filter_properties)
! 		(*driver_list->driver->filter_properties) (font, extra_props);
! 	    }
          }
  
      }
*************** created glyph-string.  Otherwise, the va
*** 4317,4322 ****
--- 4332,4338 ----
    if (XINT (n) < LGSTRING_GLYPH_LEN (gstring))
      LGSTRING_SET_GLYPH (gstring, XINT (n), Qnil);
  
+ #ifndef HAVE_MACGUI
    glyph = LGSTRING_GLYPH (gstring, 0);
    from = LGLYPH_FROM (glyph);
    to = LGLYPH_TO (glyph);
*************** created glyph-string.  Otherwise, the va
*** 4354,4359 ****
--- 4370,4376 ----
  	LGLYPH_SET_FROM (glyph, from);
  	LGLYPH_SET_TO (glyph, to);
        }
+ #endif
    return composition_gstring_put_cache (gstring, XINT (n));
  }
  
*************** EMACS_FONT_LOG is set.  Otherwise, it is
*** 5202,5207 ****
--- 5219,5227 ----
  #ifdef WINDOWSNT
    syms_of_w32font ();
  #endif	/* WINDOWSNT */
+ #ifdef HAVE_MACGUI
+   syms_of_macfont ();
+ #endif	/* HAVE_MACGUI */
  #ifdef HAVE_NS
    syms_of_nsfont ();
  #endif	/* HAVE_NS */

=== modified file 'src/font.h'
*** src/font.h	2012-01-19 07:21:25 +0000
--- src/font.h	2012-02-28 00:30:35 +0000
*************** struct font_bitmap
*** 469,479 ****
    } while (0)
  
  #define XFONT_SPEC(p)	\
!   (eassert (FONT_SPEC_P(p)), (struct font_spec *) XPNTR (p))
  #define XFONT_ENTITY(p)	\
!   (eassert (FONT_ENTITY_P(p)), (struct font_entity *) XPNTR (p))
  #define XFONT_OBJECT(p)	\
!   (eassert (FONT_OBJECT_P(p)), (struct font *) XPNTR (p))
  #define XSETFONT(a, b) (XSETPSEUDOVECTOR (a, b, PVEC_FONT))
  
  /* Number of pt per inch (from the TeXbook).  */
--- 469,480 ----
    } while (0)
  
  #define XFONT_SPEC(p)	\
!   (eassert (FONT_SPEC_P(p)), (struct font_spec *) XUNTAG (p, Lisp_Vectorlike))
  #define XFONT_ENTITY(p)	\
!   (eassert (FONT_ENTITY_P(p)), \
!    (struct font_entity *) XUNTAG (p, Lisp_Vectorlike))
  #define XFONT_OBJECT(p)	\
!   (eassert (FONT_OBJECT_P(p)), (struct font *) XUNTAG (p, Lisp_Vectorlike))
  #define XSETFONT(a, b) (XSETPSEUDOVECTOR (a, b, PVEC_FONT))
  
  /* Number of pt per inch (from the TeXbook).  */
*************** EXFUN (Ffont_xlfd_name, 2);
*** 743,748 ****
--- 744,752 ----
  
  extern Lisp_Object font_make_entity (void);
  extern Lisp_Object font_make_object (int, Lisp_Object, int);
+ #ifdef HAVE_MACGUI
+ extern Lisp_Object font_make_spec (void);
+ #endif
  
  extern Lisp_Object find_font_encoding (Lisp_Object);
  extern int font_registry_charsets (Lisp_Object, struct charset **,
*************** extern struct font_driver w32font_driver
*** 835,840 ****
--- 839,849 ----
  extern struct font_driver uniscribe_font_driver;
  extern void syms_of_w32font (void);
  #endif	/* WINDOWSNT */
+ #ifdef HAVE_MACGUI
+ extern void mac_register_font_driver (struct frame *);
+ extern struct font_driver macfont_driver;
+ extern void syms_of_macfont (void);
+ #endif	/* HAVE_MACGUI */
  #ifdef HAVE_NS
  extern Lisp_Object Qfontsize;
  extern struct font_driver nsfont_driver;

=== modified file 'src/fontset.c'
*** src/fontset.c	2012-01-19 07:21:25 +0000
--- src/fontset.c	2012-02-27 23:16:05 +0000
*************** along with GNU Emacs.  If not, see <http
*** 48,53 ****
--- 48,56 ----
  #ifdef WINDOWSNT
  #include "w32term.h"
  #endif
+ #ifdef HAVE_MACGUI
+ #include "macterm.h"
+ #endif
  #ifdef HAVE_NS
  #include "nsterm.h"
  #endif

=== modified file 'src/frame.c'
*** src/frame.c	2012-03-10 07:46:07 +0000
--- src/frame.c	2012-04-02 05:51:12 +0000
*************** along with GNU Emacs.  If not, see <http
*** 32,37 ****
--- 32,40 ----
  #ifdef WINDOWSNT
  #include "w32term.h"
  #endif
+ #ifdef HAVE_MACGUI
+ #include "macterm.h"
+ #endif
  #ifdef HAVE_NS
  #include "nsterm.h"
  #endif
*************** Value is:
*** 184,189 ****
--- 187,193 ----
    t for a termcap frame (a character-only terminal),
   'x' for an Emacs frame that is really an X window,
   'w32' for an Emacs frame that is a window on MS-Windows display,
+  'mac' for an Emacs frame on a Mac display,
   'ns' for an Emacs frame on a GNUstep or Macintosh Cocoa display,
   'pc' for a direct-write MS-DOS frame.
  See also `frame-live-p'.  */)
*************** The value is a symbol:
*** 231,236 ****
--- 235,241 ----
   nil for a termcap frame (a character-only terminal),
   'x' for an Emacs frame that is really an X window,
   'w32' for an Emacs frame that is a window on MS-Windows display,
+  'mac' for an Emacs frame on a Mac display,
   'ns' for an Emacs frame on a GNUstep or Macintosh Cocoa display,
   'pc' for a direct-write MS-DOS frame.
  
*************** affects all frames on the same terminal 
*** 655,662 ****
      abort ();
  #else /* not MSDOS */
  
! #ifdef WINDOWSNT                           /* This should work now! */
!   if (sf->output_method != output_termcap)
      error ("Not using an ASCII terminal now; cannot make a new ASCII frame");
  #endif
  #endif /* not MSDOS */
--- 660,671 ----
      abort ();
  #else /* not MSDOS */
  
! #if defined (WINDOWSNT) || defined (HAVE_MACGUI) /* This should work now! */
!   if (sf->output_method != output_termcap
! #ifdef HAVE_MACGUI
!       && sf->output_method != output_initial
! #endif
!       )
      error ("Not using an ASCII terminal now; cannot make a new ASCII frame");
  #endif
  #endif /* not MSDOS */
*************** delete_frame (Lisp_Object frame, Lisp_Ob
*** 1297,1302 ****
--- 1306,1315 ----
    if (FRAME_X_P (f))
      x_clear_frame_selections (f);
  #endif
+ #ifdef HAVE_MACGUI
+   if (FRAME_MAC_P (f))
+     x_clear_frame_selections (f);
+ #endif
  
    /* Free glyphs.
       This function must be called before the window tree of the
*************** See `redirect-frame-focus'.  */)
*** 1975,1981 ****
  
  /* Return the value of frame parameter PROP in frame FRAME.  */
  
! #if !HAVE_NS
  static
  #endif
  Lisp_Object
--- 1988,1994 ----
  
  /* Return the value of frame parameter PROP in frame FRAME.  */
  
! #if !defined (HAVE_MACGUI) && !HAVE_NS
  static
  #endif
  Lisp_Object
*************** x_set_fullscreen (struct frame *f, Lisp_
*** 3131,3137 ****
--- 3144,3156 ----
  {
    if (NILP (new_value))
      f->want_fullscreen = FULLSCREEN_NONE;
+ #ifdef HAVE_MACGUI
+   else if (EQ (new_value, Qfullscreen))
+     f->want_fullscreen = FULLSCREEN_DEDICATED_DESKTOP;
+   else if (EQ (new_value, Qfullboth))
+ #else
    else if (EQ (new_value, Qfullboth) || EQ (new_value, Qfullscreen))
+ #endif
      f->want_fullscreen = FULLSCREEN_BOTH;
    else if (EQ (new_value, Qfullwidth))
      f->want_fullscreen = FULLSCREEN_WIDTH;
*************** x_set_alpha (struct frame *f, Lisp_Objec
*** 3554,3560 ****
    for (i = 0; i < 2; i++)
      f->alpha[i] = newval[i];
  
! #if defined (HAVE_X_WINDOWS) || defined (HAVE_NTGUI) || defined (NS_IMPL_COCOA)
    BLOCK_INPUT;
    x_set_frame_alpha (f);
    UNBLOCK_INPUT;
--- 3573,3579 ----
    for (i = 0; i < 2; i++)
      f->alpha[i] = newval[i];
  
! #if defined (HAVE_X_WINDOWS) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI) || defined (NS_IMPL_COCOA)
    BLOCK_INPUT;
    x_set_frame_alpha (f);
    UNBLOCK_INPUT;
*************** Setting this variable does not affect ex
*** 4361,4367 ****
    DEFVAR_LISP ("default-frame-scroll-bars", Vdefault_frame_scroll_bars,
  	       doc: /* Default position of scroll bars on this window-system.  */);
  #ifdef HAVE_WINDOW_SYSTEM
! #if defined (HAVE_NTGUI) || defined (NS_IMPL_COCOA) || (defined (USE_GTK) && defined (USE_TOOLKIT_SCROLL_BARS))
    /* MS-Windows, Mac OS X, and GTK have scroll bars on the right by
       default.  */
    Vdefault_frame_scroll_bars = Qright;
--- 4380,4386 ----
    DEFVAR_LISP ("default-frame-scroll-bars", Vdefault_frame_scroll_bars,
  	       doc: /* Default position of scroll bars on this window-system.  */);
  #ifdef HAVE_WINDOW_SYSTEM
! #if defined (HAVE_NTGUI) || defined (HAVE_MACGUI) || defined (NS_IMPL_COCOA) || (defined (USE_GTK) && defined (USE_TOOLKIT_SCROLL_BARS))
    /* MS-Windows, Mac OS X, and GTK have scroll bars on the right by
       default.  */
    Vdefault_frame_scroll_bars = Qright;

=== modified file 'src/frame.h'
*** src/frame.h	2012-01-19 07:21:25 +0000
--- src/frame.h	2012-02-28 00:33:37 +0000
*************** enum fullscreen_type
*** 69,74 ****
--- 69,77 ----
    FULLSCREEN_HEIGHT    = 0x002,
    FULLSCREEN_BOTH      = 0x003,
    FULLSCREEN_MAXIMIZED = 0x013,
+ #ifdef HAVE_MACGUI
+   FULLSCREEN_DEDICATED_DESKTOP = 0x023,
+ #endif
    FULLSCREEN_WAIT      = 0x100
  };
  
*************** struct frame
*** 232,238 ****
       auto-resize-tool-bar is set to grow-only.  */
    unsigned minimize_tool_bar_window_p : 1;
  
! #if defined (USE_GTK) || defined (HAVE_NS)
    /* Nonzero means using a tool bar that comes from the toolkit.  */
    int external_tool_bar;
  #endif
--- 235,241 ----
       auto-resize-tool-bar is set to grow-only.  */
    unsigned minimize_tool_bar_window_p : 1;
  
! #if defined (USE_GTK) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    /* Nonzero means using a tool bar that comes from the toolkit.  */
    int external_tool_bar;
  #endif
*************** struct frame
*** 321,326 ****
--- 324,330 ----
      struct tty_output *tty;     /* termchar.h */
      struct x_output *x;         /* xterm.h */
      struct w32_output *w32;     /* w32term.h */
+     struct mac_output *mac;     /* macterm.h */
      struct ns_output *ns;       /* nsterm.h */
      EMACS_INT nothing;
    }
*************** struct frame
*** 348,354 ****
    /* Number of lines of menu bar.  */
    int menu_bar_lines;
  
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) \
      || defined (HAVE_NS) || defined (USE_GTK)
    /* Nonzero means using a menu bar that comes from the X toolkit.  */
    unsigned int external_menu_bar : 1;
--- 352,358 ----
    /* Number of lines of menu bar.  */
    int menu_bar_lines;
  
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI) \
      || defined (HAVE_NS) || defined (USE_GTK)
    /* Nonzero means using a menu bar that comes from the X toolkit.  */
    unsigned int external_menu_bar : 1;
*************** struct frame
*** 501,507 ****
  
  typedef struct frame *FRAME_PTR;
  
! #define XFRAME(p) (eassert (FRAMEP(p)),(struct frame *) XPNTR (p))
  #define XSETFRAME(a, b) (XSETPSEUDOVECTOR (a, b, PVEC_FRAME))
  
  /* Given a window, return its frame as a Lisp_Object.  */
--- 505,512 ----
  
  typedef struct frame *FRAME_PTR;
  
! #define XFRAME(p) (eassert (FRAMEP(p)), \
! 		   (struct frame *) XUNTAG (p, Lisp_Vectorlike))
  #define XSETFRAME(a, b) (XSETPSEUDOVECTOR (a, b, PVEC_FRAME))
  
  /* Given a window, return its frame as a Lisp_Object.  */
*************** typedef struct frame *FRAME_PTR;
*** 525,530 ****
--- 530,538 ----
  #ifdef HAVE_NTGUI
  #define FRAME_WINDOW_P(f) FRAME_W32_P (f)
  #endif
+ #ifdef HAVE_MACGUI
+ #define FRAME_WINDOW_P(f) FRAME_MAC_P (f)
+ #endif
  #ifdef HAVE_NS
  #define FRAME_WINDOW_P(f) FRAME_NS_P(f)
  #endif
*************** typedef struct frame *FRAME_PTR;
*** 580,586 ****
  
  /* Nonzero if this frame should display a tool bar
     in a way that does not use any text lines.  */
! #if defined (USE_GTK) || defined (HAVE_NS)
  #define FRAME_EXTERNAL_TOOL_BAR(f) (f)->external_tool_bar
  #else
  #define FRAME_EXTERNAL_TOOL_BAR(f) 0
--- 588,594 ----
  
  /* Nonzero if this frame should display a tool bar
     in a way that does not use any text lines.  */
! #if defined (USE_GTK) || defined (HAVE_MACGUI) || defined (HAVE_NS)
  #define FRAME_EXTERNAL_TOOL_BAR(f) (f)->external_tool_bar
  #else
  #define FRAME_EXTERNAL_TOOL_BAR(f) 0
*************** typedef struct frame *FRAME_PTR;
*** 603,609 ****
  
  /* Nonzero if this frame should display a menu bar
     in a way that does not use any text lines.  */
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) \
       || defined (HAVE_NS) || defined (USE_GTK)
  #define FRAME_EXTERNAL_MENU_BAR(f) (f)->external_menu_bar
  #else
--- 611,617 ----
  
  /* Nonzero if this frame should display a menu bar
     in a way that does not use any text lines.  */
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI) \
       || defined (HAVE_NS) || defined (USE_GTK)
  #define FRAME_EXTERNAL_MENU_BAR(f) (f)->external_menu_bar
  #else

=== modified file 'src/fringe.c'
*** src/fringe.c	2012-01-19 07:21:25 +0000
--- src/fringe.c	2012-02-28 00:34:28 +0000
*************** init_fringe_bitmap (int which, struct fr
*** 1502,1507 ****
--- 1502,1520 ----
  	}
  #endif /* HAVE_X_WINDOWS */
  
+ #ifdef HAVE_MACGUI
+       unsigned short *bits = fb->bits;
+       int j;
+       for (j = 0; j < fb->height; j++)
+ 	{
+ 	  unsigned short b = *bits;
+ 	  b <<= (16 - fb->width);
+ #ifndef WORDS_BIG_ENDIAN
+ 	  b = ((b >> 8) | (b << 8));
+ #endif
+ 	  *bits++ = b;
+ 	}
+ #endif
      }
  
    if (!once_p)
*************** init_fringe (void)
*** 1809,1818 ****
      }
  }
  
! #ifdef HAVE_NTGUI
  
  void
  w32_init_fringe (struct redisplay_interface *rif)
  {
    int bt;
  
--- 1822,1835 ----
      }
  }
  
! #if defined (HAVE_NTGUI) || defined (HAVE_MACGUI)
  
  void
+ #ifdef HAVE_NTGUI
  w32_init_fringe (struct redisplay_interface *rif)
+ #else  /* HAVE_MACGUI */
+ mac_init_fringe (struct redisplay_interface *rif)
+ #endif
  {
    int bt;
  
*************** w32_init_fringe (struct redisplay_interf
*** 1825,1831 ****
--- 1842,1850 ----
        rif->define_fringe_bitmap (bt, fb->bits, fb->height, fb->width);
      }
  }
+ #endif
  
+ #ifdef HAVE_NTGUI
  void
  w32_reset_fringes (void)
  {

=== modified file 'src/image.c'
*** src/image.c	2012-02-15 06:40:08 +0000
--- src/image.c	2012-05-17 03:16:24 +0000
*************** extern void x_query_color (struct frame 
*** 97,102 ****
--- 97,141 ----
  Lisp_Object Qlibpng_version;
  #endif /* HAVE_NTGUI */
  
+ 
+ #ifdef HAVE_MACGUI
+ #include "macterm.h"
+ #include <sys/stat.h>
+ #ifndef USE_MAC_IMAGE_IO
+ #include <QuickTime/QuickTime.h>
+ #endif
+ 
+ /* MAC_TODO : Color tables on Mac.  */
+ #undef COLOR_TABLE_SUPPORT
+ 
+ #define ZPixmap 0 		/* arbitrary */
+ typedef struct mac_bitmap_record Bitmap_Record;
+ 
+ #define GET_PIXEL(ximg, x, y) XGetPixel(ximg, x, y)
+ #define NO_PIXMAP 0
+ 
+ #define RGB_PIXEL_COLOR unsigned long
+ 
+ #ifdef USE_MAC_IMAGE_IO
+ #define PIX_MASK_DRAW	255
+ #define PIX_MASK_RETAIN	0
+ #else
+ /* A black pixel in a mask bitmap/pixmap means ``draw a source
+    pixel''.  A white pixel means ``retain the current pixel''. */
+ #define PIX_MASK_DRAW	RGB_TO_ULONG(0,0,0)
+ #define PIX_MASK_RETAIN	RGB_TO_ULONG(255,255,255)
+ #endif
+ 
+ #define FRAME_X_VISUAL(f) FRAME_X_DISPLAY_INFO (f)->visual
+ #define x_defined_color mac_defined_color
+ #define DefaultDepthOfScreen(screen) (one_mac_display_info.n_planes)
+ /* Functions from macterm.c that depend on XColor (so can't go in
+    macterm.h without modifying lots of files).  */
+ extern void x_query_colors (struct frame *f, XColor *, int);
+ extern void x_query_color (struct frame *f, XColor *);
+ #endif /* HAVE_MACGUI */
+ 
+ 
  #ifdef HAVE_NS
  #include "nsterm.h"
  #include <sys/types.h>
*************** static Lisp_Object Finit_image_library (
*** 150,155 ****
--- 189,418 ----
     the bitmaps yourself.  That is, creating a bitmap from the same
     data more than once will not be caught.  */
  
+ #ifdef HAVE_MACGUI
+ 
+ static XImagePtr
+ XGetImage (Display *display, Pixmap pixmap, int x, int y, unsigned int width,
+ 	   unsigned int height, unsigned long plane_mask, int format)
+ {
+ #ifndef USE_MAC_IMAGE_IO
+ #if GLYPH_DEBUG
+   xassert (x == 0 && y == 0);
+   {
+     Rect ri, rp;
+     SetRect (&ri, 0, 0, width, height);
+     xassert (EqualRect (&ri, GetPixBounds (GetGWorldPixMap (pixmap), &rp)));
+   }
+   xassert (! (pixelsLocked & GetPixelsState (GetGWorldPixMap (pixmap))));
+ #endif
+ 
+   LockPixels (GetGWorldPixMap (pixmap));
+ #endif
+ 
+   return pixmap;
+ }
+ 
+ static void
+ XPutPixel (XImagePtr ximage, int x, int y, unsigned long pixel)
+ {
+ #ifdef USE_MAC_IMAGE_IO
+   if (ximage->bits_per_pixel == 32)
+     ((unsigned int *)(ximage->data + y * ximage->bytes_per_line))[x] = pixel;
+   else
+     ((unsigned char *)(ximage->data + y * ximage->bytes_per_line))[x] = pixel;
+ #else
+   PixMapHandle pixmap = GetGWorldPixMap (ximage);
+   short depth = GetPixDepth (pixmap);
+ 
+ #if defined (WORDS_BIG_ENDIAN)
+   if (depth == 32)
+     {
+       char *base_addr = GetPixBaseAddr (pixmap);
+       short row_bytes = GetPixRowBytes (pixmap);
+ 
+       ((unsigned long *) (base_addr + y * row_bytes))[x] = 0xff000000 | pixel;
+     }
+   else
+ #endif
+   if (depth == 1)
+     {
+       char *base_addr = GetPixBaseAddr (pixmap);
+       short row_bytes = GetPixRowBytes (pixmap);
+ 
+       if (pixel == PIX_MASK_DRAW)
+ 	base_addr[y * row_bytes + x / 8] |= (1 << 7) >> (x & 7);
+       else
+ 	base_addr[y * row_bytes + x / 8] &= ~((1 << 7) >> (x & 7));
+     }
+   else
+     {
+       CGrafPtr old_port;
+       GDHandle old_gdh;
+       RGBColor color;
+ 
+       GetGWorld (&old_port, &old_gdh);
+       SetGWorld (ximage, NULL);
+ 
+       color.red = RED16_FROM_ULONG (pixel);
+       color.green = GREEN16_FROM_ULONG (pixel);
+       color.blue = BLUE16_FROM_ULONG (pixel);
+ 
+       SetCPixel (x, y, &color);
+ 
+       SetGWorld (old_port, old_gdh);
+     }
+ #endif
+ }
+ 
+ static unsigned long
+ XGetPixel (XImagePtr ximage, int x, int y)
+ {
+ #ifdef USE_MAC_IMAGE_IO
+   if (ximage->bits_per_pixel == 32)
+     return ((unsigned int *)(ximage->data + y * ximage->bytes_per_line))[x];
+   else
+     return ((unsigned char *)(ximage->data + y * ximage->bytes_per_line))[x];
+ #else
+   PixMapHandle pixmap = GetGWorldPixMap (ximage);
+   short depth = GetPixDepth (pixmap);
+ 
+ #if defined (WORDS_BIG_ENDIAN)
+   if (depth == 32)
+     {
+       char *base_addr = GetPixBaseAddr (pixmap);
+       short row_bytes = GetPixRowBytes (pixmap);
+ 
+       return ((unsigned long *) (base_addr + y * row_bytes))[x] & 0x00ffffff;
+     }
+   else
+ #endif
+   if (depth == 1)
+     {
+       char *base_addr = GetPixBaseAddr (pixmap);
+       short row_bytes = GetPixRowBytes (pixmap);
+ 
+       if (base_addr[y * row_bytes + x / 8] & (1 << (~x & 7)))
+ 	return PIX_MASK_DRAW;
+       else
+ 	return PIX_MASK_RETAIN;
+     }
+   else
+     {
+       CGrafPtr old_port;
+       GDHandle old_gdh;
+       RGBColor color;
+ 
+       GetGWorld (&old_port, &old_gdh);
+       SetGWorld (ximage, NULL);
+ 
+       GetCPixel (x, y, &color);
+ 
+       SetGWorld (old_port, old_gdh);
+       return RGB_TO_ULONG (color.red >> 8, color.green >> 8, color.blue >> 8);
+     }
+ #endif
+ }
+ 
+ static void
+ XDestroyImage (XImagePtr ximg)
+ {
+ #ifndef USE_MAC_IMAGE_IO
+   UnlockPixels (GetGWorldPixMap (ximg));
+ #endif
+ }
+ 
+ #ifdef USE_MAC_IMAGE_IO
+ void
+ mac_data_provider_release_data (void *info, const void *data, size_t size)
+ {
+   xfree ((void *)data);
+ }
+ #endif
+ 
+ static CGImageRef
+ mac_create_cg_image_from_image (struct frame *f, struct image *img)
+ {
+ #ifdef USE_MAC_IMAGE_IO
+   XImagePtr ximg = img->pixmap;
+   CGDataProviderRef provider;
+   CGImageRef result;
+ 
+   if (img->mask)
+     {
+       int x, y;
+       unsigned long color, alpha;
+ 
+       for (y = 0; y < ximg->height; y++)
+ 	for (x = 0; x < ximg->width; x++)
+ 	  {
+ 	    color = XGetPixel (ximg, x, y);
+ 	    alpha = XGetPixel (img->mask, x, y);
+ 	    XPutPixel (ximg, x, y,
+ 		       ARGB_TO_ULONG (alpha,
+ 				      RED_FROM_ULONG (color)
+ 				      * alpha / PIX_MASK_DRAW,
+ 				      GREEN_FROM_ULONG (color)
+ 				      * alpha / PIX_MASK_DRAW,
+ 				      BLUE_FROM_ULONG (color)
+ 				      * alpha / PIX_MASK_DRAW));
+ 	  }
+       xfree (img->mask->data);
+       img->mask->data = NULL;
+     }
+   BLOCK_INPUT;
+   provider = CGDataProviderCreateWithData (NULL, ximg->data,
+ 					   ximg->bytes_per_line * ximg->height,
+ 					   mac_data_provider_release_data);
+   ximg->data = NULL;
+   result = CGImageCreate (ximg->width, ximg->height, 8, 32,
+ 			  ximg->bytes_per_line, mac_cg_color_space_rgb,
+ 			  ((img->mask ? kCGImageAlphaPremultipliedFirst
+ 			    : kCGImageAlphaNoneSkipFirst)
+ 			   | kCGBitmapByteOrder32Host),
+ 			  provider, NULL, 0, kCGRenderingIntentDefault);
+   CGDataProviderRelease (provider);
+   UNBLOCK_INPUT;
+ 
+   return result;
+ #else
+   Pixmap mask;
+   CGImageRef result = NULL;
+ 
+   BLOCK_INPUT;
+   if (img->mask)
+     mask = img->mask;
+   else
+     {
+       mask = XCreatePixmap (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f),
+ 			    img->width, img->height, 1);
+       if (mask)
+ 	{
+ 	  CGrafPtr old_port;
+ 	  GDHandle old_gdh;
+ 	  Rect r;
+ 
+ 	  GetGWorld (&old_port, &old_gdh);
+ 	  SetGWorld (mask, NULL);
+ 	  BackColor (blackColor); /* Don't mask.  */
+ 	  SetRect (&r, 0, 0, img->width, img->height);
+ 	  EraseRect (&r);
+ 	  SetGWorld (old_port, old_gdh);
+ 	}
+     }
+   if (mask)
+     {
+       CreateCGImageFromPixMaps (GetGWorldPixMap (img->pixmap),
+ 				GetGWorldPixMap (mask), &result);
+       if (mask != img->mask)
+ 	XFreePixmap (FRAME_X_DISPLAY (f), mask);
+     }
+   UNBLOCK_INPUT;
+ 
+   return result;
+ #endif
+ }
+ #endif /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NS
  XImagePtr
  XGetImage (Display *display, Pixmap pixmap, int x, int y,
*************** x_create_bitmap_from_data (struct frame 
*** 264,269 ****
--- 527,538 ----
      return -1;
  #endif /* HAVE_NTGUI */
  
+ #ifdef HAVE_MACGUI
+   /* MAC_TODO: for now fail if width is not mod 16 (toolbox requires it) */
+   if (width % 16 != 0)
+     return -1;
+ #endif
+ 
  #ifdef HAVE_NS
    void *bitmap = ns_image_from_XBM (bits, width, height);
    if (!bitmap)
*************** x_create_bitmap_from_data (struct frame 
*** 271,276 ****
--- 540,549 ----
  #endif
  
    id = x_allocate_bitmap_record (f);
+ #ifdef HAVE_MACGUI
+   dpyinfo->bitmaps[id - 1].bitmap_data = (char *) xmalloc (height * width);
+   memcpy (dpyinfo->bitmaps[id - 1].bitmap_data, bits, height * width);
+ #endif  /* HAVE_MACGUI */
  
  #ifdef HAVE_NS
    dpyinfo->bitmaps[id - 1].img = bitmap;
*************** x_create_bitmap_from_file (struct frame 
*** 304,309 ****
--- 577,586 ----
  {
    Display_Info *dpyinfo = FRAME_X_DISPLAY_INFO (f);
  
+ #ifdef HAVE_MACGUI
+   return -1;  /* MAC_TODO : bitmap support */
+ #endif  /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NTGUI
    return -1;  /* W32_TODO : bitmap support */
  #endif /* HAVE_NTGUI */
*************** free_bitmap_record (Display_Info *dpyinf
*** 390,395 ****
--- 667,677 ----
    DeleteObject (bm->pixmap);
  #endif /* HAVE_NTGUI */
  
+ #ifdef HAVE_MACGUI
+   xfree (bm->bitmap_data);  /* Added ++kfs */
+   bm->bitmap_data = NULL;
+ #endif  /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NS
    ns_release_object (bm->img);
  #endif
*************** prepare_image_for_display (struct frame 
*** 1073,1078 ****
--- 1355,1371 ----
    if (img->pixmap == NO_PIXMAP && !img->load_failed_p)
      img->load_failed_p = img->type->load (f, img) == 0;
  
+ #if defined (HAVE_MACGUI)
+   if (!img->load_failed_p && img->cg_image == NULL)
+     {
+       img->cg_image = mac_create_cg_image_from_image (f, img);
+       if (img->cg_image == NULL)
+ 	{
+ 	  img->load_failed_p = 1;
+ 	  img->type->free (f, img);
+ 	}
+     }
+ #endif
  }
  
  
*************** x_clear_image_1 (struct frame *f, struct
*** 1318,1323 ****
--- 1611,1617 ----
  
    if (colors_p && img->ncolors)
      {
+       /* MAC_TODO: color table support.  */
        /* W32_TODO: color table support.  */
  #ifdef HAVE_X_WINDOWS
        x_free_colors (f, img->colors, img->ncolors);
*************** x_clear_image_1 (struct frame *f, struct
*** 1327,1332 ****
--- 1621,1633 ----
        img->ncolors = 0;
      }
  
+ #if defined (HAVE_MACGUI)
+   if (img->cg_image)
+     {
+       CGImageRelease (img->cg_image);
+       img->cg_image = NULL;
+     }
+ #endif
  }
  
  /* Free X resources of image IMG which is used on frame F.  */
*************** mark_image_cache (struct image_cache *c)
*** 1872,1878 ****
  
  
  /***********************************************************************
! 			  X / NS / W32 support code
   ***********************************************************************/
  
  #ifdef HAVE_NTGUI
--- 2173,2179 ----
  
  
  /***********************************************************************
! 		   X / MAC / NS / W32 support code
   ***********************************************************************/
  
  #ifdef HAVE_NTGUI
*************** x_create_x_image_and_pixmap (struct fram
*** 2069,2074 ****
--- 2370,2398 ----
  
  #endif /* HAVE_NTGUI */
  
+ #ifdef HAVE_MACGUI
+   Display *display = FRAME_X_DISPLAY (f);
+   Window window = FRAME_X_WINDOW (f);
+ 
+   xassert (interrupt_input_blocked);
+ 
+   /* Allocate a pixmap of the same size.  */
+   *pixmap = XCreatePixmap (display, window, width, height, depth);
+   if (*pixmap == NO_PIXMAP)
+     {
+       *ximg = NULL;
+       image_error ("Unable to create X pixmap", Qnil, Qnil);
+       return 0;
+     }
+ 
+ #ifndef USE_MAC_IMAGE_IO
+   LockPixels (GetGWorldPixMap (*pixmap));
+ #endif
+   *ximg = *pixmap;
+   return 1;
+ 
+ #endif  /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NS
    *pixmap = ns_image_for_XPM (width, height, depth);
    if (*pixmap == 0)
*************** x_destroy_x_image (XImagePtr ximg)
*** 2101,2106 ****
--- 2425,2433 ----
        ximg->data = NULL;
        xfree (ximg);
  #endif /* HAVE_NTGUI */
+ #ifdef HAVE_MACGUI
+       XDestroyImage (ximg);
+ #endif /* HAVE_MACGUI */
  #ifdef HAVE_NS
        ns_release_object (ximg);
  #endif /* HAVE_NS */
*************** x_put_x_image (struct frame *f, XImagePt
*** 2131,2136 ****
--- 2458,2467 ----
  #endif
  #endif /* HAVE_NTGUI */
  
+ #ifdef HAVE_MACGUI
+   xassert (ximg == pixmap);
+ #endif  /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NS
    xassert (ximg == pixmap);
    ns_retain_object (ximg);
*************** slurp_file (char *file, ptrdiff_t *size)
*** 2209,2214 ****
--- 2540,3267 ----
  
  
  
+ #ifdef HAVE_MACGUI
+ 
+ /***********************************************************************
+ 			MAC Image Load Functions
+  ***********************************************************************/
+ 
+ #ifdef USE_MAC_IMAGE_IO
+ static int
+ image_load_image_io (struct frame *f, struct image *img, CFStringRef type)
+ {
+   CFDictionaryRef options, src_props = NULL, props = NULL;
+   CFStringRef keys[2];
+   CFTypeRef values[2];
+   CFIndex num_values;
+   Lisp_Object specified_file, specified_data;
+   CGImageSourceRef source = NULL;
+   size_t count;
+   CGImageRef image = NULL;
+   int loop_count = -1;
+   double delay_time = -1.0;
+   int width, height;
+   XImagePtr ximg = NULL;
+   CGContextRef context;
+   CGRect rectangle, clip_rectangle;
+   CGAffineTransform transform;
+   Boolean has_alpha_p, gif_p, tiff_p;
+ 
+   keys[0] = kCGImageSourceShouldCache;
+   values[0] = (CFTypeRef) kCFBooleanFalse;
+   num_values = 1;
+   if (type == NULL)
+     gif_p = tiff_p = false;
+   else
+     {
+       gif_p = UTTypeEqual (type, kUTTypeGIF);
+       tiff_p = UTTypeEqual (type, kUTTypeTIFF);
+       keys[num_values] = kCGImageSourceTypeIdentifierHint;
+       values[num_values] = (CFTypeRef) type;
+       num_values++;
+     }
+ 
+   options = CFDictionaryCreate (NULL, (const void **) keys,
+ 				(const void **) values, num_values,
+ 				&kCFTypeDictionaryKeyCallBacks,
+ 				&kCFTypeDictionaryValueCallBacks);
+   if (options == NULL)
+     {
+       image_error ("Error creating options for image `%s'", img->spec, Qnil);
+       return 0;
+     }
+ 
+   /* Open the file.  */
+   specified_file = image_spec_value (img->spec, QCfile, NULL);
+   specified_data = image_spec_value (img->spec, QCdata, NULL);
+ 
+   if (NILP (specified_data))
+     {
+       Lisp_Object file;
+       CFStringRef path;
+       CFURLRef url;
+ 
+       file = x_find_image_file (specified_file);
+       if (!STRINGP (file))
+ 	{
+ 	  CFRelease (options);
+ 	  image_error ("Cannot find image file `%s'", specified_file, Qnil);
+ 	  return 0;
+ 	}
+       path = cfstring_create_with_utf8_cstring (SSDATA (file));
+       if (path)
+ 	{
+ 	  url = CFURLCreateWithFileSystemPath (NULL, path,
+ 					       kCFURLPOSIXPathStyle, 0);
+ 	  CFRelease (path);
+ 	  if (url)
+ 	    {
+ 	      source = CGImageSourceCreateWithURL (url, options);
+ 	      CFRelease (url);
+ 	    }
+ 	}
+     }
+   else
+     {
+       CFDataRef data = CFDataCreate (NULL, SDATA (specified_data),
+ 				     SBYTES (specified_data));
+ 
+       if (data)
+ 	{
+ 	  source = CGImageSourceCreateWithData (data, options);
+ 	  CFRelease (data);
+ 	}
+     }
+   CFRelease (options);
+ 
+   if (source)
+     {
+       CFStringRef real_type;
+ 
+       if (type == NULL
+ 	  || (real_type = CGImageSourceGetType (source),
+ 	      real_type && UTTypeEqual (type, real_type)))
+ 	src_props = CGImageSourceCopyProperties (source, NULL);
+       if (src_props)
+ 	{
+ 	  EMACS_INT ino = 0;
+ 
+ 	  count = CGImageSourceGetCount (source);
+ 	  if (type == NULL || gif_p || tiff_p)
+ 	    {
+ 	      Lisp_Object image = image_spec_value (img->spec, QCindex, NULL);
+ 
+ 	      if (INTEGERP (image))
+ 		ino = XFASTINT (image);
+ 	    }
+ 	  if (ino < count)
+ 	    {
+ 	      props = CGImageSourceCopyPropertiesAtIndex (source, ino, NULL);
+ 	      if (props)
+ 		image = CGImageSourceCreateImageAtIndex (source, ino, NULL);
+ 	    }
+ 	}
+       CFRelease (source);
+     }
+ 
+   if (image == NULL)
+     {
+       if (src_props)
+ 	CFRelease (src_props);
+       if (props)
+ 	CFRelease (props);
+       image_error ("Error reading image `%s'", img->spec, Qnil);
+       return 0;
+     }
+   else
+     {
+       CFBooleanRef boolean;
+ 
+       has_alpha_p =
+ 	(CFDictionaryGetValueIfPresent (props, kCGImagePropertyHasAlpha,
+ 					(const void **) &boolean)
+ 	 && CFBooleanGetValue (boolean));
+       if (gif_p)
+ 	{
+ 	  CFDictionaryRef dict;
+ 	  CFNumberRef number;
+ 
+ 	  dict = CFDictionaryGetValue (src_props,
+ 				       kCGImagePropertyGIFDictionary);
+ 	  if (dict
+ 	      && CFDictionaryGetValueIfPresent (dict,
+ 						kCGImagePropertyGIFLoopCount,
+ 						(const void **) &number))
+ 	    CFNumberGetValue (number, kCFNumberIntType, &loop_count);
+ 
+ 	  dict = CFDictionaryGetValue (props, kCGImagePropertyGIFDictionary);
+ 	  if (dict
+ 	      /* Use the unclamped delay time if available.  */
+ 	      && (CFDictionaryGetValueIfPresent (dict,
+ 						 CFSTR ("UnclampedDelayTime"),
+ 						 (const void **) &number)
+ 		  || CFDictionaryGetValueIfPresent (dict,
+ 						    kCGImagePropertyGIFDelayTime,
+ 						    (const void **) &number)))
+ 	    CFNumberGetValue (number, kCFNumberDoubleType, &delay_time);
+ 	}
+       CFRelease (src_props);
+       CFRelease (props);
+     }
+ 
+   width = CGImageGetWidth (image);
+   height = CGImageGetHeight (image);
+   if (type == NULL)
+     {
+       Lisp_Object value;
+       int desired_width, desired_height;
+ 
+       value = image_spec_value (img->spec, QCwidth, NULL);
+       desired_width = (INTEGERP (value)  ? XFASTINT (value) : -1);
+       value = image_spec_value (img->spec, QCheight, NULL);
+       desired_height = (INTEGERP (value) ? XFASTINT (value) : -1);
+ 
+       if (desired_width != -1 && desired_height == -1)
+ 	/* w known, calculate h.  */
+ 	desired_height = (double) desired_width / width * height + .5;
+       if (desired_width == -1 && desired_height != -1)
+ 	/* h known, calculate w.  */
+ 	desired_width = (double) desired_height / height * width + .5;
+       if (desired_width != -1 && desired_height != -1)
+ 	{
+ 	  width = desired_width;
+ 	  height = desired_height;
+ 	}
+     }
+ 
+   rectangle = CGRectMake (0, 0, width, height);
+ 
+   if (type == NULL)
+     {
+       Lisp_Object crop = image_spec_value (img->spec, QCcrop, NULL);
+       CGRect crop_rect;
+ 
+       if (CONSP (crop) && INTEGERP (XCAR (crop)))
+ 	{
+ 	  crop_rect.size.width = XINT (XCAR (crop));
+ 	  crop = XCDR (crop);
+ 	  if (CONSP (crop) && INTEGERP (XCAR (crop)))
+ 	    {
+ 	      crop_rect.size.height = XINT (XCAR (crop));
+ 	      crop = XCDR (crop);
+ 	      if (CONSP (crop) && INTEGERP (XCAR (crop)))
+ 		{
+ 		  crop_rect.origin.x = XINT (XCAR (crop));
+ 		  crop = XCDR (crop);
+ 		  if (CONSP (crop) && INTEGERP (XCAR (crop)))
+ 		    {
+ 		      crop_rect.origin.y = XINT (XCAR (crop));
+ 
+ 		      /* Simulate MagickCropImage's behavior for zero
+ 			 size and negative origin.  */
+ 		      if (crop_rect.size.width == 0)
+ 			crop_rect.size.width = width;
+ 		      if (crop_rect.size.height == 0)
+ 			crop_rect.size.height = height;
+ 		      if (crop_rect.origin.x < 0)
+ 			{
+ 			  crop_rect.size.width += crop_rect.origin.x;
+ 			  crop_rect.origin.x = 0;
+ 			}
+ 		      if (crop_rect.origin.y < 0)
+ 			{
+ 			  crop_rect.size.height += crop_rect.origin.y;
+ 			  crop_rect.origin.y = 0;
+ 			}
+ 
+ 		      crop_rect.origin.y = (CGRectGetMaxY (rectangle)
+ 					    - CGRectGetMaxY (crop_rect));
+ 		      crop_rect = CGRectIntersection (crop_rect, rectangle);
+ 		      rectangle.origin.x = - CGRectGetMinX (crop_rect);
+ 		      rectangle.origin.y = - CGRectGetMinY (crop_rect);
+ 		      width = CGRectGetWidth (crop_rect);
+ 		      height = CGRectGetHeight (crop_rect);
+ 		    }
+ 		}
+ 	    }
+ 	}
+     }
+ 
+   clip_rectangle = CGRectMake (0, 0, width, height);
+ 
+   transform = CGAffineTransformIdentity;
+   if (type == NULL)
+     {
+       Lisp_Object value = image_spec_value (img->spec, QCrotation, NULL);
+ 
+       if (FLOATP (value))
+ 	{
+ 	  double rotation = XFLOAT_DATA (value);
+ 	  CGRect rotated_clip;
+ 	  CGFloat ceil_width, ceil_height;
+ 
+ 	  transform = CGAffineTransformMakeRotation (- rotation * M_PI / 180);
+ 	  rotated_clip = CGRectApplyAffineTransform (clip_rectangle, transform);
+ 	  ceil_width = ceil (CGRectGetWidth (rotated_clip));
+ 	  ceil_height = ceil (CGRectGetHeight (rotated_clip));
+ 	  transform.tx = - (CGRectGetMinX (rotated_clip)
+ 			    - (ceil_width - CGRectGetWidth (rotated_clip))/2);
+ 	  transform.ty = - (CGRectGetMinY (rotated_clip)
+ 			    - (ceil_height - CGRectGetHeight (rotated_clip))/2);
+ 	  width = ceil_width;
+ 	  height = ceil_height;
+ 	}
+     }
+ 
+   if (!check_image_size (f, width, height))
+     {
+       CGImageRelease (image);
+       image_error ("Invalid image size (see `max-image-size')", Qnil, Qnil);
+       return 0;
+     }
+ 
+   if (!x_create_x_image_and_pixmap (f, width, height, 0, &ximg, &img->pixmap))
+     {
+       CGImageRelease (image);
+       image_error ("Out of memory (%s)", img->spec, Qnil);
+       return 0;
+     }
+ 
+   context = CGBitmapContextCreate (ximg->data, ximg->width, ximg->height, 8,
+ 				   ximg->bytes_per_line,
+ 				   mac_cg_color_space_rgb,
+ 				   kCGImageAlphaNoneSkipFirst
+ 				   | kCGBitmapByteOrder32Host);
+   if (has_alpha_p || !CGAffineTransformIsIdentity (transform))
+     {
+       Lisp_Object specified_bg;
+       XColor color;
+ 
+       specified_bg = image_spec_value (img->spec, QCbackground, NULL);
+       if (!STRINGP (specified_bg)
+ 	  || !mac_defined_color (f, SSDATA (specified_bg), &color, 0))
+ 	{
+ 	  color.pixel = FRAME_BACKGROUND_PIXEL (f);
+ 	  color.red = RED16_FROM_ULONG (color.pixel);
+ 	  color.green = GREEN16_FROM_ULONG (color.pixel);
+ 	  color.blue = BLUE16_FROM_ULONG (color.pixel);
+ 	}
+       CGContextSetRGBFillColor (context, color.red / 65535.0,
+ 				color.green / 65535.0,
+ 				color.blue / 65535.0, 1.0);
+       CGContextFillRect (context, CGRectMake (0, 0, width, height));
+     }
+   CGContextConcatCTM (context, transform);
+   CGContextClipToRect (context, clip_rectangle);
+   CGContextDrawImage (context, rectangle, image);
+   CGContextRelease (context);
+   CGImageRelease (image);
+ 
+   if (gif_p)
+     {
+       Lisp_Object extension_data = Qnil;
+ 
+       /* Save GIF image extension data.
+ 	 Format is (0xff "NETSCAPE2.0" 0x00 DATA_SUB_BLOCK_FOR_LOOP_COUNT
+ 		    0xf9 GRAPHIC_CONTROL_EXTENSION_BLOCK).  */
+       if (delay_time >= 0)
+ 	{
+ 	  Lisp_Object gce = make_uninit_string (4);
+ 	  int centisec = delay_time * 100.0 + 0.5;
+ 
+ 	  /* Fill the delay time field.  */
+ 	  SSET (gce, 1, centisec & 0xff);
+ 	  SSET (gce, 2, (centisec >> 8) & 0xff);
+ 	  /* We don't know about other fields.  */
+ 	  SSET (gce, 0, 0);
+ 	  SSET (gce, 3, 0);
+ 	  extension_data = Fcons (make_number (0xf9),
+ 				  Fcons (gce,
+ 					 extension_data));
+ 	}
+       if (loop_count >= 0)
+ 	{
+ 	  Lisp_Object data_sub_block = make_uninit_string (3);
+ 
+ 	  SSET (data_sub_block, 0, 0x01);
+ 	  SSET (data_sub_block, 1, loop_count & 0xff);
+ 	  SSET (data_sub_block, 2, (loop_count >> 8) & 0xff);
+ 	  extension_data = Fcons (make_number (0),
+ 				  Fcons (data_sub_block,
+ 					 extension_data));
+ 	  extension_data = Fcons (make_number (0xff),
+ 				  Fcons (build_string ("NETSCAPE2.0"),
+ 					 extension_data));
+ 	}
+       if (!NILP (extension_data))
+ 	img->lisp_data = Fcons (Qextension_data,
+ 				Fcons (extension_data,
+ 				       img->lisp_data));
+       if (delay_time >= 0)
+ 	img->lisp_data = Fcons (Qdelay,
+ 				Fcons (make_float (delay_time),
+ 				       img->lisp_data));
+     }
+   if ((type == NULL || gif_p || tiff_p) && count > 1)
+     img->lisp_data = Fcons (Qcount,
+ 			    Fcons (make_number (count),
+ 				   img->lisp_data));
+ 
+   img->width = width;
+   img->height = height;
+   /* Maybe fill in the background field while we have ximg handy. */
+   if (NILP (image_spec_value (img->spec, QCbackground, NULL)))
+     IMAGE_BACKGROUND (img, f, ximg);
+ 
+   /* Put the image into the pixmap.  */
+   x_put_x_image (f, ximg, img->pixmap, width, height);
+   x_destroy_x_image (ximg);
+   return 1;
+ }
+ #else  /* !USE_MAC_IMAGE_IO */
+ static int image_load_quicktime (struct frame *, struct image *img, OSType);
+ static int image_load_quartz2d (struct frame *, struct image *img, int);
+ 
+ static OSErr
+ find_image_fsspec (Lisp_Object specified_file, Lisp_Object *file, FSSpec *fss)
+ {
+   OSErr err;
+   AEDesc desc;
+ 
+   *file = x_find_image_file (specified_file);
+   if (!STRINGP (*file))
+     return fnfErr;		/* file or directory not found;
+ 				   incomplete pathname */
+   /* Try to open the image file.  */
+   err = AECoercePtr (TYPE_FILE_NAME, SDATA (*file),
+ 		     SBYTES (*file), typeFSS, &desc);
+   if (err == noErr)
+     {
+       err = AEGetDescData (&desc, fss, sizeof (FSSpec));
+       AEDisposeDesc (&desc);
+     }
+   return err;
+ }
+ 
+ static int
+ image_load_qt_1 (struct frame *f, struct image *img, OSType type,
+ 		 const FSSpec *fss, Handle dh)
+ {
+   ComponentResult err;
+   GraphicsImportComponent gi;
+   Rect rect;
+   unsigned long count;
+   int width, height;
+   ImageDescriptionHandle desc_handle;
+   short draw_all_pixels;
+   Lisp_Object specified_bg;
+   XColor color;
+   XImagePtr ximg;
+   RGBColor bg_color;
+ 
+   err = OpenADefaultComponent (GraphicsImporterComponentType, type, &gi);
+   if (err != noErr)
+     {
+       image_error ("Cannot get importer component for `%s'", img->spec, Qnil);
+       return 0;
+     }
+   if (dh == NULL)
+     {
+       /* read from file system spec */
+       err = GraphicsImportSetDataFile (gi, fss);
+       if (err != noErr)
+ 	{
+ 	  image_error ("Cannot set fsspec to graphics importer for '%s'",
+ 		       img->spec, Qnil);
+ 	  goto error;
+ 	}
+     }
+   else
+     {
+       /* read from data handle */
+       err = GraphicsImportSetDataHandle (gi, dh);
+       if (err != noErr)
+ 	{
+ 	  image_error ("Cannot set data handle to graphics importer for `%s'",
+ 		       img->spec, Qnil);
+ 	  goto error;
+ 	}
+     }
+   if (type == kQTFileTypeTIFF)
+     {
+       Lisp_Object image;
+ 
+       err = GraphicsImportGetImageCount (gi, &count);
+       if (err != noErr)
+ 	{
+ 	  image_error ("Can't get image count in image `%s'", img->spec, Qnil);
+ 	  goto error;
+ 	}
+       image = image_spec_value (img->spec, QCindex, NULL);
+       if (INTEGERP (image))
+ 	{
+ 	  EMACS_INT ino = XFASTINT (image);
+ 
+ 	  if (ino >= count)
+ 	    {
+ 	      image_error ("Invalid image number `%s' in image `%s'",
+ 			   image, img->spec);
+ 	      goto error;
+ 	    }
+ 	  err = GraphicsImportSetImageIndex (gi, ino + 1);
+ 	  if (err != noErr)
+ 	    {
+ 	      image_error ("Can't set image index `%s' in image `%s'",
+ 			   image, img->spec);
+ 	      goto error;
+ 	    }
+ 	}
+     }
+   err = GraphicsImportGetImageDescription (gi, &desc_handle);
+   if (err != noErr || desc_handle == NULL)
+     {
+       image_error ("Error reading `%s'", img->spec, Qnil);
+       goto error;
+     }
+   width = img->width = (*desc_handle)->width;
+   height = img->height = (*desc_handle)->height;
+   DisposeHandle ((Handle)desc_handle);
+ 
+   if (!check_image_size (f, width, height))
+     {
+       image_error ("Invalid image size (see `max-image-size')", Qnil, Qnil);
+       goto error;
+     }
+ 
+   err = GraphicsImportDoesDrawAllPixels (gi, &draw_all_pixels);
+ #if 0
+   /* Don't check the error code here.  It may have an undocumented
+      value -32766. */
+   if (err != noErr)
+     {
+       image_error ("Error reading `%s'", img->spec, Qnil);
+       goto error;
+     }
+ #endif
+   if (draw_all_pixels != graphicsImporterDrawsAllPixels)
+     {
+       specified_bg = image_spec_value (img->spec, QCbackground, NULL);
+       if (!STRINGP (specified_bg)
+ 	  || !mac_defined_color (f, SSDATA (specified_bg), &color, 0))
+ 	{
+ 	  color.pixel = FRAME_BACKGROUND_PIXEL (f);
+ 	  color.red = RED16_FROM_ULONG (color.pixel);
+ 	  color.green = GREEN16_FROM_ULONG (color.pixel);
+ 	  color.blue = BLUE16_FROM_ULONG (color.pixel);
+ 	}
+     }
+ 
+   if (!x_create_x_image_and_pixmap (f, width, height, 0, &ximg, &img->pixmap))
+     goto error;
+   if (draw_all_pixels != graphicsImporterDrawsAllPixels)
+     {
+       CGrafPtr old_port;
+       GDHandle old_gdh;
+ 
+       GetGWorld (&old_port, &old_gdh);
+       SetGWorld (ximg, NULL);
+       bg_color.red = color.red;
+       bg_color.green = color.green;
+       bg_color.blue = color.blue;
+       RGBBackColor (&bg_color);
+       GetPortBounds (ximg, &rect);
+       EraseRect (&rect);
+       SetGWorld (old_port, old_gdh);
+     }
+   GraphicsImportSetGWorld (gi, ximg, NULL);
+   GraphicsImportDraw (gi);
+   CloseComponent (gi);
+ 
+   if (type == kQTFileTypeTIFF && count > 1)
+     img->lisp_data = Fcons (Qcount,
+ 			    Fcons (make_number (count),
+ 				   img->lisp_data));
+ 
+   /* Maybe fill in the background field while we have ximg handy. */
+   if (NILP (image_spec_value (img->spec, QCbackground, NULL)))
+     IMAGE_BACKGROUND (img, f, ximg);
+ 
+   /* Put the image into the pixmap.  */
+   x_put_x_image (f, ximg, img->pixmap, width, height);
+   x_destroy_x_image (ximg);
+   return 1;
+ 
+  error:
+   CloseComponent (gi);
+   return 0;
+ }
+ 
+ 
+ /* Load an image using the QuickTime Graphics Importer.
+    Note: The alpha channel does not work for PNG images. */
+ static int
+ image_load_quicktime (struct frame *f, struct image *img, OSType type)
+ {
+   Lisp_Object specified_file;
+   Lisp_Object specified_data;
+   OSErr err;
+ 
+   specified_file = image_spec_value (img->spec, QCfile, NULL);
+   specified_data = image_spec_value (img->spec, QCdata, NULL);
+ 
+   if (NILP (specified_data))
+     {
+       /* Read from a file */
+       Lisp_Object file;
+       FSSpec fss;
+ 
+       err = find_image_fsspec (specified_file, &file, &fss);
+       if (err != noErr)
+ 	{
+ 	  if (err == fnfErr)
+ 	    image_error ("Cannot find image file `%s'", specified_file, Qnil);
+ 	  else
+ 	    image_error ("Cannot open `%s'", file, Qnil);
+ 	  return 0;
+ 	}
+       return image_load_qt_1 (f, img, type, &fss, NULL);
+     }
+   else
+     {
+       /* Memory source! */
+       int success_p;
+       Handle dh;
+ 
+       err = PtrToHand (SDATA (specified_data), &dh, SBYTES (specified_data));
+       if (err != noErr)
+ 	{
+ 	  image_error ("Cannot allocate data handle for `%s'",
+ 		       img->spec, Qnil);
+ 	  return 0;
+ 	}
+       success_p = image_load_qt_1 (f, img, type, NULL, dh);
+       DisposeHandle (dh);
+       return success_p;
+     }
+ }
+ 
+ 
+ static int
+ image_load_quartz2d (struct frame *f, struct image *img, int png_p)
+ {
+   Lisp_Object file, specified_file;
+   Lisp_Object specified_data, specified_bg;
+   struct gcpro gcpro1;
+   CGDataProviderRef source;
+   CGImageRef image;
+   int width, height;
+   XColor color;
+   XImagePtr ximg = NULL;
+   CGContextRef context;
+   CGRect rectangle;
+ 
+   /* Open the file.  */
+   specified_file = image_spec_value (img->spec, QCfile, NULL);
+   specified_data = image_spec_value (img->spec, QCdata, NULL);
+ 
+   file = Qnil;
+   GCPRO1 (file);
+ 
+   if (NILP (specified_data))
+     {
+       CFStringRef path;
+       CFURLRef url;
+ 
+       file = x_find_image_file (specified_file);
+       if (!STRINGP (file))
+ 	{
+ 	  image_error ("Cannot find image file `%s'", specified_file, Qnil);
+ 	  UNGCPRO;
+ 	  return 0;
+ 	}
+       path = cfstring_create_with_utf8_cstring (SSDATA (file));
+       url = CFURLCreateWithFileSystemPath (NULL, path,
+ 					   kCFURLPOSIXPathStyle, 0);
+       CFRelease (path);
+       source = CGDataProviderCreateWithURL (url);
+       CFRelease (url);
+     }
+   else
+     source = CGDataProviderCreateWithData (NULL, SDATA (specified_data),
+ 					   SBYTES (specified_data), NULL);
+ 
+   if (png_p)
+     image = CGImageCreateWithPNGDataProvider (source, NULL, false,
+ 					      kCGRenderingIntentDefault);
+   else
+     image = CGImageCreateWithJPEGDataProvider (source, NULL, false,
+ 					       kCGRenderingIntentDefault);
+ 
+   CGDataProviderRelease (source);
+   if (image == NULL)
+     {
+       UNGCPRO;
+       image_error ("Error reading image `%s'", img->spec, Qnil);
+       return 0;
+     }
+   width = img->width = CGImageGetWidth (image);
+   height = img->height = CGImageGetHeight (image);
+ 
+   if (!check_image_size (f, width, height))
+     {
+       CGImageRelease (image);
+       UNGCPRO;
+       image_error ("Invalid image size (see `max-image-size')", Qnil, Qnil);
+       return 0;
+     }
+ 
+   if (png_p)
+     {
+       specified_bg = image_spec_value (img->spec, QCbackground, NULL);
+       if (!STRINGP (specified_bg)
+ 	  || !mac_defined_color (f, SSDATA (specified_bg), &color, 0))
+ 	{
+ 	  color.pixel = FRAME_BACKGROUND_PIXEL (f);
+ 	  color.red = RED16_FROM_ULONG (color.pixel);
+ 	  color.green = GREEN16_FROM_ULONG (color.pixel);
+ 	  color.blue = BLUE16_FROM_ULONG (color.pixel);
+ 	}
+     }
+ 
+   if (!x_create_x_image_and_pixmap (f, width, height, 0, &ximg, &img->pixmap))
+     {
+       CGImageRelease (image);
+       UNGCPRO;
+       return 0;
+     }
+   rectangle = CGRectMake (0, 0, width, height);
+   QDBeginCGContext (ximg, &context);
+   if (png_p)
+     {
+       CGContextSetRGBFillColor (context, color.red / 65535.0,
+ 				color.green / 65535.0,
+ 				color.blue / 65535.0, 1.0);
+       CGContextFillRect (context, rectangle);
+     }
+   CGContextDrawImage (context, rectangle, image);
+   QDEndCGContext (ximg, &context);
+   CGImageRelease (image);
+ 
+   /* Maybe fill in the background field while we have ximg handy. */
+   if (NILP (image_spec_value (img->spec, QCbackground, NULL)))
+     IMAGE_BACKGROUND (img, f, ximg);
+ 
+   /* Put the image into the pixmap.  */
+   x_put_x_image (f, ximg, img->pixmap, width, height);
+   x_destroy_x_image (ximg);
+   UNGCPRO;
+   return 1;
+ }
+ #endif	/* !USE_MAC_IMAGE_IO */
+ 
+ #endif  /* HAVE_MACGUI */
+ 
+ 
  /***********************************************************************
  			      XBM images
   ***********************************************************************/
*************** xbm_load (struct frame *f, struct image 
*** 2991,3003 ****
  			      XPM images
   ***********************************************************************/
  
! #if defined (HAVE_XPM) || defined (HAVE_NS)
  
  static int xpm_image_p (Lisp_Object object);
  static int xpm_load (struct frame *f, struct image *img);
  static int xpm_valid_color_symbols_p (Lisp_Object);
  
! #endif /* HAVE_XPM || HAVE_NS */
  
  #ifdef HAVE_XPM
  #ifdef HAVE_NTGUI
--- 4044,4056 ----
  			      XPM images
   ***********************************************************************/
  
! #if defined (HAVE_XPM) || defined (HAVE_MACGUI) || defined (HAVE_NS)
  
  static int xpm_image_p (Lisp_Object object);
  static int xpm_load (struct frame *f, struct image *img);
  static int xpm_valid_color_symbols_p (Lisp_Object);
  
! #endif /* HAVE_XPM || HAVE_MACGUI || HAVE_NS */
  
  #ifdef HAVE_XPM
  #ifdef HAVE_NTGUI
*************** static int xpm_valid_color_symbols_p (Li
*** 3020,3026 ****
  #endif /* HAVE_NTGUI */
  #endif /* HAVE_XPM */
  
! #if defined (HAVE_XPM) || defined (HAVE_NS)
  /* The symbol `xpm' identifying XPM-format images.  */
  
  static Lisp_Object Qxpm;
--- 4073,4079 ----
  #endif /* HAVE_NTGUI */
  #endif /* HAVE_XPM */
  
! #if defined (HAVE_XPM) || defined (HAVE_MACGUI) || defined (HAVE_NS)
  /* The symbol `xpm' identifying XPM-format images.  */
  
  static Lisp_Object Qxpm;
*************** xpm_image_p (Lisp_Object object)
*** 3324,3330 ****
  	      || xpm_valid_color_symbols_p (fmt[XPM_COLOR_SYMBOLS].value)));
  }
  
! #endif /* HAVE_XPM || HAVE_NS */
  
  #if defined HAVE_XPM && defined HAVE_X_WINDOWS && !defined USE_GTK
  ptrdiff_t
--- 4377,4383 ----
  	      || xpm_valid_color_symbols_p (fmt[XPM_COLOR_SYMBOLS].value)));
  }
  
! #endif /* HAVE_XPM || HAVE_MACGUI || HAVE_NS */
  
  #if defined HAVE_XPM && defined HAVE_X_WINDOWS && !defined USE_GTK
  ptrdiff_t
*************** xpm_load (struct frame *f, struct image 
*** 3630,3638 ****
  
  #endif /* HAVE_XPM */
  
! #if defined (HAVE_NS) && !defined (HAVE_XPM)
  
! /* XPM support functions for NS where libxpm is not available.
     Only XPM version 3 (without any extensions) is supported.  */
  
  static void xpm_put_color_table_v (Lisp_Object, const unsigned char *,
--- 4683,4691 ----
  
  #endif /* HAVE_XPM */
  
! #if defined (HAVE_MACGUI) || ( defined (HAVE_NS) && !defined (HAVE_XPM) )
  
! /* XPM support functions for Mac OS where libxpm is not available.
     Only XPM version 3 (without any extensions) is supported.  */
  
  static void xpm_put_color_table_v (Lisp_Object, const unsigned char *,
*************** xpm_put_color_table_h (Lisp_Object color
*** 3783,3789 ****
  {
    struct Lisp_Hash_Table *table = XHASH_TABLE (color_table);
    EMACS_UINT hash_code;
!   Lisp_Object chars = make_unibyte_string (chars_start, chars_len);
  
    hash_lookup (table, chars, &hash_code);
    hash_put (table, chars, color, hash_code);
--- 4836,4842 ----
  {
    struct Lisp_Hash_Table *table = XHASH_TABLE (color_table);
    EMACS_UINT hash_code;
!   Lisp_Object chars = make_unibyte_string ((char *) chars_start, chars_len);
  
    hash_lookup (table, chars, &hash_code);
    hash_put (table, chars, color, hash_code);
*************** xpm_get_color_table_h (Lisp_Object color
*** 3795,3802 ****
                         int chars_len)
  {
    struct Lisp_Hash_Table *table = XHASH_TABLE (color_table);
!   ptrdiff_t i =
!     hash_lookup (table, make_unibyte_string (chars_start, chars_len), NULL);
  
    return i >= 0 ? HASH_VALUE (table, i) : Qnil;
  }
--- 4848,4855 ----
                         int chars_len)
  {
    struct Lisp_Hash_Table *table = XHASH_TABLE (color_table);
!   ptrdiff_t i = hash_lookup (table, make_unibyte_string ((char *) chars_start,
! 							 chars_len), NULL);
  
    return i >= 0 ? HASH_VALUE (table, i) : Qnil;
  }
*************** xpm_load_image (struct frame *f,
*** 3830,3837 ****
                  const unsigned char *contents,
                  const unsigned char *end)
  {
!   const unsigned char *s = contents, *beg, *str;
!   unsigned char buffer[BUFSIZ];
    int width, height, x, y;
    int num_colors, chars_per_pixel;
    ptrdiff_t len;
--- 4883,4890 ----
                  const unsigned char *contents,
                  const unsigned char *end)
  {
!   const unsigned char *s = contents, *beg;
!   char buffer[BUFSIZ];
    int width, height, x, y;
    int num_colors, chars_per_pixel;
    ptrdiff_t len;
*************** xpm_load_image (struct frame *f,
*** 3920,3926 ****
  
    while (num_colors-- > 0)
      {
!       char *color, *max_color;
        int key, next_key, max_key = 0;
        Lisp_Object symbol_color = Qnil, color_val;
        XColor cdef;
--- 4973,4979 ----
  
    while (num_colors-- > 0)
      {
!       char *str, *color, *max_color;
        int key, next_key, max_key = 0;
        Lisp_Object symbol_color = Qnil, color_val;
        XColor cdef;
*************** xpm_load_image (struct frame *f,
*** 3974,3980 ****
  	    {
  	      if (xstrcasecmp (SSDATA (XCDR (specified_color)), "None") == 0)
  		color_val = Qt;
! 	      else if (x_defined_color (f, SDATA (XCDR (specified_color)),
  					&cdef, 0))
  		color_val = make_number (cdef.pixel);
  	    }
--- 5027,5033 ----
  	    {
  	      if (xstrcasecmp (SSDATA (XCDR (specified_color)), "None") == 0)
  		color_val = Qt;
! 	      else if (x_defined_color (f, SSDATA (XCDR (specified_color)),
  					&cdef, 0))
  		color_val = make_number (cdef.pixel);
  	    }
*************** xpm_load_image (struct frame *f,
*** 3994,4007 ****
  
    for (y = 0; y < height; y++)
      {
        expect (XPM_TK_STRING);
!       str = beg;
        if (len < width * chars_per_pixel)
  	goto failure;
!       for (x = 0; x < width; x++, str += chars_per_pixel)
  	{
  	  Lisp_Object color_val =
! 	    (*get_color_table) (color_table, str, chars_per_pixel);
  
  	  XPutPixel (ximg, x, y,
  		     (INTEGERP (color_val) ? XINT (color_val)
--- 5047,5062 ----
  
    for (y = 0; y < height; y++)
      {
+       const unsigned char *data;
+ 
        expect (XPM_TK_STRING);
!       data = beg;
        if (len < width * chars_per_pixel)
  	goto failure;
!       for (x = 0; x < width; x++, data += chars_per_pixel)
  	{
  	  Lisp_Object color_val =
! 	    (*get_color_table) (color_table, data, chars_per_pixel);
  
  	  XPutPixel (ximg, x, y,
  		     (INTEGERP (color_val) ? XINT (color_val)
*************** xpm_load (struct frame *f,
*** 4082,4088 ****
  	  return 0;
  	}
  
!       contents = slurp_file (SDATA (file), &size);
        if (contents == NULL)
  	{
  	  image_error ("Error loading XPM image `%s'", img->spec, Qnil);
--- 5137,5143 ----
  	  return 0;
  	}
  
!       contents = slurp_file (SSDATA (file), &size);
        if (contents == NULL)
  	{
  	  image_error ("Error loading XPM image `%s'", img->spec, Qnil);
*************** xpm_load (struct frame *f,
*** 4109,4115 ****
    return success_p;
  }
  
! #endif /* HAVE_NS && !HAVE_XPM */
  
  
  
--- 5164,5170 ----
    return success_p;
  }
  
! #endif /* HAVE_MACGUI || (HAVE_NS && !HAVE_XPM) */
  
  
  
*************** lookup_rgb_color (struct frame *f, int r
*** 4378,4383 ****
--- 5433,5443 ----
  {
    unsigned long pixel;
  
+ #ifdef HAVE_MACGUI
+   pixel = RGB_TO_ULONG (r >> 8, g >> 8, b >> 8);
+   gamma_correct (f, &pixel);
+ #endif /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NTGUI
    pixel = PALETTERGB (r >> 8, g >> 8, b >> 8);
  #endif /* HAVE_NTGUI */
*************** x_to_xcolors (struct frame *f, struct im
*** 4470,4476 ****
      {
        XColor *row = p;
  
! #if defined (HAVE_X_WINDOWS) || defined (HAVE_NTGUI)
        for (x = 0; x < img->width; ++x, ++p)
  	p->pixel = GET_PIXEL (ximg, x, y);
        if (rgb_p)
--- 5530,5536 ----
      {
        XColor *row = p;
  
! #if defined (HAVE_X_WINDOWS) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI)
        for (x = 0; x < img->width; ++x, ++p)
  	p->pixel = GET_PIXEL (ximg, x, y);
        if (rgb_p)
*************** x_disable_image (struct frame *f, struct
*** 4758,4764 ****
--- 5818,5828 ----
  
  #ifndef HAVE_NS  /* TODO: NS support, however this not needed for toolbars */
  
+ #ifdef HAVE_MACGUI
+ #define MaskForeground(f)  PIX_MASK_DRAW
+ #else
  #define MaskForeground(f)  WHITE_PIX_DEFAULT (f)
+ #endif
  
        gc = XCreateGC (dpy, img->pixmap, 0, NULL);
        XSetForeground (dpy, gc, BLACK_PIX_DEFAULT (f));
*************** pbm_load (struct frame *f, struct image 
*** 5359,5365 ****
  				 PNG
   ***********************************************************************/
  
! #if defined (HAVE_PNG) || defined (HAVE_NS)
  
  /* Function prototypes.  */
  
--- 6423,6429 ----
  				 PNG
   ***********************************************************************/
  
! #if defined (HAVE_PNG) || defined (HAVE_MACGUI) || defined (HAVE_NS)
  
  /* Function prototypes.  */
  
*************** png_image_p (Lisp_Object object)
*** 5430,5436 ****
    return fmt[PNG_FILE].count + fmt[PNG_DATA].count == 1;
  }
  
! #endif /* HAVE_PNG || HAVE_NS */
  
  
  #ifdef HAVE_PNG
--- 6494,6500 ----
    return fmt[PNG_FILE].count + fmt[PNG_DATA].count == 1;
  }
  
! #endif /* HAVE_PNG || HAVE_MACGUI || HAVE_NS */
  
  
  #ifdef HAVE_PNG
*************** png_load (struct frame *f, struct image 
*** 5809,5815 ****
  	{
  	  /* We use the current frame background, ignoring any default
  	     background color set by the image.  */
! #if defined (HAVE_X_WINDOWS) || defined (HAVE_NTGUI)
  	  XColor color;
  	  png_color_16 frame_background;
  
--- 6873,6879 ----
  	{
  	  /* We use the current frame background, ignoring any default
  	     background color set by the image.  */
! #if defined (HAVE_X_WINDOWS) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI)
  	  XColor color;
  	  png_color_16 frame_background;
  
*************** png_load (struct frame *f, struct image 
*** 5962,5967 ****
--- 7026,7043 ----
  
  #else /* HAVE_PNG */
  
+ #ifdef HAVE_MACGUI
+ static int
+ png_load (struct frame *f, struct image *img)
+ {
+ #ifdef USE_MAC_IMAGE_IO
+   return image_load_image_io (f, img, kUTTypePNG);
+ #else
+   return image_load_quartz2d (f, img, 1);
+ #endif
+ }
+ #endif  /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NS
  static int
  png_load (struct frame *f, struct image *img)
*************** png_load (struct frame *f, struct image 
*** 5981,5987 ****
  				 JPEG
   ***********************************************************************/
  
! #if defined (HAVE_JPEG) || defined (HAVE_NS)
  
  static int jpeg_image_p (Lisp_Object object);
  static int jpeg_load (struct frame *f, struct image *img);
--- 7057,7063 ----
  				 JPEG
   ***********************************************************************/
  
! #if defined (HAVE_JPEG) || defined (HAVE_MACGUI) || defined (HAVE_NS)
  
  static int jpeg_image_p (Lisp_Object object);
  static int jpeg_load (struct frame *f, struct image *img);
*************** jpeg_image_p (Lisp_Object object)
*** 6051,6057 ****
    return fmt[JPEG_FILE].count + fmt[JPEG_DATA].count == 1;
  }
  
! #endif /* HAVE_JPEG || HAVE_NS */
  
  #ifdef HAVE_JPEG
  
--- 7127,7133 ----
    return fmt[JPEG_FILE].count + fmt[JPEG_DATA].count == 1;
  }
  
! #endif /* HAVE_JPEG || HAVE_MACGUI || HAVE_NS */
  
  #ifdef HAVE_JPEG
  
*************** jpeg_load (struct frame *f, struct image
*** 6509,6516 ****
    x_destroy_x_image (ximg);
    return 1;
  }
! 
! #else /* HAVE_JPEG */
  
  #ifdef HAVE_NS
  static int
--- 7585,7604 ----
    x_destroy_x_image (ximg);
    return 1;
  }
! 
! #else /* HAVE_JPEG */
! 
! #ifdef HAVE_MACGUI
! static int
! jpeg_load (struct frame *f, struct image *img)
! {
! #ifdef USE_MAC_IMAGE_IO
!   return image_load_image_io (f, img, kUTTypeJPEG);
! #else
!   return image_load_quartz2d (f, img, 0);
! #endif
! }
! #endif  /* HAVE_MACGUI */
  
  #ifdef HAVE_NS
  static int
*************** jpeg_load (struct frame *f, struct image
*** 6530,6536 ****
  				 TIFF
   ***********************************************************************/
  
! #if defined (HAVE_TIFF) || defined (HAVE_NS)
  
  static int tiff_image_p (Lisp_Object object);
  static int tiff_load (struct frame *f, struct image *img);
--- 7618,7624 ----
  				 TIFF
   ***********************************************************************/
  
! #if defined (HAVE_TIFF) || defined (HAVE_MACGUI) || defined (HAVE_NS)
  
  static int tiff_image_p (Lisp_Object object);
  static int tiff_load (struct frame *f, struct image *img);
*************** tiff_image_p (Lisp_Object object)
*** 6601,6607 ****
    return fmt[TIFF_FILE].count + fmt[TIFF_DATA].count == 1;
  }
  
! #endif /* HAVE_TIFF || HAVE_NS */
  
  #ifdef HAVE_TIFF
  
--- 7689,7695 ----
    return fmt[TIFF_FILE].count + fmt[TIFF_DATA].count == 1;
  }
  
! #endif /* HAVE_TIFF || HAVE_MACGUI || HAVE_NS */
  
  #ifdef HAVE_TIFF
  
*************** tiff_load (struct frame *f, struct image
*** 6959,6964 ****
--- 8047,8064 ----
  
  #else /* HAVE_TIFF */
  
+ #ifdef HAVE_MACGUI
+ static int
+ tiff_load (struct frame *f, struct image *img)
+ {
+ #ifdef USE_MAC_IMAGE_IO
+   return image_load_image_io (f, img, kUTTypeTIFF);
+ #else
+   return image_load_quicktime (f, img, kQTFileTypeTIFF);
+ #endif
+ }
+ #endif /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NS
  static int
  tiff_load (struct frame *f, struct image *img)
*************** tiff_load (struct frame *f, struct image
*** 6977,6983 ****
  				 GIF
   ***********************************************************************/
  
! #if defined (HAVE_GIF) || defined (HAVE_NS)
  
  static int gif_image_p (Lisp_Object object);
  static int gif_load (struct frame *f, struct image *img);
--- 8077,8083 ----
  				 GIF
   ***********************************************************************/
  
! #if defined (HAVE_GIF) || defined (HAVE_MACGUI) || defined (HAVE_NS)
  
  static int gif_image_p (Lisp_Object object);
  static int gif_load (struct frame *f, struct image *img);
*************** gif_image_p (Lisp_Object object)
*** 7058,7068 ****
    return fmt[GIF_FILE].count + fmt[GIF_DATA].count == 1;
  }
  
! #endif /* HAVE_GIF */
  
  #ifdef HAVE_GIF
  
! #if defined (HAVE_NTGUI)
  /* winuser.h might define DrawText to DrawTextA or DrawTextW.
     Undefine before redefining to avoid a preprocessor warning.  */
  #ifdef DrawText
--- 8158,8168 ----
    return fmt[GIF_FILE].count + fmt[GIF_DATA].count == 1;
  }
  
! #endif /* HAVE_GIF || HAVE_MACGUI */
  
  #ifdef HAVE_GIF
  
! #if defined (HAVE_NTGUI) || defined (HAVE_MACGUI)
  /* winuser.h might define DrawText to DrawTextA or DrawTextW.
     Undefine before redefining to avoid a preprocessor warning.  */
  #ifdef DrawText
*************** gif_image_p (Lisp_Object object)
*** 7073,7083 ****
  #include <gif_lib.h>
  #undef DrawText
  
! #else /* HAVE_NTGUI */
  
  #include <gif_lib.h>
  
! #endif /* HAVE_NTGUI */
  
  
  #ifdef HAVE_NTGUI
--- 8173,8183 ----
  #include <gif_lib.h>
  #undef DrawText
  
! #else /* !HAVE_NTGUI && !HAVE_MACGUI */
  
  #include <gif_lib.h>
  
! #endif /* !HAVE_NTGUI && !HAVE_MACGUI */
  
  
  #ifdef HAVE_NTGUI
*************** gif_load (struct frame *f, struct image 
*** 7447,7452 ****
--- 8547,8765 ----
  
  #else  /* !HAVE_GIF */
  
+ #ifdef HAVE_MACGUI
+ static int
+ gif_load (struct frame *f, struct image *img)
+ {
+ #ifdef USE_MAC_IMAGE_IO
+   return image_load_image_io (f, img, kUTTypeGIF);
+ #else  /* !USE_MAC_IMAGE_IO */
+   Lisp_Object specified_file, file;
+   Lisp_Object specified_data;
+   OSErr err;
+   Boolean graphic_p, movie_p, prefer_graphic_p;
+   Handle dh = NULL;
+   Movie movie = NULL;
+   Lisp_Object image;
+   Track track = NULL;
+   Media media = NULL;
+   long nsamples;
+   Rect rect;
+   Lisp_Object specified_bg;
+   XColor color;
+   RGBColor bg_color;
+   int width, height;
+   XImagePtr ximg;
+   TimeScale time_scale;
+   TimeValue time, duration;
+   int ino;
+   CGrafPtr old_port;
+   GDHandle old_gdh;
+ 
+   specified_file = image_spec_value (img->spec, QCfile, NULL);
+   specified_data = image_spec_value (img->spec, QCdata, NULL);
+ 
+   /* Animated gifs use QuickTime Movie Toolbox.  So initialize it here. */
+   EnterMovies ();
+ 
+   if (NILP (specified_data))
+     {
+       /* Read from a file */
+       FSSpec fss;
+       short refnum;
+ 
+       err = find_image_fsspec (specified_file, &file, &fss);
+       if (err != noErr)
+ 	{
+ 	  if (err == fnfErr)
+ 	    image_error ("Cannot find image file `%s'", specified_file, Qnil);
+ 	  else
+ 	    goto open_error;
+ 	}
+ 
+       err = CanQuickTimeOpenFile (&fss, kQTFileTypeGIF, 0,
+ 				  &graphic_p, &movie_p, &prefer_graphic_p, 0);
+       if (err != noErr)
+ 	goto open_error;
+ 
+       if (!graphic_p && !movie_p)
+ 	goto open_error;
+       if (prefer_graphic_p)
+ 	return image_load_qt_1 (f, img, kQTFileTypeGIF, &fss, NULL);
+       err = OpenMovieFile (&fss, &refnum, fsRdPerm);
+       if (err != noErr)
+ 	goto open_error;
+       err = NewMovieFromFile (&movie, refnum, NULL, NULL, 0, NULL);
+       CloseMovieFile (refnum);
+       if (err != noErr)
+ 	{
+ 	  image_error ("Error reading `%s'", file, Qnil);
+ 	  return 0;
+ 	}
+     }
+   else
+     {
+       /* Memory source! */
+       Handle dref = NULL;
+       long file_type_atom[3];
+ 
+       err = PtrToHand (SDATA (specified_data), &dh, SBYTES (specified_data));
+       if (err != noErr)
+ 	{
+ 	  image_error ("Cannot allocate data handle for `%s'",
+ 		       img->spec, Qnil);
+ 	  goto error;
+ 	}
+ 
+       file_type_atom[0] = EndianU32_NtoB (sizeof (long) * 3);
+       file_type_atom[1] = EndianU32_NtoB (kDataRefExtensionMacOSFileType);
+       file_type_atom[2] = EndianU32_NtoB (kQTFileTypeGIF);
+       err = PtrToHand (&dh, &dref, sizeof (Handle));
+       if (err == noErr)
+ 	/* no file name.  "" below should actually be "\p", but we
+ 	   avoid pascal string literals.  */
+ 	err = PtrAndHand ("", dref, 1);
+       if (err == noErr)
+ 	err = PtrAndHand (file_type_atom, dref, sizeof (long) * 3);
+       if (err != noErr)
+ 	{
+ 	  image_error ("Cannot allocate handle data ref for `%s'", img->spec, Qnil);
+ 	  goto error;
+ 	}
+       err = CanQuickTimeOpenDataRef (dref, HandleDataHandlerSubType, &graphic_p,
+ 				     &movie_p, &prefer_graphic_p, 0);
+       if (err != noErr)
+ 	goto open_error;
+ 
+       if (!graphic_p && !movie_p)
+ 	goto open_error;
+       if (prefer_graphic_p)
+ 	{
+ 	  int success_p;
+ 
+ 	  DisposeHandle (dref);
+ 	  success_p = image_load_qt_1 (f, img, kQTFileTypeGIF, NULL, dh);
+ 	  DisposeHandle (dh);
+ 	  return success_p;
+ 	}
+       err = NewMovieFromDataRef (&movie, 0, NULL, dref,
+ 				 HandleDataHandlerSubType);
+       DisposeHandle (dref);
+       if (err != noErr)
+ 	goto open_error;
+     }
+ 
+   image = image_spec_value (img->spec, QCindex, NULL);
+   ino = INTEGERP (image) ? XFASTINT (image) : 0;
+   track = GetMovieIndTrack (movie, 1);
+   media = GetTrackMedia (track);
+   nsamples = GetMediaSampleCount (media);
+   if (ino >= nsamples)
+     {
+       image_error ("Invalid image number `%s' in image `%s'",
+ 		   image, img->spec);
+       goto error;
+     }
+   time_scale = GetMediaTimeScale (media);
+ 
+   specified_bg = image_spec_value (img->spec, QCbackground, NULL);
+   if (!STRINGP (specified_bg)
+       || !mac_defined_color (f, SSDATA (specified_bg), &color, 0))
+     {
+       color.pixel = FRAME_BACKGROUND_PIXEL (f);
+       color.red = RED16_FROM_ULONG (color.pixel);
+       color.green = GREEN16_FROM_ULONG (color.pixel);
+       color.blue = BLUE16_FROM_ULONG (color.pixel);
+     }
+   GetMovieBox (movie, &rect);
+   width = img->width = rect.right - rect.left;
+   height = img->height = rect.bottom - rect.top;
+   if (!x_create_x_image_and_pixmap (f, width, height, 0, &ximg, &img->pixmap))
+     goto error;
+ 
+   GetGWorld (&old_port, &old_gdh);
+   SetGWorld (ximg, NULL);
+   bg_color.red = color.red;
+   bg_color.green = color.green;
+   bg_color.blue = color.blue;
+   RGBBackColor (&bg_color);
+   SetGWorld (old_port, old_gdh);
+   SetMovieActive (movie, 1);
+   SetMovieGWorld (movie, ximg, NULL);
+   SampleNumToMediaTime (media, ino + 1, &time, &duration);
+   SetMovieTimeValue (movie, time);
+   MoviesTask (movie, 0L);
+   DisposeTrackMedia (media);
+   DisposeMovieTrack (track);
+   DisposeMovie (movie);
+   if (dh)
+     DisposeHandle (dh);
+ 
+   /* Save GIF image extension data.
+      Format is (0xf9 GRAPHIC_CONTROL_EXTENSION_BLOCK).  */
+   {
+     Lisp_Object gce = make_uninit_string (4);
+     int centisec = ((float)duration / time_scale) * 100.0f + 0.5f;
+ 
+     /* Fill the delay time field.  */
+     SSET (gce, 1, centisec & 0xff);
+     SSET (gce, 2, (centisec >> 8) & 0xff);
+     /* We don't know about other fields.  */
+     SSET (gce, 0, 0);
+     SSET (gce, 3, 0);
+ 
+     img->lisp_data = list4 (Qdelay, make_float ((double) duration / time_scale),
+ 			    Qextension_data, list2 (make_number (0xf9), gce));
+     img->lisp_data = Fcons (Qcount,
+ 			    Fcons (make_number (nsamples),
+ 				   img->lisp_data));
+   }
+ 
+   /* Maybe fill in the background field while we have ximg handy. */
+   if (NILP (image_spec_value (img->spec, QCbackground, NULL)))
+     IMAGE_BACKGROUND (img, f, ximg);
+ 
+   /* Put the image into the pixmap.  */
+   x_put_x_image (f, ximg, img->pixmap, width, height);
+   x_destroy_x_image (ximg);
+   return 1;
+ 
+  open_error:
+   image_error ("Cannot open `%s'", file, Qnil);
+  error:
+   if (media)
+     DisposeTrackMedia (media);
+   if (track)
+     DisposeMovieTrack (track);
+   if (movie)
+     DisposeMovie (movie);
+   if (dh)
+     DisposeHandle (dh);
+   return 0;
+ #endif	/* !USE_MAC_IMAGE_IO */
+ }
+ #endif /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NS
  static int
  gif_load (struct frame *f, struct image *img)
*************** imagemagick_image_p (Lisp_Object object)
*** 7554,7559 ****
--- 8867,8880 ----
  /* The GIF library also defines DrawRectangle, but its never used in Emacs.
     Therefore rename the function so it doesn't collide with ImageMagick.  */
  #define DrawRectangle DrawRectangleGif
+ #ifdef HAVE_MACGUI
+ /* The CoreServices and ApplicationServices frameworks also define
+    ExceptionInfo and ColorInfo, respectively, but they are never used
+    in Emacs.  Therefore rename the types in ImageMagick so they don't
+    collide with the frameworks.  */
+ #define ExceptionInfo ExceptionInfoMagick
+ #define ColorInfo ColorInfoMagick
+ #endif
  #include <wand/MagickWand.h>
  
  /* ImageMagick 6.5.3 through 6.6.5 hid PixelGetMagickColor for some reason.
*************** imagemagick_load (struct frame *f, struc
*** 7978,7983 ****
--- 9299,9308 ----
    return success_p;
  }
  
+ #endif	/* defined (HAVE_IMAGEMAGICK) */
+ 
+ #if defined (HAVE_IMAGEMAGICK) || defined (USE_MAC_IMAGE_IO)
+ 
  DEFUN ("imagemagick-types", Fimagemagick_types, Simagemagick_types, 0, 0, 0,
         doc: /* Return a list of image types supported by ImageMagick.
  Each entry in this list is a symbol named after an ImageMagick format
*************** Note that ImageMagick recognizes many fi
*** 7989,7994 ****
--- 9314,9320 ----
  recognize as images, such as C.  See `imagemagick-types-inhibit'.  */)
    (void)
  {
+ #ifdef HAVE_IMAGEMAGICK
    Lisp_Object typelist = Qnil;
    size_t numf = 0;
    ExceptionInfo ex;
*************** recognize as images, such as C.  See `im
*** 8001,8009 ****
        typelist = Fcons (Qimagemagicktype, typelist);
      }
    return Fnreverse (typelist);
  }
  
! #endif	/* defined (HAVE_IMAGEMAGICK) */
  
  
  
--- 9327,9514 ----
        typelist = Fcons (Qimagemagicktype, typelist);
      }
    return Fnreverse (typelist);
+ #else
+   EXFUN (Fimage_io_types, 0);
+   Lisp_Object rest, typelist = Qnil;
+ 
+   for (rest = Fimage_io_types (); CONSP (rest); rest = XCDR (rest))
+     {
+       Lisp_Object extension = CAR_SAFE (CDR_SAFE (XCAR (rest)));
+ 
+       if (STRINGP (extension))
+ 	{
+ 	  extension = Fintern (Fupcase (extension), Qnil);
+ 	  if (NILP (Fmemq (extension, typelist)))
+ 	    typelist = Fcons (extension, typelist);
+ 	}
+     }
+ 
+   return Fnreverse (typelist);
+ #endif
  }
  
! #endif	/* defined (HAVE_IMAGEMAGICK) || defined (USE_MAC_IMAGE_IO) */
! 
! 
! 
! /***********************************************************************
! 			      Image I/O
!  ***********************************************************************/
! 
! #ifdef USE_MAC_IMAGE_IO
! static Lisp_Object Qimage_io;
! 
! static int image_io_image_p (Lisp_Object);
! static int image_io_load (struct frame *, struct image *);
! 
! /* Indices of image specification fields in image_io_format.  */
! 
! enum image_io_keyword_index
!   {
!     IMAGE_IO_TYPE,
!     IMAGE_IO_DATA,
!     IMAGE_IO_FILE,
!     IMAGE_IO_ASCENT,
!     IMAGE_IO_MARGIN,
!     IMAGE_IO_RELIEF,
!     IMAGE_IO_ALGORITHM,
!     IMAGE_IO_HEURISTIC_MASK,
!     IMAGE_IO_MASK,
!     IMAGE_IO_BACKGROUND,
!     IMAGE_IO_HEIGHT,
!     IMAGE_IO_WIDTH,
!     IMAGE_IO_ROTATION,
!     IMAGE_IO_CROP,
!     IMAGE_IO_LAST
!   };
! 
! static struct image_keyword image_io_format[IMAGE_IO_LAST] =
!   {
!     {":type",		IMAGE_SYMBOL_VALUE,			1},
!     {":data",		IMAGE_STRING_VALUE,			0},
!     {":file",		IMAGE_STRING_VALUE,			0},
!     {":ascent",		IMAGE_ASCENT_VALUE,			0},
!     {":margin",		IMAGE_NON_NEGATIVE_INTEGER_VALUE_OR_PAIR, 0},
!     {":relief",		IMAGE_INTEGER_VALUE,			0},
!     {":conversion",	IMAGE_DONT_CHECK_VALUE_TYPE,		0},
!     {":heuristic-mask",	IMAGE_DONT_CHECK_VALUE_TYPE,		0},
!     {":mask",		IMAGE_DONT_CHECK_VALUE_TYPE,		0},
!     {":background",	IMAGE_STRING_OR_NIL_VALUE,		0},
!     {":height",		IMAGE_INTEGER_VALUE,			0},
!     {":width",		IMAGE_INTEGER_VALUE,			0},
!     {":rotation",	IMAGE_NUMBER_VALUE,     		0},
!     {":crop",		IMAGE_DONT_CHECK_VALUE_TYPE,		0}
!   };
! 
! /* Structure describing the image type for any image handled via Image
!    I/O.  */
! 
! static struct image_type image_io_type =
!   {
!     &Qimage_io,
!     image_io_image_p,
!     image_io_load,
!     x_clear_image,
!     NULL
!   };
! 
! /* Return non-zero if OBJECT is a valid IMAGE_IO image specification.
!    Do this by calling parse_image_spec and supplying the keywords that
!    identify the IMAGE_IO format.  */
! 
! static int
! image_io_image_p (Lisp_Object object)
! {
!   struct image_keyword fmt[IMAGE_IO_LAST];
!   memcpy (fmt, image_io_format, sizeof fmt);
! 
!   if (!parse_image_spec (object, fmt, IMAGE_IO_LAST, Qimage_io))
!     return 0;
! 
!   /* Must specify either the :data or :file keyword.  */
!   return fmt[IMAGE_IO_FILE].count + fmt[IMAGE_IO_DATA].count == 1;
! }
! 
! static int
! image_io_load (struct frame *f, struct image *img)
! {
!   return image_load_image_io (f, img, NULL);
! }
! 
! DEFUN ("image-io-types", Fimage_io_types, Simage_io_types, 0, 0, 0,
!        doc: /* Return a list of image types supported by Image I/O.
! Each entry in this list is of the form (UTI-STRING EXTENSION-STRING),
! where UTI-STRING is a uniform type identifier (UTI) string, and
! EXTENSION-STRING is a preferred file name extension string or nil it
! is not available.  */)
!   (void)
! {
!   Lisp_Object typelist = Qnil;
!   CFArrayRef identifiers;
! 
!   BLOCK_INPUT;
!   identifiers = CGImageSourceCopyTypeIdentifiers ();
!   if (identifiers)
!     {
!       CFIndex i, count;
! 
!       count = CFArrayGetCount (identifiers);
!       for (i = 0; i < count; i++)
! 	{
! 	  CFStringRef identifier, extension;
! 	  Lisp_Object ext = Qnil;
! 
! 	  identifier = CFArrayGetValueAtIndex (identifiers, i);
! 	  extension =
! 	    UTTypeCopyPreferredTagWithClass (identifier,
! 					     kUTTagClassFilenameExtension);
! 	  if (extension)
! 	    {
! 	      ext = cfstring_to_lisp_nodecode (extension);
! 	      CFRelease (extension);
! 	    }
! 	  typelist = Fcons (list2 (cfstring_to_lisp_nodecode (identifier), ext),
! 			    typelist);
! 	}
!       CFRelease (identifiers);
!     }
!   UNBLOCK_INPUT;
! 
!   return Fnreverse (typelist);
! }
! 
! #if !defined (HAVE_IMAGEMAGICK)
! /* Fallback implementation of the image type `imagemagick' with the
!    Image I/O framework.  */
! static Lisp_Object Qimagemagick;
! 
! static int imagemagick_image_p (Lisp_Object);
! 
! static struct image_type imagemagick_type =
!   {
!     &Qimagemagick,
!     imagemagick_image_p,
!     image_io_load,
!     x_clear_image,
!     NULL
!   };
! 
! static int
! imagemagick_image_p (Lisp_Object object)
! {
!   struct image_keyword fmt[IMAGE_IO_LAST];
!   memcpy (fmt, image_io_format, sizeof fmt);
! 
!   if (!parse_image_spec (object, fmt, IMAGE_IO_LAST, Qimagemagick))
!     return 0;
! 
!   /* Must specify either the :data or :file keyword.  */
!   return fmt[IMAGE_IO_FILE].count + fmt[IMAGE_IO_DATA].count == 1;
! }
! 
! #endif	/* not defined (HAVE_IMAGEMAGICK) */
! 
! #endif	/* USE_MAC_IMAGE_IO */
  
  
  
*************** recognize as images, such as C.  See `im
*** 8011,8017 ****
  				 SVG
   ***********************************************************************/
  
! #if defined (HAVE_RSVG)
  
  /* Function prototypes.  */
  
--- 9516,9522 ----
  				 SVG
   ***********************************************************************/
  
! #if defined (HAVE_RSVG) || defined (USE_MAC_IMAGE_IO)
  
  /* Function prototypes.  */
  
*************** svg_image_p (Lisp_Object object)
*** 8096,8101 ****
--- 9601,9607 ----
    return fmt[SVG_FILE].count + fmt[SVG_DATA].count == 1;
  }
  
+ #if defined (HAVE_RSVG)
  #include <librsvg/rsvg.h>
  
  #ifdef HAVE_NTGUI
*************** svg_load_image (struct frame *f,        
*** 8390,8397 ****
    fn_g_error_free (err);
    return 0;
  }
  
! #endif	/* defined (HAVE_RSVG) */
  
  
  
--- 9896,9981 ----
    fn_g_error_free (err);
    return 0;
  }
+ #else  /* defined (USE_MAC_IMAGE_IO) */
+ static int
+ svg_load (struct frame *f, struct image *img)
+ {
+   extern int mac_svg_load_image (struct frame *, struct image *,
+ 				 unsigned char *, unsigned int, XColor *,
+ 				 int (*) (struct frame *, int, int),
+ 				 void (*) (const char *, Lisp_Object,
+ 					   Lisp_Object));
+   Lisp_Object specified_bg;
+   XColor background;
+   int success_p = 0;
+   Lisp_Object file_name;
+ 
+   specified_bg = image_spec_value (img->spec, QCbackground, NULL);
+   if (!STRINGP (specified_bg)
+       || !mac_defined_color (f, SSDATA (specified_bg), &background, 0))
+     {
+       background.pixel = FRAME_BACKGROUND_PIXEL (f);
+       background.red = RED16_FROM_ULONG (background.pixel);
+       background.green = GREEN16_FROM_ULONG (background.pixel);
+       background.blue = BLUE16_FROM_ULONG (background.pixel);
+     }
+ 
+   /* If IMG->spec specifies a file name, create a non-file spec from it.  */
+   file_name = image_spec_value (img->spec, QCfile, NULL);
+   if (STRINGP (file_name))
+     {
+       Lisp_Object file;
+       unsigned char *contents;
+       ptrdiff_t size;
+       struct gcpro gcpro1;
+ 
+       file = x_find_image_file (file_name);
+       GCPRO1 (file);
+       if (!STRINGP (file))
+ 	{
+ 	  image_error ("Cannot find image file `%s'", file_name, Qnil);
+ 	  UNGCPRO;
+ 	  return 0;
+ 	}
+ 
+       /* Read the entire file into memory.  */
+       contents = slurp_file (SSDATA (file), &size);
+       if (contents == NULL)
+ 	{
+ 	  image_error ("Error loading SVG image `%s'", img->spec, Qnil);
+ 	  UNGCPRO;
+ 	  return 0;
+ 	}
+       /* If the file was slurped into memory properly, parse it.  */
+       success_p = mac_svg_load_image (f, img, contents, size, &background,
+ 				      check_image_size, image_error);
+       xfree (contents);
+       UNGCPRO;
+     }
+   /* Else its not a file, its a lisp object.  Load the image from a
+      lisp object rather than a file.  */
+   else
+     {
+       Lisp_Object data;
+ 
+       data = image_spec_value (img->spec, QCdata, NULL);
+       success_p = mac_svg_load_image (f, img, SDATA (data), SBYTES (data),
+ 				      &background,
+ 				      check_image_size, image_error);
+     }
+ 
+   if (success_p)
+     {
+       /* Maybe fill in the background field while we have ximg handy. */
+       if (NILP (image_spec_value (img->spec, QCbackground, NULL)))
+ 	IMAGE_BACKGROUND (img, f, img->pixmap);
+     }
+ 
+   return success_p;
+ }
+ #endif /* defined (USE_MAC_IMAGE_IO) */
  
! #endif	/* defined (HAVE_RSVG) || defined (USE_MAC_IMAGE_IO) */
  
  
  
*************** of `dynamic-library-alist', which see). 
*** 8754,8795 ****
    if (EQ (type, Qpbm) || EQ (type, Qxbm))
      return Qt;
  
! #if defined (HAVE_XPM) || defined (HAVE_NS)
    if (EQ (type, Qxpm))
      return CHECK_LIB_AVAILABLE (&xpm_type, init_xpm_functions, libraries);
  #endif
  
! #if defined (HAVE_JPEG) || defined (HAVE_NS)
    if (EQ (type, Qjpeg))
      return CHECK_LIB_AVAILABLE (&jpeg_type, init_jpeg_functions, libraries);
  #endif
  
! #if defined (HAVE_TIFF) || defined (HAVE_NS)
    if (EQ (type, Qtiff))
      return CHECK_LIB_AVAILABLE (&tiff_type, init_tiff_functions, libraries);
  #endif
  
! #if defined (HAVE_GIF) || defined (HAVE_NS)
    if (EQ (type, Qgif))
      return CHECK_LIB_AVAILABLE (&gif_type, init_gif_functions, libraries);
  #endif
  
! #if defined (HAVE_PNG) || defined (HAVE_NS)
    if (EQ (type, Qpng))
      return CHECK_LIB_AVAILABLE (&png_type, init_png_functions, libraries);
  #endif
  
! #if defined (HAVE_RSVG)
!   if (EQ (type, Qsvg))
      return CHECK_LIB_AVAILABLE (&svg_type, init_svg_functions, libraries);
  #endif
  
! #if defined (HAVE_IMAGEMAGICK)
    if (EQ (type, Qimagemagick))
      return CHECK_LIB_AVAILABLE (&imagemagick_type, init_imagemagick_functions,
                                  libraries);
  #endif
  
  #ifdef HAVE_GHOSTSCRIPT
    if (EQ (type, Qpostscript))
      return CHECK_LIB_AVAILABLE (&gs_type, init_gs_functions, libraries);
--- 10338,10389 ----
    if (EQ (type, Qpbm) || EQ (type, Qxbm))
      return Qt;
  
! #if defined (HAVE_XPM) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    if (EQ (type, Qxpm))
      return CHECK_LIB_AVAILABLE (&xpm_type, init_xpm_functions, libraries);
  #endif
  
! #if defined (HAVE_JPEG) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    if (EQ (type, Qjpeg))
      return CHECK_LIB_AVAILABLE (&jpeg_type, init_jpeg_functions, libraries);
  #endif
  
! #if defined (HAVE_TIFF) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    if (EQ (type, Qtiff))
      return CHECK_LIB_AVAILABLE (&tiff_type, init_tiff_functions, libraries);
  #endif
  
! #if defined (HAVE_GIF) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    if (EQ (type, Qgif))
      return CHECK_LIB_AVAILABLE (&gif_type, init_gif_functions, libraries);
  #endif
  
! #if defined (HAVE_PNG) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    if (EQ (type, Qpng))
      return CHECK_LIB_AVAILABLE (&png_type, init_png_functions, libraries);
  #endif
  
! #if defined (HAVE_RSVG) || defined (USE_MAC_IMAGE_IO)
!   if (EQ (type, Qsvg)
! #if !defined (HAVE_RSVG)
!       && mac_webkit_supports_svg_p ()
! #endif
!       )
      return CHECK_LIB_AVAILABLE (&svg_type, init_svg_functions, libraries);
  #endif
  
! #if defined (HAVE_IMAGEMAGICK) || defined (USE_MAC_IMAGE_IO)
    if (EQ (type, Qimagemagick))
      return CHECK_LIB_AVAILABLE (&imagemagick_type, init_imagemagick_functions,
                                  libraries);
  #endif
  
+ #ifdef USE_MAC_IMAGE_IO
+   if (EQ (type, Qimage_io))
+     return CHECK_LIB_AVAILABLE (&image_io_type, init_image_io_functions,
+                                 libraries);
+ #endif
+ 
  #ifdef HAVE_GHOSTSCRIPT
    if (EQ (type, Qpostscript))
      return CHECK_LIB_AVAILABLE (&gs_type, init_gs_functions, libraries);
*************** non-numeric, there is no explicit limit 
*** 8880,8916 ****
  	);
  #endif
  
! #if defined (HAVE_XPM) || defined (HAVE_NS)
    DEFSYM (Qxpm, "xpm");
    ADD_IMAGE_TYPE (Qxpm);
  #endif
  
! #if defined (HAVE_JPEG) || defined (HAVE_NS)
    DEFSYM (Qjpeg, "jpeg");
    ADD_IMAGE_TYPE (Qjpeg);
  #endif
  
! #if defined (HAVE_TIFF) || defined (HAVE_NS)
    DEFSYM (Qtiff, "tiff");
    ADD_IMAGE_TYPE (Qtiff);
  #endif
  
! #if defined (HAVE_GIF) || defined (HAVE_NS)
    DEFSYM (Qgif, "gif");
    ADD_IMAGE_TYPE (Qgif);
  #endif
  
! #if defined (HAVE_PNG) || defined (HAVE_NS)
    DEFSYM (Qpng, "png");
    ADD_IMAGE_TYPE (Qpng);
  #endif
  
! #if defined (HAVE_IMAGEMAGICK)
    DEFSYM (Qimagemagick, "imagemagick");
    ADD_IMAGE_TYPE (Qimagemagick);
  #endif
  
! #if defined (HAVE_RSVG)
    DEFSYM (Qsvg, "svg");
    ADD_IMAGE_TYPE (Qsvg);
  #ifdef HAVE_NTGUI
--- 10474,10515 ----
  	);
  #endif
  
! #if defined (HAVE_XPM) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    DEFSYM (Qxpm, "xpm");
    ADD_IMAGE_TYPE (Qxpm);
  #endif
  
! #if defined (HAVE_JPEG) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    DEFSYM (Qjpeg, "jpeg");
    ADD_IMAGE_TYPE (Qjpeg);
  #endif
  
! #if defined (HAVE_TIFF) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    DEFSYM (Qtiff, "tiff");
    ADD_IMAGE_TYPE (Qtiff);
  #endif
  
! #if defined (HAVE_GIF) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    DEFSYM (Qgif, "gif");
    ADD_IMAGE_TYPE (Qgif);
  #endif
  
! #if defined (HAVE_PNG) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    DEFSYM (Qpng, "png");
    ADD_IMAGE_TYPE (Qpng);
  #endif
  
! #if defined (HAVE_IMAGEMAGICK) || defined (USE_MAC_IMAGE_IO)
    DEFSYM (Qimagemagick, "imagemagick");
    ADD_IMAGE_TYPE (Qimagemagick);
  #endif
  
! #ifdef USE_MAC_IMAGE_IO
!   DEFSYM (Qimage_io, "image-io");
!   ADD_IMAGE_TYPE (Qimage_io);
! #endif
! 
! #if defined (HAVE_RSVG) || defined (USE_MAC_IMAGE_IO)
    DEFSYM (Qsvg, "svg");
    ADD_IMAGE_TYPE (Qsvg);
  #ifdef HAVE_NTGUI
*************** non-numeric, there is no explicit limit 
*** 8919,8930 ****
    DEFSYM (Qglib, "glib");
    DEFSYM (Qgobject, "gobject");
  #endif /* HAVE_NTGUI  */
! #endif /* HAVE_RSVG  */
  
    defsubr (&Sinit_image_library);
! #ifdef HAVE_IMAGEMAGICK
    defsubr (&Simagemagick_types);
  #endif
    defsubr (&Sclear_image_cache);
    defsubr (&Simage_flush);
    defsubr (&Simage_size);
--- 10518,10532 ----
    DEFSYM (Qglib, "glib");
    DEFSYM (Qgobject, "gobject");
  #endif /* HAVE_NTGUI  */
! #endif /* HAVE_RSVG || USE_MAC_IMAGE_IO */
  
    defsubr (&Sinit_image_library);
! #if defined (HAVE_IMAGEMAGICK) || defined (USE_MAC_IMAGE_IO)
    defsubr (&Simagemagick_types);
  #endif
+ #ifdef USE_MAC_IMAGE_IO
+   defsubr (&Simage_io_types);
+ #endif
    defsubr (&Sclear_image_cache);
    defsubr (&Simage_flush);
    defsubr (&Simage_size);

=== modified file 'src/keyboard.c'
*** src/keyboard.c	2012-04-04 07:54:02 +0000
--- src/keyboard.c	2012-04-28 00:30:28 +0000
*************** along with GNU Emacs.  If not, see <http
*** 69,74 ****
--- 69,78 ----
  #include "w32term.h"
  #endif /* HAVE_NTGUI */
  
+ #ifdef HAVE_MACGUI
+ #include "macterm.h"
+ #endif
+ 
  #ifdef HAVE_NS
  #include "nsterm.h"
  #endif
*************** static Lisp_Object Qmouse_fixup_help_mes
*** 323,333 ****
  /* Symbols to denote kinds of events.  */
  static Lisp_Object Qfunction_key;
  Lisp_Object Qmouse_click;
! #if defined (WINDOWSNT)
  Lisp_Object Qlanguage_change;
  #endif
  static Lisp_Object Qdrag_n_drop;
  static Lisp_Object Qsave_session;
  #ifdef HAVE_DBUS
  static Lisp_Object Qdbus_event;
  #endif
--- 327,340 ----
  /* Symbols to denote kinds of events.  */
  static Lisp_Object Qfunction_key;
  Lisp_Object Qmouse_click;
! #if defined (WINDOWSNT) || defined (HAVE_MACGUI)
  Lisp_Object Qlanguage_change;
  #endif
  static Lisp_Object Qdrag_n_drop;
  static Lisp_Object Qsave_session;
+ #ifdef HAVE_MACGUI
+ Lisp_Object Qmac_apple_event;
+ #endif
  #ifdef HAVE_DBUS
  static Lisp_Object Qdbus_event;
  #endif
*************** command_loop (void)
*** 1129,1135 ****
--- 1136,1155 ----
    else
      while (1)
        {
+ #if MAC_USE_AUTORELEASE_LOOP
+ 	mac_autorelease_loop (^{
+ 	    internal_catch (Qtop_level, top_level_1, Qnil);
+ 	    return Qnil;
+ 	  });
+ #else
+ #ifdef HAVE_MACGUI
+ 	void *pool = mac_alloc_autorelease_pool ();
+ #endif
  	internal_catch (Qtop_level, top_level_1, Qnil);
+ #ifdef HAVE_MACGUI
+ 	mac_release_autorelease_pool (pool);
+ #endif
+ #endif
  #if 0 /* This shouldn't be necessary anymore.  --lorentey  */
          /* Reset single_kboard in case top-level set it while
             evaluating an -f option, or we are stuck there for some
*************** command_loop (void)
*** 1154,1164 ****
  Lisp_Object
  command_loop_2 (Lisp_Object ignore)
  {
    register Lisp_Object val;
  
    do
!     val = internal_condition_case (command_loop_1, Qerror, cmd_error);
    while (!NILP (val));
  
    return Qnil;
  }
--- 1174,1198 ----
  Lisp_Object
  command_loop_2 (Lisp_Object ignore)
  {
+ #if MAC_USE_AUTORELEASE_LOOP
+   mac_autorelease_loop (^{
+       return internal_condition_case (command_loop_1, Qerror, cmd_error);
+     });
+ #else
    register Lisp_Object val;
  
    do
!     {
! #ifdef HAVE_MACGUI
!       void *pool = mac_alloc_autorelease_pool ();
! #endif
!       val = internal_condition_case (command_loop_1, Qerror, cmd_error);
! #ifdef HAVE_MACGUI
!       mac_release_autorelease_pool (pool);
! #endif
!     }
    while (!NILP (val));
+ #endif
  
    return Qnil;
  }
*************** EXFUN (Fwindow_system, 1);
*** 1328,1342 ****
  Lisp_Object
  command_loop_1 (void)
  {
!   Lisp_Object cmd;
!   Lisp_Object keybuf[30];
!   int i;
!   int prev_modiff = 0;
!   struct buffer *prev_buffer = NULL;
  #if 0 /* This shouldn't be necessary anymore.  --lorentey  */
    int was_locked = single_kboard;
  #endif
!   int already_adjusted = 0;
  
    KVAR (current_kboard, Vprefix_arg) = Qnil;
    KVAR (current_kboard, Vlast_prefix_arg) = Qnil;
--- 1362,1379 ----
  Lisp_Object
  command_loop_1 (void)
  {
! #if MAC_USE_AUTORELEASE_LOOP
! #define BLOCK __block
! #else
! #define BLOCK
! #endif
!   BLOCK int prev_modiff = 0;
!   BLOCK struct buffer *prev_buffer = NULL;
  #if 0 /* This shouldn't be necessary anymore.  --lorentey  */
    int was_locked = single_kboard;
  #endif
!   BLOCK int already_adjusted = 0;
! #undef BLOCK
  
    KVAR (current_kboard, Vprefix_arg) = Qnil;
    KVAR (current_kboard, Vlast_prefix_arg) = Qnil;
*************** command_loop_1 (void)
*** 1376,1383 ****
--- 1413,1431 ----
    if (!CONSP (last_command_event))
      KVAR (current_kboard, Vlast_repeatable_command) = real_this_command;
  
+ #if MAC_USE_AUTORELEASE_LOOP
+   mac_autorelease_loop (^
+ #else
    while (1)
+ #endif
      {
+ #if defined (HAVE_MACGUI) && !MAC_USE_AUTORELEASE_LOOP
+       void *pool = mac_alloc_autorelease_pool ();
+ #endif
+       Lisp_Object cmd;
+       Lisp_Object keybuf[30];
+       int i;
+ 
        if (! FRAME_LIVE_P (XFRAME (selected_frame)))
  	Fkill_emacs (Qnil);
  
*************** command_loop_1 (void)
*** 1704,1710 ****
--- 1752,1768 ----
        if (!was_locked)
          any_kboard_state ();
  #endif
+ #if defined (HAVE_MACGUI) && !MAC_USE_AUTORELEASE_LOOP
+       mac_release_autorelease_pool (pool);
+ #endif
+ #if MAC_USE_AUTORELEASE_LOOP
+       return Qt;
+ #endif
      }
+ #if MAC_USE_AUTORELEASE_LOOP
+     );
+   return Qnil;
+ #endif
  }
  
  /* Adjust point to a boundary of a region that has such a property
*************** kbd_buffer_get_event (KBOARD **kbp,
*** 3923,3929 ****
          }
  #endif
  
! #if defined (HAVE_X11) || defined (HAVE_NTGUI) \
      || defined (HAVE_NS)
        else if (event->kind == DELETE_WINDOW_EVENT)
  	{
--- 3981,3987 ----
          }
  #endif
  
! #if defined (HAVE_X11) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI) \
      || defined (HAVE_NS)
        else if (event->kind == DELETE_WINDOW_EVENT)
  	{
*************** kbd_buffer_get_event (KBOARD **kbp,
*** 3933,3939 ****
  	  kbd_fetch_ptr = event + 1;
  	}
  #endif
! #if defined (HAVE_X11) || defined (HAVE_NTGUI) \
      || defined (HAVE_NS)
        else if (event->kind == ICONIFY_EVENT)
  	{
--- 3991,3997 ----
  	  kbd_fetch_ptr = event + 1;
  	}
  #endif
! #if defined (HAVE_X11) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI) \
      || defined (HAVE_NS)
        else if (event->kind == ICONIFY_EVENT)
  	{
*************** kbd_buffer_get_event (KBOARD **kbp,
*** 3956,3962 ****
  	  XSETBUFFER (obj, current_buffer);
  	  kbd_fetch_ptr = event + 1;
  	}
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) \
      || defined (HAVE_NS) || defined (USE_GTK)
        else if (event->kind == MENU_BAR_ACTIVATE_EVENT)
  	{
--- 4014,4020 ----
  	  XSETBUFFER (obj, current_buffer);
  	  kbd_fetch_ptr = event + 1;
  	}
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI) \
      || defined (HAVE_NS) || defined (USE_GTK)
        else if (event->kind == MENU_BAR_ACTIVATE_EVENT)
  	{
*************** kbd_buffer_get_event (KBOARD **kbp,
*** 3966,3976 ****
  	    x_activate_menubar (XFRAME (event->frame_or_window));
  	}
  #endif
! #if defined (WINDOWSNT)
        else if (event->kind == LANGUAGE_CHANGE_EVENT)
  	{
  	  /* Make an event (language-change (FRAME CHARSET LCID)).  */
  	  obj = Fcons (event->frame_or_window, Qnil);
  	  obj = Fcons (Qlanguage_change, Fcons (obj, Qnil));
  	  kbd_fetch_ptr = event + 1;
  	}
--- 4024,4039 ----
  	    x_activate_menubar (XFRAME (event->frame_or_window));
  	}
  #endif
! #if defined (WINDOWSNT) || defined (HAVE_MACGUI)
        else if (event->kind == LANGUAGE_CHANGE_EVENT)
  	{
+ #ifdef HAVE_MACGUI
+ 	  /* Make an event (language-change (KEY_SCRIPT)).  */
+ 	  obj = Fcons (make_number (event->code), Qnil);
+ #else
  	  /* Make an event (language-change (FRAME CHARSET LCID)).  */
  	  obj = Fcons (event->frame_or_window, Qnil);
+ #endif
  	  obj = Fcons (Qlanguage_change, Fcons (obj, Qnil));
  	  kbd_fetch_ptr = event + 1;
  	}
*************** kbd_buffer_get_event (KBOARD **kbp,
*** 4066,4073 ****
  	    {
  	      obj = make_lispy_event (event);
  
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) \
!     || defined (HAVE_NS) || defined (USE_GTK)
  	      /* If this was a menu selection, then set the flag to inhibit
  		 writing to last_nonmenu_event.  Don't do this if the event
  		 we're returning is (menu-bar), though; that indicates the
--- 4129,4136 ----
  	    {
  	      obj = make_lispy_event (event);
  
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI) \
!     || defined(HAVE_NS) || defined (USE_GTK)
  	      /* If this was a menu selection, then set the flag to inhibit
  		 writing to last_nonmenu_event.  Don't do this if the event
  		 we're returning is (menu-bar), though; that indicates the
*************** static Lisp_Object Vlispy_mouse_stem;
*** 5095,5100 ****
--- 5158,5167 ----
  static const char *const lispy_wheel_names[] =
  {
    "wheel-up", "wheel-down", "wheel-left", "wheel-right"
+ #ifdef HAVE_MACGUI
+   , "swipe-up", "swipe-down", "swipe-left", "swipe-right",
+   "magnify-up", "magnify-down", "rotate-left", "rotate-right"
+ #endif
  };
  
  /* drag-n-drop events are generated when a set of selected files are
*************** make_lispy_event (struct input_event *ev
*** 5784,5789 ****
--- 5851,5870 ----
  
            if (event->kind == HORIZ_WHEEL_EVENT)
              symbol_num += 2;
+ #ifdef HAVE_MACGUI
+           if (event->modifiers & drag_modifier)
+ 	    {
+ 	      /* Emit a swipe event.  */
+ 	      event->modifiers &= ~drag_modifier;
+ 	      symbol_num += 4;
+ 	    }
+           else if (event->modifiers & click_modifier)
+ 	    {
+ 	      /* Emit a maginify/rotate event.  */
+ 	      event->modifiers &= ~click_modifier;
+ 	      symbol_num += 8;
+ 	    }
+ #endif
  
  	  is_double = (last_mouse_button == - (1 + symbol_num)
  		       && (eabs (XINT (event->x) - last_mouse_x) <= fuzz)
*************** make_lispy_event (struct input_event *ev
*** 5822,5832 ****
  				      ASIZE (wheel_syms));
  	}
  
! 	if (event->modifiers & (double_modifier | triple_modifier))
  	  return Fcons (head,
  			Fcons (position,
  			       Fcons (make_number (double_click_count),
  				      Qnil)));
  	else
  	  return Fcons (head,
  			Fcons (position,
--- 5903,5936 ----
  				      ASIZE (wheel_syms));
  	}
  
! 	if (event->modifiers & (double_modifier | triple_modifier)
! #ifdef HAVE_MACGUI
! 	    || !NILP (event->arg)
! #endif
! 	    )
! #ifdef HAVE_MACGUI
! 	  {
! 	    if (mac_ignore_momentum_wheel_events)
! 	      {
! 		Lisp_Object phases =
! 		  CAR_SAFE (CDR_SAFE (CDR_SAFE (CDR_SAFE (event->arg))));
! 		Lisp_Object momentum_phase = CAR_SAFE (CDR_SAFE (phases));
! 
! 		if (!NILP (momentum_phase)
! 		    && !EQ (momentum_phase, make_number (0)))
! 		  return Qnil;
! 	      }
! #endif
  	  return Fcons (head,
  			Fcons (position,
  			       Fcons (make_number (double_click_count),
+ #ifdef HAVE_MACGUI
+ 				      !NILP (event->arg) ? Fcons (event->arg, Qnil) :
+ #endif
  				      Qnil)));
+ #ifdef HAVE_MACGUI
+           }
+ #endif
  	else
  	  return Fcons (head,
  			Fcons (position,
*************** make_lispy_event (struct input_event *ev
*** 5915,5922 ****
        }
  #endif /* HAVE_MOUSE */
  
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) \
!     || defined (HAVE_NS) || defined (USE_GTK)
      case MENU_BAR_EVENT:
        if (EQ (event->arg, event->frame_or_window))
  	/* This is the prefix key.  We translate this to
--- 6019,6026 ----
        }
  #endif /* HAVE_MOUSE */
  
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI) \
!     || defined(HAVE_NS) || defined (USE_GTK)
      case MENU_BAR_EVENT:
        if (EQ (event->arg, event->frame_or_window))
  	/* This is the prefix key.  We translate this to
*************** make_lispy_event (struct input_event *ev
*** 5954,5959 ****
--- 6058,6076 ----
      case SAVE_SESSION_EVENT:
        return Qsave_session;
  
+ #ifdef HAVE_MACGUI
+     case MAC_APPLE_EVENT:
+       {
+ 	Lisp_Object spec[2];
+ 
+ 	spec[0] = event->x;
+ 	spec[1] = event->y;
+ 	return Fcons (Qmac_apple_event,
+ 		      Fcons (Fvector (2, spec),
+ 			     Fcons (event->arg, Qnil)));
+       }
+ #endif
+ 
  #ifdef HAVE_DBUS
      case DBUS_EVENT:
        {
*************** struct user_signal_info
*** 7265,7270 ****
--- 7382,7389 ----
  /* List of user signals.  */
  static struct user_signal_info *user_signals = NULL;
  
+ void (*handle_user_signal_hook) (int);
+ 
  void
  add_user_signal (int sig, const char *name)
  {
*************** handle_user_signal (int sig)
*** 7314,7319 ****
--- 7433,7440 ----
            }
  
  	p->npending++;
+ 	if (handle_user_signal_hook)
+ 	  (*handle_user_signal_hook) (sig);
  #ifdef SIGIO
  	if (interrupt_input)
  	  kill (getpid (), SIGIO);
*************** parse_tool_bar_item (Lisp_Object key, Li
*** 8220,8226 ****
        if (menu_separator_name_p (SSDATA (caption)))
  	{
  	  PROP (TOOL_BAR_ITEM_TYPE) = Qt;
! #if !defined (USE_GTK) && !defined (HAVE_NS)
  	  /* If we use build_desired_tool_bar_string to render the
  	     tool bar, the separator is rendered as an image.  */
  	  PROP (TOOL_BAR_ITEM_IMAGES)
--- 8341,8347 ----
        if (menu_separator_name_p (SSDATA (caption)))
  	{
  	  PROP (TOOL_BAR_ITEM_TYPE) = Qt;
! #if !defined (USE_GTK) && !defined (HAVE_MACGUI) && !defined (HAVE_NS)
  	  /* If we use build_desired_tool_bar_string to render the
  	     tool bar, the separator is rendered as an image.  */
  	  PROP (TOOL_BAR_ITEM_IMAGES)
*************** See also `current-input-mode'.  */)
*** 11100,11106 ****
    int new_interrupt_input;
  #ifdef SIGIO
  /* Note SIGIO has been undef'd if FIONREAD is missing.  */
! #ifdef HAVE_X_WINDOWS
    if (x_display_list != NULL)
      {
        /* When using X, don't give the user a real choice,
--- 11221,11227 ----
    int new_interrupt_input;
  #ifdef SIGIO
  /* Note SIGIO has been undef'd if FIONREAD is missing.  */
! #if defined (HAVE_X_WINDOWS)
    if (x_display_list != NULL)
      {
        /* When using X, don't give the user a real choice,
*************** init_keyboard (void)
*** 11531,11538 ****
  
  #ifdef POLL_FOR_INPUT
    poll_timer = NULL;
!   poll_suppress_count = 1;
!   start_polling ();
  #endif
  }
  
--- 11652,11662 ----
  
  #ifdef POLL_FOR_INPUT
    poll_timer = NULL;
!   if (!interrupt_input)
!     {
!       poll_suppress_count = 1;
!       start_polling ();
!     }
  #endif
  }
  
*************** syms_of_keyboard (void)
*** 11599,11608 ****
    DEFSYM (Qconfig_changed_event, "config-changed-event");
    DEFSYM (Qmenu_enable, "menu-enable");
  
! #if defined (WINDOWSNT)
    DEFSYM (Qlanguage_change, "language-change");
  #endif
  
  #ifdef HAVE_DBUS
    DEFSYM (Qdbus_event, "dbus-event");
  #endif
--- 11723,11737 ----
    DEFSYM (Qconfig_changed_event, "config-changed-event");
    DEFSYM (Qmenu_enable, "menu-enable");
  
! #if defined (WINDOWSNT) || defined (HAVE_MACGUI)
    DEFSYM (Qlanguage_change, "language-change");
  #endif
  
+ #ifdef HAVE_MACGUI
+   Qmac_apple_event = intern ("mac-apple-event");
+   staticpro (&Qmac_apple_event);
+ #endif
+ 
  #ifdef HAVE_DBUS
    DEFSYM (Qdbus_event, "dbus-event");
  #endif

=== modified file 'src/keyboard.h'
*** src/keyboard.h	2012-01-19 07:21:25 +0000
--- src/keyboard.h	2012-02-28 03:34:38 +0000
*************** extern Lisp_Object unuse_menu_items (Lis
*** 306,312 ****
     confined to an extended version of this with sections of code below
     using it unconditionally.  */
  #ifndef HAVE_NTGUI
! #if defined (USE_GTK) || defined (HAVE_NS)
  # define ENCODE_MENU_STRING(str) ENCODE_UTF_8 (str)
  #elif defined HAVE_X_I18N
  #define ENCODE_MENU_STRING(str) ENCODE_SYSTEM (str)
--- 306,312 ----
     confined to an extended version of this with sections of code below
     using it unconditionally.  */
  #ifndef HAVE_NTGUI
! #if defined (USE_GTK) || defined (HAVE_MACGUI) || defined (HAVE_NS)
  # define ENCODE_MENU_STRING(str) ENCODE_UTF_8 (str)
  #elif defined HAVE_X_I18N
  #define ENCODE_MENU_STRING(str) ENCODE_SYSTEM (str)
*************** extern Lisp_Object Qhelp_echo;
*** 421,426 ****
--- 421,428 ----
  /* Symbols to use for non-text mouse positions.  */
  extern Lisp_Object Qmode_line, Qvertical_line, Qheader_line;
  
+ extern void (*handle_user_signal_hook) (int);
+ 
  /* True while doing kbd input.  */
  extern int waiting_for_input;
  

=== modified file 'src/lisp.h'
*** src/lisp.h	2012-05-23 17:32:28 +0000
--- src/lisp.h	2012-06-01 10:57:00 +0000
*************** enum pvec_type
*** 475,480 ****
--- 475,481 ----
       (var) = (type) | (intptr_t) (ptr))
  
  #define XPNTR(a) ((intptr_t) ((a) & ~TYPEMASK))
+ #define XUNTAG(a, type) ((uintptr_t) (a) - (type))
  
  #else  /* not USE_LSB_TAG */
  
*************** enum pvec_type
*** 517,522 ****
--- 518,524 ----
  #else
  #define XPNTR(a) ((uintptr_t) ((a) & VALMASK))
  #endif
+ #define XUNTAG(a, type) XPNTR (a)
  
  #endif /* not USE_LSB_TAG */
  
*************** extern Lisp_Object make_number (EMACS_IN
*** 607,621 ****
  
  /* Extract a value or address from a Lisp_Object.  */
  
! #define XCONS(a) (eassert (CONSP (a)), (struct Lisp_Cons *) XPNTR (a))
! #define XVECTOR(a) (eassert (VECTORLIKEP (a)), (struct Lisp_Vector *) XPNTR (a))
! #define XSTRING(a) (eassert (STRINGP (a)), (struct Lisp_String *) XPNTR (a))
! #define XSYMBOL(a) (eassert (SYMBOLP (a)), (struct Lisp_Symbol *) XPNTR (a))
! #define XFLOAT(a) (eassert (FLOATP (a)), (struct Lisp_Float *) XPNTR (a))
  
  /* Misc types.  */
  
! #define XMISC(a)   ((union Lisp_Misc *) XPNTR (a))
  #define XMISCANY(a)	(eassert (MISCP (a)), &(XMISC (a)->u_any))
  #define XMISCTYPE(a)   (XMISCANY (a)->type)
  #define XMARKER(a)	(eassert (MARKERP (a)), &(XMISC (a)->u_marker))
--- 609,628 ----
  
  /* Extract a value or address from a Lisp_Object.  */
  
! #define XCONS(a) (eassert (CONSP(a)), \
! 		  (struct Lisp_Cons *) XUNTAG (a, Lisp_Cons))
! #define XVECTOR(a) (eassert (VECTORLIKEP(a)), \
! 		    (struct Lisp_Vector *) XUNTAG (a, Lisp_Vectorlike))
! #define XSTRING(a) (eassert (STRINGP(a)), \
! 		    (struct Lisp_String *) XUNTAG (a, Lisp_String))
! #define XSYMBOL(a) (eassert (SYMBOLP(a)), \
! 		    (struct Lisp_Symbol *) XUNTAG (a, Lisp_Symbol))
! #define XFLOAT(a) (eassert (FLOATP(a)), \
! 		   (struct Lisp_Float *) XUNTAG (a, Lisp_Float))
  
  /* Misc types.  */
  
! #define XMISC(a)   ((union Lisp_Misc *) XUNTAG (a, Lisp_Misc))
  #define XMISCANY(a)	(eassert (MISCP (a)), &(XMISC (a)->u_any))
  #define XMISCTYPE(a)   (XMISCANY (a)->type)
  #define XMARKER(a)	(eassert (MARKERP (a)), &(XMISC (a)->u_marker))
*************** extern Lisp_Object make_number (EMACS_IN
*** 635,648 ****
  
  /* Pseudovector types.  */
  
! #define XPROCESS(a) (eassert (PROCESSP (a)), (struct Lisp_Process *) XPNTR (a))
! #define XWINDOW(a) (eassert (WINDOWP (a)), (struct window *) XPNTR (a))
! #define XTERMINAL(a) (eassert (TERMINALP (a)), (struct terminal *) XPNTR (a))
! #define XSUBR(a) (eassert (SUBRP (a)), (struct Lisp_Subr *) XPNTR (a))
! #define XBUFFER(a) (eassert (BUFFERP (a)), (struct buffer *) XPNTR (a))
! #define XCHAR_TABLE(a) (eassert (CHAR_TABLE_P (a)), (struct Lisp_Char_Table *) XPNTR (a))
! #define XSUB_CHAR_TABLE(a) (eassert (SUB_CHAR_TABLE_P (a)), (struct Lisp_Sub_Char_Table *) XPNTR (a))
! #define XBOOL_VECTOR(a) (eassert (BOOL_VECTOR_P (a)), (struct Lisp_Bool_Vector *) XPNTR (a))
  
  /* Construct a Lisp_Object from a value or address.  */
  
--- 642,663 ----
  
  /* Pseudovector types.  */
  
! #define XPROCESS(a) (eassert (PROCESSP(a)), \
! 		     (struct Lisp_Process *) XUNTAG (a, Lisp_Vectorlike))
! #define XWINDOW(a) (eassert (WINDOWP(a)), \
! 		    (struct window *) XUNTAG (a, Lisp_Vectorlike))
! #define XTERMINAL(a) (eassert (TERMINALP(a)), \
! 		      (struct terminal *) XUNTAG (a, Lisp_Vectorlike))
! #define XSUBR(a) (eassert (SUBRP(a)), \
! 		  (struct Lisp_Subr *) XUNTAG (a, Lisp_Vectorlike))
! #define XBUFFER(a) (eassert (BUFFERP(a)), \
! 		    (struct buffer *) XUNTAG (a, Lisp_Vectorlike))
! #define XCHAR_TABLE(a) (eassert (CHAR_TABLE_P (a)), \
! 			(struct Lisp_Char_Table *) XUNTAG (a, Lisp_Vectorlike))
! #define XSUB_CHAR_TABLE(a) (eassert (SUB_CHAR_TABLE_P (a)), \
! 			    (struct Lisp_Sub_Char_Table *) XUNTAG (a, Lisp_Vectorlike))
! #define XBOOL_VECTOR(a) (eassert (BOOL_VECTOR_P (a)), \
! 			 (struct Lisp_Bool_Vector *) XUNTAG (a, Lisp_Vectorlike))
  
  /* Construct a Lisp_Object from a value or address.  */
  
*************** extern Lisp_Object make_number (EMACS_IN
*** 669,675 ****
  /* The cast to struct vectorlike_header * avoids aliasing issues.  */
  #define XSETPSEUDOVECTOR(a, b, code) \
    XSETTYPED_PSEUDOVECTOR(a, b,       \
! 			 ((struct vectorlike_header *) XPNTR (a))->size, \
  			 code)
  #define XSETTYPED_PSEUDOVECTOR(a, b, size, code)			\
    (XSETVECTOR (a, b),							\
--- 684,690 ----
  /* The cast to struct vectorlike_header * avoids aliasing issues.  */
  #define XSETPSEUDOVECTOR(a, b, code) \
    XSETTYPED_PSEUDOVECTOR(a, b,       \
! 			 ((struct vectorlike_header *) XUNTAG (a, Lisp_Vectorlike))->size, \
  			 code)
  #define XSETTYPED_PSEUDOVECTOR(a, b, size, code)			\
    (XSETVECTOR (a, b),							\
*************** extern EMACS_INT string_bytes (struct Li
*** 837,850 ****
  
  /* Mark STR as a unibyte string.  */
  #define STRING_SET_UNIBYTE(STR)  \
!   do { if (EQ (STR, empty_multibyte_string))  \
        (STR) = empty_unibyte_string;  \
      else XSTRING (STR)->size_byte = -1; } while (0)
  
  /* Mark STR as a multibyte string.  Assure that STR contains only
     ASCII characters in advance.  */
  #define STRING_SET_MULTIBYTE(STR)  \
!   do { if (EQ (STR, empty_unibyte_string))  \
        (STR) = empty_multibyte_string;  \
      else XSTRING (STR)->size_byte = XSTRING (STR)->size; } while (0)
  
--- 852,865 ----
  
  /* Mark STR as a unibyte string.  */
  #define STRING_SET_UNIBYTE(STR)  \
!   do { if (XSTRING (STR)->size == 0)  \
        (STR) = empty_unibyte_string;  \
      else XSTRING (STR)->size_byte = -1; } while (0)
  
  /* Mark STR as a multibyte string.  Assure that STR contains only
     ASCII characters in advance.  */
  #define STRING_SET_MULTIBYTE(STR)  \
!   do { if (XSTRING (STR)->size == 0)  \
        (STR) = empty_multibyte_string;  \
      else XSTRING (STR)->size_byte = XSTRING (STR)->size; } while (0)
  
*************** struct Lisp_Hash_Table
*** 1277,1283 ****
  
  
  #define XHASH_TABLE(OBJ) \
!      ((struct Lisp_Hash_Table *) XPNTR (OBJ))
  
  #define XSET_HASH_TABLE(VAR, PTR) \
       (XSETPSEUDOVECTOR (VAR, PTR, PVEC_HASH_TABLE))
--- 1292,1298 ----
  
  
  #define XHASH_TABLE(OBJ) \
!      ((struct Lisp_Hash_Table *) XUNTAG (OBJ, Lisp_Vectorlike))
  
  #define XSET_HASH_TABLE(VAR, PTR) \
       (XSETPSEUDOVECTOR (VAR, PTR, PVEC_HASH_TABLE))
*************** typedef struct {
*** 1717,1722 ****
--- 1732,1746 ----
    RANGED_INTEGERP (TYPE_MINIMUM (type), x, TYPE_MAXIMUM (type))
  
  #define INTEGERP(x) (LISP_INT_TAG_P (XTYPE ((x))))
+ #ifdef USE_LSB_TAG    /* Below usually gives shorter instructions.  */
+ #define SYMBOLP(x) (XTYPE (XUNTAG (x, Lisp_Symbol)) == 0)
+ #define MISCP(x) (XTYPE (XUNTAG (x, Lisp_Misc)) == 0)
+ #define VECTORLIKEP(x) (XTYPE (XUNTAG (x, Lisp_Vectorlike)) == 0)
+ #define STRINGP(x) (XTYPE (XUNTAG (x, Lisp_String)) == 0)
+ #define CONSP(x) (XTYPE (XUNTAG (x, Lisp_Cons)) == 0)
+ 
+ #define FLOATP(x) (XTYPE (XUNTAG (x, Lisp_Float)) == 0)
+ #else
  #define SYMBOLP(x) (XTYPE ((x)) == Lisp_Symbol)
  #define MISCP(x) (XTYPE ((x)) == Lisp_Misc)
  #define VECTORLIKEP(x) (XTYPE ((x)) == Lisp_Vectorlike)
*************** typedef struct {
*** 1724,1729 ****
--- 1748,1754 ----
  #define CONSP(x) (XTYPE ((x)) == Lisp_Cons)
  
  #define FLOATP(x) (XTYPE ((x)) == Lisp_Float)
+ #endif
  #define VECTORP(x) (VECTORLIKEP (x) && !(ASIZE (x) & PSEUDOVECTOR_FLAG))
  #define OVERLAYP(x) (MISCP (x) && XMISCTYPE (x) == Lisp_Misc_Overlay)
  #define MARKERP(x) (MISCP (x) && XMISCTYPE (x) == Lisp_Misc_Marker)
*************** typedef struct {
*** 1744,1750 ****
     code is CODE.  */
  #define TYPED_PSEUDOVECTORP(x, t, code)				\
    (VECTORLIKEP (x)						\
!    && (((((struct t *) XPNTR (x))->size				\
  	 & (PSEUDOVECTOR_FLAG | (code))))			\
         == (PSEUDOVECTOR_FLAG | (code))))
  
--- 1769,1775 ----
     code is CODE.  */
  #define TYPED_PSEUDOVECTORP(x, t, code)				\
    (VECTORLIKEP (x)						\
!    && (((((struct t *) XUNTAG (x, Lisp_Vectorlike))->size	\
  	 & (PSEUDOVECTOR_FLAG | (code))))			\
         == (PSEUDOVECTOR_FLAG | (code))))
  
*************** extern Lisp_Object Qleft_margin, Qright_
*** 2722,2727 ****
--- 2747,2755 ----
  extern Lisp_Object Qglyphless_char;
  extern Lisp_Object QCdata, QCfile;
  extern Lisp_Object QCmap;
+ #ifdef HAVE_MACGUI
+ extern Lisp_Object Qrect;
+ #endif
  extern Lisp_Object Qrisky_local_variable;
  extern struct frame *last_glyphless_glyph_frame;
  extern unsigned last_glyphless_glyph_face_id;
*************** extern ptrdiff_t evxprintf (char **, ptr
*** 2901,2906 ****
--- 2929,2937 ----
    ATTRIBUTE_FORMAT_PRINTF (5, 0);
  
  /* Defined in lread.c.  */
+ #ifdef HAVE_MACGUI
+ extern Lisp_Object Qdata, Qsize;
+ #endif
  extern Lisp_Object Qvariable_documentation, Qstandard_input;
  extern Lisp_Object Qbackquote, Qcomma, Qcomma_at, Qcomma_dot, Qfunction;
  EXFUN (Fread, 1);
*************** extern Lisp_Object Qvisible;
*** 3269,3275 ****
  extern void store_frame_param (struct frame *, Lisp_Object, Lisp_Object);
  extern void store_in_alist (Lisp_Object *, Lisp_Object, Lisp_Object);
  extern Lisp_Object do_switch_frame (Lisp_Object, int, int, Lisp_Object);
! #if HAVE_NS
  extern Lisp_Object get_frame_param (struct frame *, Lisp_Object);
  #endif
  extern Lisp_Object frame_buffer_predicate (Lisp_Object);
--- 3300,3306 ----
  extern void store_frame_param (struct frame *, Lisp_Object, Lisp_Object);
  extern void store_in_alist (Lisp_Object *, Lisp_Object, Lisp_Object);
  extern Lisp_Object do_switch_frame (Lisp_Object, int, int, Lisp_Object);
! #if defined (HAVE_MACGUI) || HAVE_NS
  extern Lisp_Object get_frame_param (struct frame *, Lisp_Object);
  #endif
  extern Lisp_Object frame_buffer_predicate (Lisp_Object);
*************** extern char *x_get_keysym_name (int);
*** 3546,3558 ****
  EXFUN (Fmsdos_downcase_filename, 1);
  #endif
  
  #ifdef HAVE_LIBXML2
  /* Defined in xml.c */
  extern void syms_of_xml (void);
  #endif
  
  #ifdef HAVE_MENUS
! /* Defined in (x|w32)fns.c, nsfns.m...  */
  extern int have_menus_p (void);
  #endif
  
--- 3577,3607 ----
  EXFUN (Fmsdos_downcase_filename, 1);
  #endif
  
+ #ifdef HAVE_MACGUI
+ /* Defined in macfns.c */
+ extern void syms_of_macfns (void);
+ 
+ /* Defined in macselect.c */
+ extern void syms_of_macselect (void);
+ 
+ /* Defined in macterm.c */
+ extern void syms_of_macterm (void);
+ 
+ /* Defined in macmenu.c */
+ extern void syms_of_macmenu (void);
+ 
+ /* Defined in mac.c */
+ extern void syms_of_mac (void);
+ extern void init_mac_osx_environment (void);
+ #endif /* HAVE_MACGUI */
+ 
  #ifdef HAVE_LIBXML2
  /* Defined in xml.c */
  extern void syms_of_xml (void);
  #endif
  
  #ifdef HAVE_MENUS
! /* Defined in (x|mac|w32)fns.c, nsfns.m...  */
  extern int have_menus_p (void);
  #endif
  

=== modified file 'src/lisp.mk'
*** src/lisp.mk	2012-01-05 09:46:05 +0000
--- src/lisp.mk	2012-02-28 00:35:53 +0000
*************** lisp = \
*** 149,154 ****
--- 149,155 ----
  	$(lispsource)/dos-vars.elc \
  	$(lispsource)/term/pc-win.elc \
  	$(lispsource)/term/internal.elc \
+ 	$(lispsource)/term/mac-win.elc \
  	$(lispsource)/term/ns-win.elc \
  	$(lispsource)/mwheel.elc \
  	$(lispsource)/emacs-lisp/float-sup.elc \

=== modified file 'src/lread.c'
*** src/lread.c	2012-04-13 18:08:18 +0000
--- src/lread.c	2012-04-28 00:30:28 +0000
*************** along with GNU Emacs.  If not, see <http
*** 62,69 ****
  #endif
  
  /* hash table read constants */
! static Lisp_Object Qhash_table, Qdata;
! static Lisp_Object Qtest, Qsize;
  static Lisp_Object Qweakness;
  static Lisp_Object Qrehash_size;
  static Lisp_Object Qrehash_threshold;
--- 62,73 ----
  #endif
  
  /* hash table read constants */
! static Lisp_Object Qhash_table;
! #ifndef HAVE_MACGUI
! static
! #endif
! Lisp_Object Qdata, Qsize;
! static Lisp_Object Qtest;
  static Lisp_Object Qweakness;
  static Lisp_Object Qrehash_size;
  static Lisp_Object Qrehash_threshold;
*************** init_lread (void)
*** 4298,4308 ****
      }
  #endif  /* CANNOT_DUMP */
  
! #if (!(defined (WINDOWSNT) || (defined (HAVE_NS))))
    /* When Emacs is invoked over network shares on NT, PATH_LOADSEARCH is
       almost never correct, thereby causing a warning to be printed out that
       confuses users.  Since PATH_LOADSEARCH is always overridden by the
!      EMACSLOADPATH environment variable below, disable the warning on NT.  */
  
    /* HAVE_NS also uses EMACSLOADPATH.  */
  
--- 4302,4316 ----
      }
  #endif  /* CANNOT_DUMP */
  
! #if (!(defined (WINDOWSNT) || (defined (HAVE_MACGUI)) || (defined (HAVE_NS))))
    /* When Emacs is invoked over network shares on NT, PATH_LOADSEARCH is
       almost never correct, thereby causing a warning to be printed out that
       confuses users.  Since PATH_LOADSEARCH is always overridden by the
!      EMACSLOADPATH environment variable below, disable the warning on NT.
!      Also, when using the "self-contained" option for the Mac port,
!      the "standard" paths may not exist and would be overridden by
!      EMACSLOADPATH as on NT.  Since this depends on how the executable
!      was build and packaged, turn off the warnings in general */
  
    /* HAVE_NS also uses EMACSLOADPATH.  */
  
*************** init_lread (void)
*** 4330,4336 ****
  	    }
  	}
      }
! #endif /* !(WINDOWSNT || HAVE_NS) */
  
    /* If the EMACSLOADPATH environment variable is set, use its value.
       This doesn't apply if we're dumping.  */
--- 4338,4344 ----
  	    }
  	}
      }
! #endif /* !(WINDOWSNT || HAVE_MACGUI || HAVE_NS) */
  
    /* If the EMACSLOADPATH environment variable is set, use its value.
       This doesn't apply if we're dumping.  */

=== modified file 'src/menu.c'
*** src/menu.c	2012-01-19 07:21:25 +0000
--- src/menu.c	2012-02-28 03:37:05 +0000
*************** extern HMENU current_popup_menu;
*** 56,61 ****
--- 56,67 ----
  
  #endif /* HAVE_NTGUI  */
  
+ #ifdef HAVE_MACGUI
+ #include "macterm.h"
+ 
+ extern Lisp_Object Qmac_apple_event;
+ #endif
+ 
  #include "menu.h"
  
  /* Define HAVE_BOXES if menus can handle radio and toggle buttons.  */
*************** grow_menu_items (void)
*** 186,192 ****
    menu_items = larger_vector (menu_items, menu_items_allocated, Qnil);
  }
  
! #if (defined USE_X_TOOLKIT || defined USE_GTK || defined HAVE_NS \
       || defined HAVE_NTGUI)
  
  /* Begin a submenu.  */
--- 192,198 ----
    menu_items = larger_vector (menu_items, menu_items_allocated, Qnil);
  }
  
! #if (defined USE_X_TOOLKIT || defined USE_GTK || defined HAVE_MACGUI || defined HAVE_NS \
       || defined HAVE_NTGUI)
  
  /* Begin a submenu.  */
*************** push_submenu_end (void)
*** 213,219 ****
    menu_items_submenu_depth--;
  }
  
! #endif /* USE_X_TOOLKIT || USE_GTK || HAVE_NS || defined HAVE_NTGUI */
  
  /* Indicate boundary between left and right.  */
  
--- 219,225 ----
    menu_items_submenu_depth--;
  }
  
! #endif /* USE_X_TOOLKIT || USE_GTK || HAVE_MACGUI || HAVE_NS || defined HAVE_NTGUI */
  
  /* Indicate boundary between left and right.  */
  
*************** single_menu_item (Lisp_Object key, Lisp_
*** 443,449 ****
  		  XVECTOR (item_properties)->contents[ITEM_PROPERTY_SELECTED],
  		  XVECTOR (item_properties)->contents[ITEM_PROPERTY_HELP]);
  
! #if defined (USE_X_TOOLKIT) || defined (USE_GTK) || defined (HAVE_NS) || defined (HAVE_NTGUI)
    /* Display a submenu using the toolkit.  */
    if (! (NILP (map) || NILP (enabled)))
      {
--- 449,455 ----
  		  XVECTOR (item_properties)->contents[ITEM_PROPERTY_SELECTED],
  		  XVECTOR (item_properties)->contents[ITEM_PROPERTY_HELP]);
  
! #if defined (USE_X_TOOLKIT) || defined (USE_GTK) || defined (HAVE_MACGUI) || defined (HAVE_NS) || defined (HAVE_NTGUI)
    /* Display a submenu using the toolkit.  */
    if (! (NILP (map) || NILP (enabled)))
      {
*************** parse_single_submenu (Lisp_Object item_k
*** 575,581 ****
  }
  
  
! #if defined (USE_X_TOOLKIT) || defined (USE_GTK) || defined (HAVE_NS) || defined (HAVE_NTGUI)
  
  /* Allocate a widget_value, blocking input.  */
  
--- 581,587 ----
  }
  
  
! #if defined (USE_X_TOOLKIT) || defined (USE_GTK) || defined (HAVE_MACGUI) || defined (HAVE_NS) || defined (HAVE_NTGUI)
  
  /* Allocate a widget_value, blocking input.  */
  
*************** find_and_call_menu_selection (FRAME_PTR 
*** 961,967 ****
      }
  }
  
! #endif /* USE_X_TOOLKIT || USE_GTK || HAVE_NS || HAVE_NTGUI */
  
  #ifdef HAVE_NS
  /* As above, but return the menu selection instead of storing in kb buffer.
--- 967,973 ----
      }
  }
  
! #endif /* USE_X_TOOLKIT || USE_GTK || HAVE_MACGUI || HAVE_NS || HAVE_NTGUI */
  
  #ifdef HAVE_NS
  /* As above, but return the menu selection instead of storing in kb buffer.
*************** no quit occurs and `x-popup-menu' return
*** 1098,1104 ****
      /* Decode the first argument: find the window and the coordinates.  */
      if (EQ (position, Qt)
  	|| (CONSP (position) && (EQ (XCAR (position), Qmenu_bar)
! 				 || EQ (XCAR (position), Qtool_bar))))
        {
  	get_current_pos_p = 1;
        }
--- 1104,1114 ----
      /* Decode the first argument: find the window and the coordinates.  */
      if (EQ (position, Qt)
  	|| (CONSP (position) && (EQ (XCAR (position), Qmenu_bar)
! 				 || EQ (XCAR (position), Qtool_bar)
! #ifdef HAVE_MACGUI
! 				 || EQ (XCAR (position), Qmac_apple_event)
! #endif
! 				 )))
        {
  	get_current_pos_p = 1;
        }
*************** no quit occurs and `x-popup-menu' return
*** 1205,1211 ****
  
      /* FIXME: Find a more general check!  */
      if (!(FRAME_X_P (f) || FRAME_MSDOS_P (f)
! 	  || FRAME_W32_P (f) || FRAME_NS_P (f)))
        error ("Can not put GUI menu on this terminal");
  
      XSETFRAME (Vmenu_updating_frame, f);
--- 1215,1221 ----
  
      /* FIXME: Find a more general check!  */
      if (!(FRAME_X_P (f) || FRAME_MSDOS_P (f)
! 	  || FRAME_W32_P (f) || FRAME_MAC_P (f) || FRAME_NS_P (f)))
        error ("Can not put GUI menu on this terminal");
  
      XSETFRAME (Vmenu_updating_frame, f);
*************** no quit occurs and `x-popup-menu' return
*** 1322,1327 ****
--- 1332,1340 ----
  #if defined HAVE_NTGUI
    selection = w32_menu_show (f, xpos, ypos, for_click,
  			     keymaps, title, &error_name);
+ #elif defined HAVE_MACGUI
+   selection = mac_menu_show (f, xpos, ypos, for_click,
+ 			     keymaps, title, &error_name);
  #elif defined HAVE_NS
    selection = ns_menu_show (f, xpos, ypos, for_click,
  			    keymaps, title, &error_name);

=== modified file 'src/menu.h'
*** src/menu.h	2012-01-19 07:21:25 +0000
--- src/menu.h	2012-02-28 03:37:33 +0000
*************** extern void save_menu_items (void);
*** 32,38 ****
  extern int parse_single_submenu (Lisp_Object, Lisp_Object, Lisp_Object);
  extern void list_of_panes (Lisp_Object);
  #if defined (USE_X_TOOLKIT) || defined (USE_GTK) || defined (HAVE_NTGUI) \
!   || defined (HAVE_NS)
  extern void free_menubar_widget_value_tree (widget_value *);
  extern void update_submenu_strings (widget_value *);
  extern void find_and_call_menu_selection (FRAME_PTR, int,
--- 32,38 ----
  extern int parse_single_submenu (Lisp_Object, Lisp_Object, Lisp_Object);
  extern void list_of_panes (Lisp_Object);
  #if defined (USE_X_TOOLKIT) || defined (USE_GTK) || defined (HAVE_NTGUI) \
!   || defined (HAVE_MACGUI) || defined (HAVE_NS)
  extern void free_menubar_widget_value_tree (widget_value *);
  extern void update_submenu_strings (widget_value *);
  extern void find_and_call_menu_selection (FRAME_PTR, int,
*************** extern void mouse_position_for_popup (FR
*** 47,52 ****
--- 47,54 ----
  
  extern Lisp_Object w32_menu_show (FRAME_PTR, int, int, int, int,
  				  Lisp_Object, const char **);
+ extern Lisp_Object mac_menu_show (FRAME_PTR, int, int, int, int,
+ 				  Lisp_Object, const char **);
  extern Lisp_Object ns_menu_show (FRAME_PTR, int, int, int, int,
  				 Lisp_Object, const char **);
  extern Lisp_Object xmenu_show (FRAME_PTR, int, int, int, int,

=== modified file 'src/process.c'
*** src/process.c	2012-04-20 06:39:29 +0000
--- src/process.c	2012-04-28 00:30:28 +0000
*************** usage: (make-network-process &rest ARGS)
*** 3061,3067 ****
        /* SERVICE can either be a string or int.
  	 Convert to a C string for later use by getaddrinfo.  */
        if (EQ (service, Qt))
! 	portstring = "0";
        else if (INTEGERP (service))
  	{
  	  sprintf (portbuf, "%"pI"d", XINT (service));
--- 3061,3070 ----
        /* SERVICE can either be a string or int.
  	 Convert to a C string for later use by getaddrinfo.  */
        if (EQ (service, Qt))
! 	/* We pass NULL for unspecified port, because some versions of
! 	   Darwin return EAI_NONAME for getaddrinfo ("localhost", "0",
! 	   ...).  */
! 	portstring = NULL;
        else if (INTEGERP (service))
  	{
  	  sprintf (portbuf, "%"pI"d", XINT (service));
*************** usage: (make-network-process &rest ARGS)
*** 3087,3097 ****
  
        ret = getaddrinfo (SSDATA (host), portstring, &hints, &res);
        if (ret)
  #ifdef HAVE_GAI_STRERROR
! 	error ("%s/%s %s", SSDATA (host), portstring, gai_strerror (ret));
  #else
! 	error ("%s/%s getaddrinfo error %d", SSDATA (host), portstring, ret);
  #endif
        immediate_quit = 0;
  
        goto open_socket;
--- 3090,3108 ----
  
        ret = getaddrinfo (SSDATA (host), portstring, &hints, &res);
        if (ret)
+ 	{
  #ifdef HAVE_GAI_STRERROR
! 	  if (portstring)
! 	    error ("%s/%s %s", SSDATA (host), portstring, gai_strerror (ret));
! 	  else
! 	    error ("%s %s", SSDATA (host), gai_strerror (ret));
  #else
! 	  if (portstring)
! 	    error ("%s/%s getaddrinfo error %d", SSDATA (host), portstring, ret);
! 	  else
! 	    error ("%s getaddrinfo error %d", SSDATA (host), ret);
  #endif
+ 	}
        immediate_quit = 0;
  
        goto open_socket;
*************** wait_reading_process_output_1 (void)
*** 4248,4254 ****
--- 4259,4272 ----
  static inline int
  select_wrapper (int n, fd_set *rfd, fd_set *wfd, fd_set *xfd, struct timeval *tmo)
  {
+ #ifdef HAVE_MACGUI
+   extern int sys_select (int, SELECT_TYPE *, SELECT_TYPE *, SELECT_TYPE *,
+ 			 EMACS_TIME *);
+ 
+   return sys_select (n, rfd, wfd, xfd, tmo);
+ #else
    return select (n, rfd, wfd, xfd, tmo);
+ #endif
  }
  #define select select_wrapper
  #endif
*************** init_process (void)
*** 7305,7346 ****
    memset (datagram_address, 0, sizeof datagram_address);
  #endif
  
-  {
-    Lisp_Object subfeatures = Qnil;
-    const struct socket_options *sopt;
- 
- #define ADD_SUBFEATURE(key, val) \
-   subfeatures = pure_cons (pure_cons (key, pure_cons (val, Qnil)), subfeatures)
- 
- #ifdef NON_BLOCKING_CONNECT
-    ADD_SUBFEATURE (QCnowait, Qt);
- #endif
- #ifdef DATAGRAM_SOCKETS
-    ADD_SUBFEATURE (QCtype, Qdatagram);
- #endif
- #ifdef HAVE_SEQPACKET
-    ADD_SUBFEATURE (QCtype, Qseqpacket);
- #endif
- #ifdef HAVE_LOCAL_SOCKETS
-    ADD_SUBFEATURE (QCfamily, Qlocal);
- #endif
-    ADD_SUBFEATURE (QCfamily, Qipv4);
- #ifdef AF_INET6
-    ADD_SUBFEATURE (QCfamily, Qipv6);
- #endif
- #ifdef HAVE_GETSOCKNAME
-    ADD_SUBFEATURE (QCservice, Qt);
- #endif
- #if defined (O_NONBLOCK) || defined (O_NDELAY)
-    ADD_SUBFEATURE (QCserver, Qt);
- #endif
- 
-    for (sopt = socket_options; sopt->name; sopt++)
-      subfeatures = pure_cons (intern_c_string (sopt->name), subfeatures);
- 
-    Fprovide (intern_c_string ("make-network-process"), subfeatures);
-  }
- 
  #if defined (DARWIN_OS)
    /* PTYs are broken on Darwin < 6, but are sometimes useful for interactive
       processes.  As such, we only change the default value.  */
--- 7323,7328 ----
*************** The variable takes effect when `start-pr
*** 7553,7558 ****
--- 7535,7576 ----
    defsubr (&Sset_process_filter_multibyte);
    defsubr (&Sprocess_filter_multibyte_p);
  
+  {
+    Lisp_Object subfeatures = Qnil;
+    const struct socket_options *sopt;
+ 
+ #define ADD_SUBFEATURE(key, val) \
+   subfeatures = pure_cons (pure_cons (key, pure_cons (val, Qnil)), subfeatures)
+ 
+ #ifdef NON_BLOCKING_CONNECT
+    ADD_SUBFEATURE (QCnowait, Qt);
+ #endif
+ #ifdef DATAGRAM_SOCKETS
+    ADD_SUBFEATURE (QCtype, Qdatagram);
+ #endif
+ #ifdef HAVE_SEQPACKET
+    ADD_SUBFEATURE (QCtype, Qseqpacket);
+ #endif
+ #ifdef HAVE_LOCAL_SOCKETS
+    ADD_SUBFEATURE (QCfamily, Qlocal);
+ #endif
+    ADD_SUBFEATURE (QCfamily, Qipv4);
+ #ifdef AF_INET6
+    ADD_SUBFEATURE (QCfamily, Qipv6);
+ #endif
+ #ifdef HAVE_GETSOCKNAME
+    ADD_SUBFEATURE (QCservice, Qt);
+ #endif
+ #if defined (O_NONBLOCK) || defined (O_NDELAY)
+    ADD_SUBFEATURE (QCserver, Qt);
+ #endif
+ 
+    for (sopt = socket_options; sopt->name; sopt++)
+      subfeatures = pure_cons (intern_c_string (sopt->name), subfeatures);
+ 
+    Fprovide (intern_c_string ("make-network-process"), subfeatures);
+  }
+ 
  #endif	/* subprocesses */
  
    defsubr (&Sget_buffer_process);

=== modified file 'src/s/darwin.h'
*** src/s/darwin.h	2012-01-19 07:21:25 +0000
--- src/s/darwin.h	2012-02-28 03:54:00 +0000
*************** along with GNU Emacs.  If not, see <http
*** 123,128 ****
--- 123,133 ----
  #define free unexec_free
  /* Don't use posix_memalign because it is not compatible with unexmacosx.c.  */
  #undef HAVE_POSIX_MEMALIGN
+ /* Name of the segment whose VM protection is the default (read/write)
+    for temacs but read-only for the dumped executable.  */
+ #define EMACS_READ_ONLY_SEGMENT "EMACS_READ_ONLY"
+ /* Name of the section to place the pure space.  */
+ //#define PURE_SECTION EMACS_READ_ONLY_SEGMENT ",pure"
  #endif
  
  /* Define the following so emacs symbols will not conflict with those

=== modified file 'src/term.c'
*** src/term.c	2012-01-19 07:21:25 +0000
--- src/term.c	2012-02-27 23:16:05 +0000
*************** static int been_here = -1;
*** 57,62 ****
--- 57,65 ----
  #ifdef HAVE_X_WINDOWS
  #include "xterm.h"
  #endif
+ #ifdef HAVE_MACGUI
+ #include "macterm.h"
+ #endif
  
  #ifndef O_RDWR
  #define O_RDWR 2

=== modified file 'src/termcap.c'
*** src/termcap.c	2011-09-09 01:06:52 +0000
--- src/termcap.c	2012-02-28 03:42:21 +0000
*************** find_capability (register char *bp, regi
*** 79,84 ****
--- 79,87 ----
    return NULL;
  }
  
+ /* These are already defined in the System framework in Mac OS X and
+    cause prebinding to fail.  */
+ #ifndef DARWIN_OS
  int
  tgetnum (const char *cap)
  {
*************** tgetstr (const char *cap, char **area)
*** 108,113 ****
--- 111,117 ----
      return NULL;
    return tgetst1 (ptr, area);
  }
+ #endif /* !DARWIN_OS */
  
  #ifdef IS_EBCDIC_HOST
  /* Table, indexed by a character in range 0200 to 0300 with 0200 subtracted,
*************** tgetst1 (char *ptr, char **area)
*** 264,269 ****
--- 268,276 ----
  
  /* Outputting a string with padding.  */
  
+ /* Already defined in the System framework in Mac OS X and causes
+    prebinding to fail.  */
+ #ifndef DARWIN_OS
  char PC;
  
  void
*************** tputs (register const char *str, int nli
*** 317,322 ****
--- 324,330 ----
    while (padcount-- > 0)
      (*outfun) (PC);
  }
+ #endif /* !DARWIN_OS */
  
  /* Finding the termcap entry in the termcap data base.  */
  
*************** valid_filename_p (char *fn)
*** 357,362 ****
--- 365,373 ----
     0 if the data base is accessible but the type NAME is not defined
     in it, and some other value otherwise.  */
  
+ /* Already defined in the System framework in Mac OS X and causes
+    prebinding to fail.  */
+ #ifndef DARWIN_OS
  int
  tgetent (char *bp, const char *name)
  {
*************** tgetent (char *bp, const char *name)
*** 514,519 ****
--- 525,531 ----
    term_entry = bp;
    return 1;
  }
+ #endif /* !DARWIN_OS */
  
  /* Given file open on FD and buffer BUFP,
     scan the file from the beginning until a line is found

=== modified file 'src/termhooks.h'
*** src/termhooks.h	2012-01-19 07:21:25 +0000
--- src/termhooks.h	2012-02-28 03:42:48 +0000
*************** enum event_kind
*** 102,108 ****
    HORIZ_WHEEL_EVENT,            /* A wheel event generated by a second
                                     horizontal wheel that is present on some
                                     mice. See WHEEL_EVENT.  */
! #if defined (WINDOWSNT)
    LANGUAGE_CHANGE_EVENT,	/* A LANGUAGE_CHANGE_EVENT is
  				   generated on WINDOWSNT or Mac OS
  				   when the keyboard layout or input
--- 102,108 ----
    HORIZ_WHEEL_EVENT,            /* A wheel event generated by a second
                                     horizontal wheel that is present on some
                                     mice. See WHEEL_EVENT.  */
! #if defined (WINDOWSNT) || defined (HAVE_MACGUI)
    LANGUAGE_CHANGE_EVENT,	/* A LANGUAGE_CHANGE_EVENT is
  				   generated on WINDOWSNT or Mac OS
  				   when the keyboard layout or input
*************** enum event_kind
*** 173,178 ****
--- 173,188 ----
       save yourself before shutdown. */
    SAVE_SESSION_EVENT
  
+ #ifdef HAVE_MACGUI
+   /* Generated when an Apple event, a HICommand event, or a Services
+      menu event is received and the corresponding handler is
+      registered.  Members `x' and `y' are for the event class and ID
+      symbols, respectively.  Member `arg' is a Lisp object converted
+      from the received Apple event.  Parameters for non-Apple events
+      are converted to those in Apple events.  */
+   , MAC_APPLE_EVENT
+ #endif
+ 
  #ifdef HAVE_GPM
    , GPM_CLICK_EVENT
  #endif
*************** extern struct tty_display_info *gpm_tty;
*** 317,322 ****
--- 327,333 ----
  #endif
  
  
+ struct mac_display_info;
  struct ns_display_info;
  struct x_display_info;
  struct w32_display_info;
*************** struct terminal
*** 338,349 ****
--- 349,369 ----
    /* This is an association list containing the X selections that
       Emacs might own on this terminal.  Each element has the form
         (SELECTION-NAME SELECTION-VALUE SELECTION-TIMESTAMP FRAME)
+      In the Mac port, each element has the form
+        (SELECTION-NAME SELECTION-VALUE SELECTION-TIMESTAMP FRAME OWNERSHIP-INFO)
       SELECTION-NAME is a lisp symbol, whose name is the name of an X Atom.
       SELECTION-VALUE is the value that emacs owns for that selection.
        It may be any kind of Lisp object.
       SELECTION-TIMESTAMP is the time at which emacs began owning this
        selection, as a cons of two 16-bit numbers (making a 32 bit
        time.)
+      OWNERSHIP-INFO is a value saved when emacs owns for that selection.
+       If another application takes the ownership of that selection
+       later, then newly examined ownership info value should be
+       different from the saved one.
+      If there is an entry in this alist, the current ownership info for
+       the selection coincides with OWNERSHIP-INFO, then it can be
+       assumed that Emacs owns that selection.
       FRAME is the frame for which we made the selection.  If there is
        an entry in this alist, then it can be assumed that Emacs owns
        that selection.
*************** struct terminal
*** 385,390 ****
--- 405,411 ----
      struct tty_display_info *tty;     /* termchar.h */
      struct x_display_info *x;         /* xterm.h */
      struct w32_display_info *w32;     /* w32term.h */
+     struct mac_display_info *mac;     /* macterm.h */
      struct ns_display_info *ns;       /* nsterm.h */
    } display_info;
  

=== modified file 'src/tparam.c'
*** src/tparam.c	2011-08-05 02:15:35 +0000
--- src/tparam.c	2012-02-27 23:16:05 +0000
*************** tparam (const char *string, char *outstr
*** 55,60 ****
--- 55,63 ----
    return tparam1 (string, outstring, len, NULL, NULL, arg);
  }
  
+ /* These are already defined in the System framework in Mac OS X and
+    cause prebinding to fail.  */
+ #ifndef DARWIN_OS
  char *BC;
  char *UP;
  
*************** tgoto (const char *cm, int hpos, int vpo
*** 70,75 ****
--- 73,79 ----
    args[1] = hpos;
    return tparam1 (cm, tgoto_buf, 50, UP, BC, args);
  }
+ #endif
  
  static char *
  tparam1 (const char *string, char *outstring, int len,

=== modified file 'src/unexmacosx.c'
*** src/unexmacosx.c	2012-01-19 07:21:25 +0000
--- src/unexmacosx.c	2012-02-27 23:16:05 +0000
*************** copy_data_segment (struct load_command *
*** 907,912 ****
--- 907,952 ----
      }
  }
  
+ /* Copy a LC_SEGMENT load command for the EMACS_READ_ONLY segment from
+    the input file to the output file, adjusting the file offset of the
+    segment and the file offsets of sections contained in it.  The VM
+    protection is changed to read-only, and the sections are dumped
+    from memory.  */
+ static void
+ copy_emacs_read_only_segment (struct load_command *lc)
+ {
+   struct segment_command *scp = (struct segment_command *) lc;
+   unsigned long old_fileoff = scp->fileoff;
+   struct section *sectp;
+   int j;
+ 
+   scp->fileoff = curr_file_offset;
+   scp->maxprot = scp->initprot = VM_PROT_READ;
+ 
+   printf ("Writing segment %-16.16s @ %#8lx (%#8lx/%#8lx @ %#10lx)\n",
+ 	  scp->segname, (long) (scp->fileoff), (long) (scp->filesize),
+ 	  (long) (scp->vmsize), (long) (scp->vmaddr));
+ 
+   sectp = (struct section *) (scp + 1);
+   for (j = 0; j < scp->nsects; j++)
+     {
+       sectp->offset += curr_file_offset - old_fileoff;
+       if (!unexec_write (sectp->offset, (void *) sectp->addr, sectp->size))
+ 	unexec_error ("cannot write section %.16s", sectp->sectname);
+       printf ("        section %-16.16s at %#8lx - %#8lx (sz: %#8lx)\n",
+ 	      sectp->sectname, (long) (sectp->offset),
+ 	      (long) (sectp->offset + sectp->size), (long) (sectp->size));
+       sectp++;
+     }
+ 
+   curr_file_offset += ROUNDUP_TO_PAGE_BOUNDARY (scp->filesize);
+ 
+   if (!unexec_write (curr_header_offset, lc, lc->cmdsize))
+     unexec_error ("cannot write load command to header");
+ 
+   curr_header_offset += lc->cmdsize;
+ }
+ 
  /* Copy a LC_SYMTAB load command from the input file to the output
     file, adjusting the file offset fields.  */
  static void
*************** dump_it (void)
*** 1210,1215 ****
--- 1250,1259 ----
  
  	      copy_data_segment (lca[i]);
  	    }
+ 	  else if (strncmp (scp->segname, EMACS_READ_ONLY_SEGMENT, 16) == 0)
+ 	    {
+ 	      copy_emacs_read_only_segment (lca[i]);
+ 	    }
  	  else
  	    {
  	      if (strncmp (scp->segname, SEG_LINKEDIT, 16) == 0)

=== modified file 'src/window.c'
*** src/window.c	2012-04-23 16:22:23 +0000
--- src/window.c	2012-04-28 00:30:28 +0000
*************** along with GNU Emacs.  If not, see <http
*** 46,51 ****
--- 46,54 ----
  #ifdef MSDOS
  #include "msdos.h"
  #endif
+ #ifdef HAVE_MACGUI
+ #include "macterm.h"
+ #endif
  #ifdef HAVE_NS
  #include "nsterm.h"
  #endif

=== modified file 'src/xdisp.c'
*** src/xdisp.c	2012-05-30 18:09:17 +0000
--- src/xdisp.c	2012-06-01 10:57:00 +0000
*************** along with GNU Emacs.  If not, see <http
*** 305,310 ****
--- 305,313 ----
  #ifdef WINDOWSNT
  #include "w32term.h"
  #endif
+ #ifdef HAVE_MACGUI
+ #include "macterm.h"
+ #endif
  #ifdef HAVE_NS
  #include "nsterm.h"
  #endif
*************** Lisp_Object Qimage;
*** 409,415 ****
  /* The image map types.  */
  Lisp_Object QCmap;
  static Lisp_Object QCpointer;
! static Lisp_Object Qrect, Qcircle, Qpoly;
  
  /* Tool bar styles */
  Lisp_Object Qboth, Qboth_horiz, Qtext_image_horiz;
--- 412,422 ----
  /* The image map types.  */
  Lisp_Object QCmap;
  static Lisp_Object QCpointer;
! #ifndef HAVE_MACGUI
! static
! #endif
! Lisp_Object Qrect;
! static Lisp_Object Qcircle, Qpoly;
  
  /* Tool bar styles */
  Lisp_Object Qboth, Qboth_horiz, Qtext_image_horiz;
*************** pixel_to_glyph_coords (FRAME_PTR f, regi
*** 1798,1804 ****
--- 1805,1813 ----
     text, or we can't tell because W's current matrix is not up to
     date.  */
  
+ #ifndef HAVE_MACGUI
  static
+ #endif
  struct glyph *
  x_y_to_hpos_vpos (struct window *w, int x, int y, int *hpos, int *vpos,
  		  int *dx, int *dy, int *area)
*************** x_y_to_hpos_vpos (struct window *w, int 
*** 1875,1881 ****
  /* Convert frame-relative x/y to coordinates relative to window W.
     Takes pseudo-windows into account.  */
  
! static void
  frame_to_window_pixel_xy (struct window *w, int *x, int *y)
  {
    if (w->pseudo_window_p)
--- 1884,1893 ----
  /* Convert frame-relative x/y to coordinates relative to window W.
     Takes pseudo-windows into account.  */
  
! #ifndef HAVE_MACGUI
! static
! #endif
! void
  frame_to_window_pixel_xy (struct window *w, int *x, int *y)
  {
    if (w->pseudo_window_p)
*************** prepare_menu_bars (void)
*** 11080,11085 ****
--- 11092,11100 ----
  	  menu_bar_hooks_run = update_menu_bar (f, 0, menu_bar_hooks_run);
  #ifdef HAVE_WINDOW_SYSTEM
  	  update_tool_bar (f, 0);
+ #ifdef HAVE_MACGUI
+ 	  mac_update_title_bar (f, 0);
+ #endif
  #endif
  #ifdef HAVE_NS
            if (windows_or_buffers_changed
*************** prepare_menu_bars (void)
*** 11098,11103 ****
--- 11113,11121 ----
        update_menu_bar (sf, 1, 0);
  #ifdef HAVE_WINDOW_SYSTEM
        update_tool_bar (sf, 1);
+ #ifdef HAVE_MACGUI
+       mac_update_title_bar (sf, 1);
+ #endif
  #endif
      }
  }
*************** update_menu_bar (struct frame *f, int sa
*** 11131,11137 ****
  
    if (FRAME_WINDOW_P (f)
        ?
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) \
      || defined (HAVE_NS) || defined (USE_GTK)
        FRAME_EXTERNAL_MENU_BAR (f)
  #else
--- 11149,11155 ----
  
    if (FRAME_WINDOW_P (f)
        ?
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI) \
      || defined (HAVE_NS) || defined (USE_GTK)
        FRAME_EXTERNAL_MENU_BAR (f)
  #else
*************** update_menu_bar (struct frame *f, int sa
*** 11190,11200 ****
  	  FRAME_MENU_BAR_ITEMS (f) = menu_bar_items (FRAME_MENU_BAR_ITEMS (f));
  
  	  /* Redisplay the menu bar in case we changed it.  */
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) \
      || defined (HAVE_NS) || defined (USE_GTK)
  	  if (FRAME_WINDOW_P (f))
              {
! #if defined (HAVE_NS)
                /* All frames on Mac OS share the same menubar.  So only
                   the selected frame should be allowed to set it.  */
                if (f == SELECTED_FRAME ())
--- 11208,11218 ----
  	  FRAME_MENU_BAR_ITEMS (f) = menu_bar_items (FRAME_MENU_BAR_ITEMS (f));
  
  	  /* Redisplay the menu bar in case we changed it.  */
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI) \
      || defined (HAVE_NS) || defined (USE_GTK)
  	  if (FRAME_WINDOW_P (f))
              {
! #if defined (HAVE_MACGUI) || defined (HAVE_NS)
                /* All frames on Mac OS share the same menubar.  So only
                   the selected frame should be allowed to set it.  */
                if (f == SELECTED_FRAME ())
*************** update_menu_bar (struct frame *f, int sa
*** 11205,11215 ****
  	    /* On a terminal screen, the menu bar is an ordinary screen
  	       line, and this makes it get updated.  */
  	    w->update_mode_line = Qt;
! #else /* ! (USE_X_TOOLKIT || HAVE_NTGUI || HAVE_NS || USE_GTK) */
  	  /* In the non-toolkit version, the menu bar is an ordinary screen
  	     line, and this makes it get updated.  */
  	  w->update_mode_line = Qt;
! #endif /* ! (USE_X_TOOLKIT || HAVE_NTGUI || HAVE_NS || USE_GTK) */
  
  	  unbind_to (count, Qnil);
  	  set_buffer_internal_1 (prev);
--- 11223,11233 ----
  	    /* On a terminal screen, the menu bar is an ordinary screen
  	       line, and this makes it get updated.  */
  	    w->update_mode_line = Qt;
! #else /* ! (USE_X_TOOLKIT || HAVE_NTGUI || HAVE_MACGUI || HAVE_NS || USE_GTK) */
  	  /* In the non-toolkit version, the menu bar is an ordinary screen
  	     line, and this makes it get updated.  */
  	  w->update_mode_line = Qt;
! #endif /* ! (USE_X_TOOLKIT || HAVE_NTGUI || HAVE_MACGUI || HAVE_NS || USE_GTK) */
  
  	  unbind_to (count, Qnil);
  	  set_buffer_internal_1 (prev);
*************** FRAME_PTR last_mouse_frame;
*** 11307,11312 ****
--- 11325,11337 ----
  
  int last_tool_bar_item;
  
+ #if defined (USE_GTK) || defined (HAVE_NS)
+ #define FRAME_TOOLKIT_TOOL_BAR_P(f)	1
+ #elif defined (HAVE_MACGUI)
+ #define FRAME_TOOLKIT_TOOL_BAR_P(f)	(!(FRAME_MAC_P (f) && FRAME_NATIVE_TOOL_BAR_P (f)))
+ #else
+ #define FRAME_TOOLKIT_TOOL_BAR_P(f)	0
+ #endif
  
  static Lisp_Object
  update_tool_bar_unwind (Lisp_Object frame)
*************** update_tool_bar_unwind (Lisp_Object fram
*** 11323,11334 ****
  static void
  update_tool_bar (struct frame *f, int save_match_data)
  {
! #if defined (USE_GTK) || defined (HAVE_NS)
!   int do_update = FRAME_EXTERNAL_TOOL_BAR (f);
! #else
!   int do_update = WINDOWP (f->tool_bar_window)
!     && WINDOW_TOTAL_LINES (XWINDOW (f->tool_bar_window)) > 0;
! #endif
  
    if (do_update)
      {
--- 11348,11360 ----
  static void
  update_tool_bar (struct frame *f, int save_match_data)
  {
!   int do_update;
! 
!   if (FRAME_TOOLKIT_TOOL_BAR_P (f))
!     do_update = FRAME_EXTERNAL_TOOL_BAR (f);
!   else
!     do_update = WINDOWP (f->tool_bar_window)
!       && WINDOW_TOTAL_LINES (XWINDOW (f->tool_bar_window)) > 0;
  
    if (do_update)
      {
*************** redisplay_tool_bar (struct frame *f)
*** 11790,11800 ****
    struct it it;
    struct glyph_row *row;
  
! #if defined (USE_GTK) || defined (HAVE_NS)
!   if (FRAME_EXTERNAL_TOOL_BAR (f))
!     update_frame_tool_bar (f);
!   return 0;
! #endif
  
    /* If frame hasn't a tool-bar window or if it is zero-height, don't
       do anything.  This means you must start with tool-bar-lines
--- 11816,11827 ----
    struct it it;
    struct glyph_row *row;
  
!   if (FRAME_TOOLKIT_TOOL_BAR_P (f))
!     {
!       if (FRAME_EXTERNAL_TOOL_BAR (f))
! 	update_frame_tool_bar (f);
!       return 0;
!     }
  
    /* If frame hasn't a tool-bar window or if it is zero-height, don't
       do anything.  This means you must start with tool-bar-lines
*************** redisplay_internal (void)
*** 12829,12835 ****
    if (!fr->glyphs_initialized_p)
      return;
  
! #if defined (USE_X_TOOLKIT) || defined (USE_GTK) || defined (HAVE_NS)
    if (popup_activated ())
      return;
  #endif
--- 12856,12862 ----
    if (!fr->glyphs_initialized_p)
      return;
  
! #if defined (USE_X_TOOLKIT) || defined (USE_GTK) || defined (HAVE_MACGUI) || defined (HAVE_NS)
    if (popup_activated ())
      return;
  #endif
*************** redisplay_window (Lisp_Object window, in
*** 15456,15461 ****
--- 15483,15491 ----
        int new_vpos = -1;
  
        w->force_start = Qnil;
+ #ifdef HAVE_MACGUI
+       if (!mac_redisplay_dont_reset_vscroll)
+ #endif
        w->vscroll = 0;
        w->window_end_valid = Qnil;
  
*************** redisplay_window (Lisp_Object window, in
*** 16019,16025 ****
  
        if (FRAME_WINDOW_P (f))
  	{
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) \
      || defined (HAVE_NS) || defined (USE_GTK)
  	  redisplay_menu_p = FRAME_EXTERNAL_MENU_BAR (f);
  #else
--- 16049,16055 ----
  
        if (FRAME_WINDOW_P (f))
  	{
! #if defined (USE_X_TOOLKIT) || defined (HAVE_NTGUI) || defined (HAVE_MACGUI) \
      || defined (HAVE_NS) || defined (USE_GTK)
  	  redisplay_menu_p = FRAME_EXTERNAL_MENU_BAR (f);
  #else
*************** redisplay_window (Lisp_Object window, in
*** 16035,16049 ****
  #ifdef HAVE_WINDOW_SYSTEM
        if (FRAME_WINDOW_P (f))
          {
! #if defined (USE_GTK) || defined (HAVE_NS)
! 	  if (FRAME_EXTERNAL_TOOL_BAR (f))
! 	    redisplay_tool_bar (f);
! #else
! 	  if (WINDOWP (f->tool_bar_window)
! 	      && (FRAME_TOOL_BAR_LINES (f) > 0
! 		  || !NILP (Vauto_resize_tool_bars))
! 	      && redisplay_tool_bar (f))
! 	    ignore_mouse_drag_p = 1;
  #endif
          }
  #endif
--- 16065,16084 ----
  #ifdef HAVE_WINDOW_SYSTEM
        if (FRAME_WINDOW_P (f))
          {
! 	  if (FRAME_TOOLKIT_TOOL_BAR_P (f))
! 	    {
! 	      if (FRAME_EXTERNAL_TOOL_BAR (f))
! 		redisplay_tool_bar (f);
! 	    }
! #if !defined (USE_GTK) && !defined (HAVE_NS)
! 	  else
! 	    {
! 	      if (WINDOWP (f->tool_bar_window)
! 		  && (FRAME_TOOL_BAR_LINES (f) > 0
! 		      || !NILP (Vauto_resize_tool_bars))
! 		  && redisplay_tool_bar (f))
! 		ignore_mouse_drag_p = 1;
! 	    }
  #endif
          }
  #endif
*************** display_menu_bar (struct window *w)
*** 19849,19854 ****
--- 19884,19893 ----
    if (FRAME_X_P (f))
      return;
  #endif
+ #ifdef HAVE_MACGUI
+   if (FRAME_MAC_P (f))
+     return;
+ #endif
  
  #ifdef HAVE_NS
    if (FRAME_NS_P (f))
*************** get_char_face_and_encoding (struct frame
*** 22280,22286 ****
      }
  
    /* Make sure X resources of the face are allocated.  */
! #ifdef HAVE_X_WINDOWS
    if (display_p)
  #endif
      {
--- 22319,22325 ----
      }
  
    /* Make sure X resources of the face are allocated.  */
! #if defined (HAVE_X_WINDOWS) || defined (HAVE_MACGUI)
    if (display_p)
  #endif
      {
*************** cursor_in_mouse_face_p (struct window *w
*** 26048,26054 ****
     covers these buffer positions.  This is similar to
     row_containing_pos, but is more accurate when bidi reordering makes
     buffer positions change non-linearly with glyph rows.  */
! static void
  rows_from_pos_range (struct window *w,
  		     EMACS_INT start_charpos, EMACS_INT end_charpos,
  		     Lisp_Object disp_string,
--- 26087,26096 ----
     covers these buffer positions.  This is similar to
     row_containing_pos, but is more accurate when bidi reordering makes
     buffer positions change non-linearly with glyph rows.  */
! #ifndef HAVE_MACGUI
! static
! #endif
! void
  rows_from_pos_range (struct window *w,
  		     EMACS_INT start_charpos, EMACS_INT end_charpos,
  		     Lisp_Object disp_string,
*************** note_mouse_highlight (struct frame *f, i
*** 27212,27218 ****
    struct buffer *b;
  
    /* When a menu is active, don't highlight because this looks odd.  */
! #if defined (USE_X_TOOLKIT) || defined (USE_GTK) || defined (HAVE_NS) || defined (MSDOS)
    if (popup_activated ())
      return;
  #endif
--- 27254,27260 ----
    struct buffer *b;
  
    /* When a menu is active, don't highlight because this looks odd.  */
! #if defined (USE_X_TOOLKIT) || defined (USE_GTK) || defined (HAVE_MACGUI) || defined (HAVE_NS) || defined (MSDOS)
    if (popup_activated ())
      return;
  #endif

=== modified file 'src/xfaces.c'
*** src/xfaces.c	2012-03-21 07:02:13 +0000
--- src/xfaces.c	2012-06-10 07:58:38 +0000
*************** along with GNU Emacs.  If not, see <http
*** 238,243 ****
--- 238,249 ----
  #define GCGraphicsExposures 0
  #endif /* WINDOWSNT */
  
+ #ifdef HAVE_MACGUI
+ #include "macterm.h"
+ #define x_display_info mac_display_info
+ #define check_x check_mac
+ #endif /* HAVE_MACGUI */
+ 
  #ifdef HAVE_NS
  #include "nsterm.h"
  #undef FRAME_X_DISPLAY_INFO
*************** x_free_gc (struct frame *f, GC gc)
*** 715,720 ****
--- 721,750 ----
  }
  #endif  /* HAVE_NS */
  
+ #ifdef HAVE_MACGUI
+ /* Mac OS emulation of GCs */
+ 
+ static inline GC
+ x_create_gc (struct frame *f, unsigned long mask, XGCValues *xgcv)
+ {
+   GC gc;
+   BLOCK_INPUT;
+   gc = XCreateGC (FRAME_MAC_DISPLAY (f), FRAME_MAC_WINDOW (f), mask, xgcv);
+   UNBLOCK_INPUT;
+   IF_DEBUG (++ngcs);
+   return gc;
+ }
+ 
+ static void
+ x_free_gc (struct frame *f, GC gc)
+ {
+   eassert (interrupt_input_blocked);
+   IF_DEBUG (xassert (--ngcs >= 0));
+   XFreeGC (FRAME_MAC_DISPLAY (f), gc);
+ }
+ 
+ #endif  /* HAVE_MACGUI */
+ 
  /* Like strcasecmp/stricmp.  Used to compare parts of font names which
     are in ISO8859-1.  */
  
*************** init_frame_faces (struct frame *f)
*** 789,794 ****
--- 819,827 ----
  #ifdef WINDOWSNT
    if (!FRAME_WINDOW_P (f) || FRAME_W32_WINDOW (f))
  #endif
+ #ifdef HAVE_MACGUI
+   if (!FRAME_MAC_P (f) || FRAME_MAC_WINDOW (f))
+ #endif
  #ifdef HAVE_NS
    if (!FRAME_NS_P (f) || FRAME_NS_WINDOW (f))
  #endif
*************** defined_color (struct frame *f, const ch
*** 1169,1174 ****
--- 1202,1211 ----
    else if (FRAME_W32_P (f))
      return w32_defined_color (f, color_name, color_def, alloc);
  #endif
+ #ifdef HAVE_MACGUI
+   else if (FRAME_MAC_P (f))
+     return mac_defined_color (f, color_name, color_def, alloc);
+ #endif
  #ifdef HAVE_NS
    else if (FRAME_NS_P (f))
      return ns_defined_color (f, color_name, color_def, alloc, 1);
*************** lface_fully_specified_p (Lisp_Object *at
*** 2175,2181 ****
  
    for (i = 1; i < LFACE_VECTOR_SIZE; ++i)
      if (i != LFACE_FONT_INDEX && i != LFACE_INHERIT_INDEX)
!       if ((UNSPECIFIEDP (attrs[i]) || IGNORE_DEFFACE_P (attrs[i])))
  	break;
  
    return i == LFACE_VECTOR_SIZE;
--- 2212,2224 ----
  
    for (i = 1; i < LFACE_VECTOR_SIZE; ++i)
      if (i != LFACE_FONT_INDEX && i != LFACE_INHERIT_INDEX)
!       if ((UNSPECIFIEDP (attrs[i]) || IGNORE_DEFFACE_P (attrs[i]))
! #ifdef HAVE_MACGUI
!         /* MAC_TODO: No stipple support on Mac OS yet, this index is
!            always unspecified.  */
!           && i != LFACE_STIPPLE_INDEX
! #endif
! 	  )
  	break;
  
    return i == LFACE_VECTOR_SIZE;
*************** face_for_overlay_string (struct window *
*** 6107,6120 ****
  
    *endptr = endpos;
  
!   default_face = FACE_FROM_ID (f, DEFAULT_FACE_ID);
! 
!   /* Optimize common cases where we can use the default face.  */
    if (NILP (prop)
!       && !(pos >= region_beg && pos < region_end))
      return DEFAULT_FACE_ID;
  
    /* Begin with attributes from the default face.  */
    memcpy (attrs, default_face->lface, sizeof attrs);
  
    /* Merge in attributes specified via text properties.  */
--- 6150,6163 ----
  
    *endptr = endpos;
  
!   /* Optimize common case where we can use the default face.  */
    if (NILP (prop)
!       && !(pos >= region_beg && pos < region_end)
!       && NILP (Vface_remapping_alist))
      return DEFAULT_FACE_ID;
  
    /* Begin with attributes from the default face.  */
+   default_face = FACE_FROM_ID (f, lookup_basic_face (f, DEFAULT_FACE_ID));
    memcpy (attrs, default_face->lface, sizeof attrs);
  
    /* Merge in attributes specified via text properties.  */

=== modified file 'lib/Makefile.in'
*** lib/Makefile.in	2012-02-01 11:17:54 +0000
--- lib/Makefile.in	2012-06-10 07:58:38 +0000
***************
*** 1,9 ****
! # Makefile.in generated by automake 1.11.1 from Makefile.am.
  # @configure_input@
  
! # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
! # 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
! # Inc.
  # This Makefile.in is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
--- 1,8 ----
! # Makefile.in generated by automake 1.12.1 from Makefile.am.
  # @configure_input@
  
! # Copyright (C) 1994-2012 Free Software Foundation, Inc.
! 
  # This Makefile.in is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
***************
*** 39,44 ****
--- 38,60 ----
  # Reproduce by: gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --tests-base=tests --aux-dir=build-aux --avoid=msvc-inval --avoid=msvc-nothrow --avoid=raise --avoid=threadlib --makefile-name=gnulib.mk --conditional-dependencies --no-libtool --macro-prefix=gl --no-vc-files alloca-opt careadlinkat crypto/md5 crypto/sha1 crypto/sha256 crypto/sha512 dtoastr dup2 filemode getloadavg getopt-gnu ignore-value intprops lstat mktime pthread_sigmask readlink socklen stdarg stdio strftime strtoimax strtoumax symlink sys_stat
  
  VPATH = @srcdir@
+ am__make_dryrun = \
+   { \
+     am__dry=no; \
+     case $$MAKEFLAGS in \
+       *\\[\ \	]*) \
+         echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+           | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+       *) \
+         for am__flg in $$MAKEFLAGS; do \
+           case $$am__flg in \
+             *=*|--*) ;; \
+             *n*) am__dry=yes; break;; \
+           esac; \
+         done;; \
+     esac; \
+     test $$am__dry = yes; \
+   }
  pkgdatadir = $(datadir)/@PACKAGE@
  pkgincludedir = $(includedir)/@PACKAGE@
  pkglibdir = $(libdir)/@PACKAGE@
*************** POST_UNINSTALL = :
*** 58,64 ****
  build_triplet = @build@
  host_triplet = @host@
  DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
! 	$(srcdir)/gnulib.mk COPYING
  @gl_GNULIB_ENABLED_be453cec5eecf5731a274f2de7f2db36_TRUE@am__append_1 = gettext.h
  subdir = lib
  ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
--- 74,80 ----
  build_triplet = @build@
  host_triplet = @host@
  DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
! 	$(srcdir)/gnulib.mk $(top_srcdir)/build-aux/depcomp COPYING
  @gl_GNULIB_ENABLED_be453cec5eecf5731a274f2de7f2db36_TRUE@am__append_1 = gettext.h
  subdir = lib
  ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
*************** am__aclocal_m4_deps = $(top_srcdir)/m4/0
*** 69,78 ****
  	$(top_srcdir)/m4/getopt.m4 $(top_srcdir)/m4/gl-comp.m4 \
  	$(top_srcdir)/m4/gnulib-common.m4 \
  	$(top_srcdir)/m4/include_next.m4 $(top_srcdir)/m4/inttypes.m4 \
! 	$(top_srcdir)/m4/largefile.m4 $(top_srcdir)/m4/longlong.m4 \
! 	$(top_srcdir)/m4/lstat.m4 $(top_srcdir)/m4/md5.m4 \
! 	$(top_srcdir)/m4/mktime.m4 $(top_srcdir)/m4/multiarch.m4 \
! 	$(top_srcdir)/m4/nocrash.m4 $(top_srcdir)/m4/pathmax.m4 \
  	$(top_srcdir)/m4/pthread_sigmask.m4 \
  	$(top_srcdir)/m4/readlink.m4 $(top_srcdir)/m4/sha1.m4 \
  	$(top_srcdir)/m4/sha256.m4 $(top_srcdir)/m4/sha512.m4 \
--- 85,94 ----
  	$(top_srcdir)/m4/getopt.m4 $(top_srcdir)/m4/gl-comp.m4 \
  	$(top_srcdir)/m4/gnulib-common.m4 \
  	$(top_srcdir)/m4/include_next.m4 $(top_srcdir)/m4/inttypes.m4 \
! 	$(top_srcdir)/m4/longlong.m4 $(top_srcdir)/m4/lstat.m4 \
! 	$(top_srcdir)/m4/md5.m4 $(top_srcdir)/m4/mktime.m4 \
! 	$(top_srcdir)/m4/multiarch.m4 $(top_srcdir)/m4/nocrash.m4 \
! 	$(top_srcdir)/m4/pathmax.m4 \
  	$(top_srcdir)/m4/pthread_sigmask.m4 \
  	$(top_srcdir)/m4/readlink.m4 $(top_srcdir)/m4/sha1.m4 \
  	$(top_srcdir)/m4/sha256.m4 $(top_srcdir)/m4/sha512.m4 \
*************** CCLD = $(CC)
*** 115,120 ****
--- 131,141 ----
  LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
  SOURCES = $(libgnu_a_SOURCES) $(EXTRA_libgnu_a_SOURCES)
  DIST_SOURCES = $(am__libgnu_a_SOURCES_DIST) $(EXTRA_libgnu_a_SOURCES)
+ am__can_run_installinfo = \
+   case $$AM_UPDATE_INFO_DIR in \
+     n|no|NO) false;; \
+     *) (install-info --version) >/dev/null 2>&1;; \
+   esac
  ETAGS = etags
  CTAGS = ctags
  DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
*************** LTLIBINTL = @LTLIBINTL@
*** 527,532 ****
--- 548,555 ----
  LTLIBOBJS = @LTLIBOBJS@
  M17N_FLT_CFLAGS = @M17N_FLT_CFLAGS@
  M17N_FLT_LIBS = @M17N_FLT_LIBS@
+ MAC_OBJ = @MAC_OBJ@
+ MAC_OBJC_OBJ = @MAC_OBJC_OBJ@
  MAINT = @MAINT@
  MAKEINFO = @MAKEINFO@
  MKDEPDIR = @MKDEPDIR@
*************** lisppath = @lisppath@
*** 756,763 ****
  localedir = @localedir@
  locallisppath = @locallisppath@
  localstatedir = @localstatedir@
  mandir = @mandir@
- mkdir_p = @mkdir_p@
  ns_appbindir = @ns_appbindir@
  ns_appdir = @ns_appdir@
  ns_appresdir = @ns_appresdir@
--- 779,786 ----
  localedir = @localedir@
  locallisppath = @locallisppath@
  localstatedir = @localstatedir@
+ mac_appdir = @mac_appdir@
  mandir = @mandir@
  ns_appbindir = @ns_appbindir@
  ns_appdir = @ns_appdir@
  ns_appresdir = @ns_appresdir@
*************** Makefile: $(srcdir)/Makefile.in $(top_bu
*** 858,863 ****
--- 881,887 ----
  	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
  	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
  	esac;
+ $(srcdir)/gnulib.mk:
  
  $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
  	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
*************** $(am__aclocal_m4_deps):
*** 870,876 ****
  
  clean-noinstLIBRARIES:
  	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
! libgnu.a: $(libgnu_a_OBJECTS) $(libgnu_a_DEPENDENCIES) 
  	-rm -f libgnu.a
  	$(libgnu_a_AR) libgnu.a $(libgnu_a_OBJECTS) $(libgnu_a_LIBADD)
  	$(RANLIB) libgnu.a
--- 894,900 ----
  
  clean-noinstLIBRARIES:
  	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
! libgnu.a: $(libgnu_a_OBJECTS) $(libgnu_a_DEPENDENCIES) $(EXTRA_libgnu_a_DEPENDENCIES) 
  	-rm -f libgnu.a
  	$(libgnu_a_AR) libgnu.a $(libgnu_a_OBJECTS) $(libgnu_a_LIBADD)
  	$(RANLIB) libgnu.a
*************** GTAGS:
*** 973,978 ****
--- 997,1016 ----
  	  && $(am__cd) $(top_srcdir) \
  	  && gtags -i $(GTAGS_ARGS) "$$here"
  
+ cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+ 	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+ 	case "$(srcdir)" in \
+ 	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+ 	  *) sdir=$(subdir)/$(srcdir) ;; \
+ 	esac; \
+ 	for i in $$list; do \
+ 	  if test -f "$$i"; then \
+ 	    echo "$(subdir)/$$i"; \
+ 	  else \
+ 	    echo "$$sdir/$$i"; \
+ 	  fi; \
+ 	done >> $(top_builddir)/cscope.files
+ 
  distclean-tags:
  	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
  
*************** install-am: all-am
*** 1022,1031 ****
  
  installcheck: installcheck-am
  install-strip:
! 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
! 	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
! 	  `test -z '$(STRIP)' || \
! 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
  mostlyclean-generic:
  	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
  
--- 1060,1074 ----
  
  installcheck: installcheck-am
  install-strip:
! 	if test -z '$(STRIP)'; then \
! 	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
! 	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
! 	      install; \
! 	else \
! 	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
! 	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
! 	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
! 	fi
  mostlyclean-generic:
  	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
  
*************** uninstall-am:
*** 1112,1125 ****
  .MAKE: all check install install-am install-strip
  
  .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
! 	clean-noinstLIBRARIES ctags distclean distclean-compile \
! 	distclean-generic distclean-tags distdir dvi dvi-am html \
! 	html-am info info-am install install-am install-data \
! 	install-data-am install-dvi install-dvi-am install-exec \
! 	install-exec-am install-html install-html-am install-info \
! 	install-info-am install-man install-pdf install-pdf-am \
! 	install-ps install-ps-am install-strip installcheck \
! 	installcheck-am installdirs maintainer-clean \
  	maintainer-clean-generic mostlyclean mostlyclean-compile \
  	mostlyclean-generic mostlyclean-local pdf pdf-am ps ps-am tags \
  	uninstall uninstall-am
--- 1155,1168 ----
  .MAKE: all check install install-am install-strip
  
  .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
! 	clean-noinstLIBRARIES cscopelist ctags distclean \
! 	distclean-compile distclean-generic distclean-tags distdir dvi \
! 	dvi-am html html-am info info-am install install-am \
! 	install-data install-data-am install-dvi install-dvi-am \
! 	install-exec install-exec-am install-html install-html-am \
! 	install-info install-info-am install-man install-pdf \
! 	install-pdf-am install-ps install-ps-am install-strip \
! 	installcheck installcheck-am installdirs maintainer-clean \
  	maintainer-clean-generic mostlyclean mostlyclean-compile \
  	mostlyclean-generic mostlyclean-local pdf pdf-am ps ps-am tags \
  	uninstall uninstall-am

=== modified file 'aclocal.m4'
*** aclocal.m4	2012-02-01 11:17:54 +0000
--- aclocal.m4	2012-06-10 07:58:38 +0000
***************
*** 1,7 ****
! # generated automatically by aclocal 1.11.1 -*- Autoconf -*-
  
- # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
- # 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
--- 1,7 ----
! # generated automatically by aclocal 1.12.1 -*- Autoconf -*-
! 
! # Copyright (C) 1996-2012 Free Software Foundation, Inc.
  
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
***************
*** 13,40 ****
  
  m4_ifndef([AC_AUTOCONF_VERSION],
    [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
! m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.68],,
! [m4_warning([this file was generated for autoconf 2.68.
  You have another version of autoconf.  It may work, but is not guaranteed to.
  If you have problems, you may need to regenerate the build system entirely.
! To do so, use the procedure documented by the package, typically `autoreconf'.])])
  
! # Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
  # AM_AUTOMAKE_VERSION(VERSION)
  # ----------------------------
  # Automake X.Y traces this macro to ensure aclocal.m4 has been
  # generated from the m4 files accompanying Automake X.Y.
  # (This private macro should not be called outside this file.)
  AC_DEFUN([AM_AUTOMAKE_VERSION],
! [am__api_version='1.11'
  dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
  dnl require some minimum version.  Point them to the right macro.
! m4_if([$1], [1.11.1], [],
        [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
  ])
  
--- 13,42 ----
  
  m4_ifndef([AC_AUTOCONF_VERSION],
    [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
! m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,
! [m4_warning([this file was generated for autoconf 2.69.
  You have another version of autoconf.  It may work, but is not guaranteed to.
  If you have problems, you may need to regenerate the build system entirely.
! To do so, use the procedure documented by the package, typically 'autoreconf'.])])
  
! # Copyright (C) 2002-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
+ # serial 8
+ 
  # AM_AUTOMAKE_VERSION(VERSION)
  # ----------------------------
  # Automake X.Y traces this macro to ensure aclocal.m4 has been
  # generated from the m4 files accompanying Automake X.Y.
  # (This private macro should not be called outside this file.)
  AC_DEFUN([AM_AUTOMAKE_VERSION],
! [am__api_version='1.12'
  dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
  dnl require some minimum version.  Point them to the right macro.
! m4_if([$1], [1.12.1], [],
        [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
  ])
  
*************** m4_define([_AM_AUTOCONF_VERSION], [])
*** 50,71 ****
  # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
  # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
  AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
! [AM_AUTOMAKE_VERSION([1.11.1])dnl
  m4_ifndef([AC_AUTOCONF_VERSION],
    [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
  _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
  
  # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
  
! # Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
  # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
! # $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
! # `$srcdir', `$srcdir/..', or `$srcdir/../..'.
  #
  # Of course, Automake must honor this variable whenever it calls a
  # tool from the auxiliary directory.  The problem is that $srcdir (and
--- 52,75 ----
  # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
  # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
  AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
! [AM_AUTOMAKE_VERSION([1.12.1])dnl
  m4_ifndef([AC_AUTOCONF_VERSION],
    [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
  _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
  
  # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
  
! # Copyright (C) 2001-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
+ # serial 2
+ 
  # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
! # $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to
! # '$srcdir', '$srcdir/..', or '$srcdir/../..'.
  #
  # Of course, Automake must honor this variable whenever it calls a
  # tool from the auxiliary directory.  The problem is that $srcdir (and
*************** _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCON
*** 84,90 ****
  #
  # The reason of the latter failure is that $top_srcdir and $ac_aux_dir
  # are both prefixed by $srcdir.  In an in-source build this is usually
! # harmless because $srcdir is `.', but things will broke when you
  # start a VPATH build or use an absolute $srcdir.
  #
  # So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
--- 88,94 ----
  #
  # The reason of the latter failure is that $top_srcdir and $ac_aux_dir
  # are both prefixed by $srcdir.  In an in-source build this is usually
! # harmless because $srcdir is '.', but things will broke when you
  # start a VPATH build or use an absolute $srcdir.
  #
  # So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
*************** am_aux_dir=`cd $ac_aux_dir && pwd`
*** 110,131 ****
  
  # AM_CONDITIONAL                                            -*- Autoconf -*-
  
! # Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008
! # Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 9
  
  # AM_CONDITIONAL(NAME, SHELL-CONDITION)
  # -------------------------------------
  # Define a conditional.
  AC_DEFUN([AM_CONDITIONAL],
! [AC_PREREQ(2.52)dnl
!  ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
! 	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
  AC_SUBST([$1_TRUE])dnl
  AC_SUBST([$1_FALSE])dnl
  _AM_SUBST_NOTMAKE([$1_TRUE])dnl
--- 114,134 ----
  
  # AM_CONDITIONAL                                            -*- Autoconf -*-
  
! # Copyright (C) 1997-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 10
  
  # AM_CONDITIONAL(NAME, SHELL-CONDITION)
  # -------------------------------------
  # Define a conditional.
  AC_DEFUN([AM_CONDITIONAL],
! [AC_PREREQ([2.52])dnl
!  m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
!        [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
  AC_SUBST([$1_TRUE])dnl
  AC_SUBST([$1_FALSE])dnl
  _AM_SUBST_NOTMAKE([$1_TRUE])dnl
*************** AC_CONFIG_COMMANDS_PRE(
*** 144,159 ****
  Usually this means the macro was only invoked conditionally.]])
  fi])])
  
! # Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009
! # Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 10
  
! # There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
  # written in clear, in which case automake, when reading aclocal.m4,
  # will think it sees a *use*, and therefore will trigger all it's
  # C support machinery.  Also note that it means that autoscan, seeing
--- 147,161 ----
  Usually this means the macro was only invoked conditionally.]])
  fi])])
  
! # Copyright (C) 1999-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 17
  
! # There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be
  # written in clear, in which case automake, when reading aclocal.m4,
  # will think it sees a *use*, and therefore will trigger all it's
  # C support machinery.  Also note that it means that autoscan, seeing
*************** fi])])
*** 163,169 ****
  # _AM_DEPENDENCIES(NAME)
  # ----------------------
  # See how the compiler implements dependency checking.
! # NAME is "CC", "CXX", "GCJ", or "OBJC".
  # We try a few techniques and use that to set a single cache variable.
  #
  # We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
--- 165,171 ----
  # _AM_DEPENDENCIES(NAME)
  # ----------------------
  # See how the compiler implements dependency checking.
! # NAME is "CC", "CXX", "OBJC", "OBJCXX", "UPC", or "GJC".
  # We try a few techniques and use that to set a single cache variable.
  #
  # We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
*************** AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMAND
*** 176,187 ****
  AC_REQUIRE([AM_MAKE_INCLUDE])dnl
  AC_REQUIRE([AM_DEP_TRACK])dnl
  
! ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
!        [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
!        [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
!        [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
!        [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
!                    [depcc="$$1"   am_compiler_list=])
  
  AC_CACHE_CHECK([dependency style of $depcc],
                 [am_cv_$1_dependencies_compiler_type],
--- 178,190 ----
  AC_REQUIRE([AM_MAKE_INCLUDE])dnl
  AC_REQUIRE([AM_DEP_TRACK])dnl
  
! m4_if([$1], [CC],   [depcc="$CC"   am_compiler_list=],
!       [$1], [CXX],  [depcc="$CXX"  am_compiler_list=],
!       [$1], [OBJC], [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
!       [$1], [OBJCXX], [depcc="$OBJCXX" am_compiler_list='gcc3 gcc'],
!       [$1], [UPC],  [depcc="$UPC"  am_compiler_list=],
!       [$1], [GCJ],  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
!                     [depcc="$$1"   am_compiler_list=])
  
  AC_CACHE_CHECK([dependency style of $depcc],
                 [am_cv_$1_dependencies_compiler_type],
*************** AC_CACHE_CHECK([dependency style of $dep
*** 189,196 ****
    # We make a subdir and do the tests there.  Otherwise we can end up
    # making bogus files that we don't know about and never remove.  For
    # instance it was reported that on HP-UX the gcc test will end up
!   # making a dummy file named `D' -- because `-MD' means `put the output
!   # in D'.
    mkdir conftest.dir
    # Copy depcomp to subdir because otherwise we won't find it if we're
    # using a relative directory.
--- 192,200 ----
    # We make a subdir and do the tests there.  Otherwise we can end up
    # making bogus files that we don't know about and never remove.  For
    # instance it was reported that on HP-UX the gcc test will end up
!   # making a dummy file named 'D' -- because '-MD' means "put the output
!   # in D".
!   rm -rf conftest.dir
    mkdir conftest.dir
    # Copy depcomp to subdir because otherwise we won't find it if we're
    # using a relative directory.
*************** AC_CACHE_CHECK([dependency style of $dep
*** 229,244 ****
      : > sub/conftest.c
      for i in 1 2 3 4 5 6; do
        echo '#include "conftst'$i'.h"' >> sub/conftest.c
!       # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
!       # Solaris 8's {/usr,}/bin/sh.
!       touch sub/conftst$i.h
      done
      echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
  
!     # We check with `-c' and `-o' for the sake of the "dashmstdout"
      # mode.  It turns out that the SunPro C++ compiler does not properly
!     # handle `-M -o', and we need to detect this.  Also, some Intel
!     # versions had trouble with output in subdirs
      am__obj=sub/conftest.${OBJEXT-o}
      am__minus_obj="-o $am__obj"
      case $depmode in
--- 233,248 ----
      : > sub/conftest.c
      for i in 1 2 3 4 5 6; do
        echo '#include "conftst'$i'.h"' >> sub/conftest.c
!       # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
!       # Solaris 10 /bin/sh.
!       echo '/* dummy */' > sub/conftst$i.h
      done
      echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
  
!     # We check with '-c' and '-o' for the sake of the "dashmstdout"
      # mode.  It turns out that the SunPro C++ compiler does not properly
!     # handle '-M -o', and we need to detect this.  Also, some Intel
!     # versions had trouble with output in subdirs.
      am__obj=sub/conftest.${OBJEXT-o}
      am__minus_obj="-o $am__obj"
      case $depmode in
*************** AC_CACHE_CHECK([dependency style of $dep
*** 247,262 ****
        test "$am__universal" = false || continue
        ;;
      nosideeffect)
!       # after this tag, mechanisms are not by side-effect, so they'll
!       # only be used when explicitly requested
        if test "x$enable_dependency_tracking" = xyes; then
  	continue
        else
  	break
        fi
        ;;
!     msvisualcpp | msvcmsys)
!       # This compiler won't grok `-c -o', but also, the minuso test has
        # not run yet.  These depmodes are late enough in the game, and
        # so weak that their functioning should not be impacted.
        am__obj=conftest.${OBJEXT-o}
--- 251,266 ----
        test "$am__universal" = false || continue
        ;;
      nosideeffect)
!       # After this tag, mechanisms are not by side-effect, so they'll
!       # only be used when explicitly requested.
        if test "x$enable_dependency_tracking" = xyes; then
  	continue
        else
  	break
        fi
        ;;
!     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
!       # This compiler won't grok '-c -o', but also, the minuso test has
        # not run yet.  These depmodes are late enough in the game, and
        # so weak that their functioning should not be impacted.
        am__obj=conftest.${OBJEXT-o}
*************** AM_CONDITIONAL([am__fastdep$1], [
*** 304,310 ****
  # AM_SET_DEPDIR
  # -------------
  # Choose a directory name for dependency files.
! # This macro is AC_REQUIREd in _AM_DEPENDENCIES
  AC_DEFUN([AM_SET_DEPDIR],
  [AC_REQUIRE([AM_SET_LEADING_DOT])dnl
  AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
--- 308,314 ----
  # AM_SET_DEPDIR
  # -------------
  # Choose a directory name for dependency files.
! # This macro is AC_REQUIREd in _AM_DEPENDENCIES.
  AC_DEFUN([AM_SET_DEPDIR],
  [AC_REQUIRE([AM_SET_LEADING_DOT])dnl
  AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
*************** AC_SUBST([DEPDIR], ["${am__leading_dot}d
*** 314,341 ****
  # AM_DEP_TRACK
  # ------------
  AC_DEFUN([AM_DEP_TRACK],
! [AC_ARG_ENABLE(dependency-tracking,
! [  --disable-dependency-tracking  speeds up one-time build
!   --enable-dependency-tracking   do not reject slow dependency extractors])
  if test "x$enable_dependency_tracking" != xno; then
    am_depcomp="$ac_aux_dir/depcomp"
    AMDEPBACKSLASH='\'
  fi
  AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
  AC_SUBST([AMDEPBACKSLASH])dnl
  _AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
  ])
  
  # Generate code to set up dependency tracking.              -*- Autoconf -*-
  
! # Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
! # Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! #serial 5
  
  # _AM_OUTPUT_DEPENDENCY_COMMANDS
  # ------------------------------
--- 318,351 ----
  # AM_DEP_TRACK
  # ------------
  AC_DEFUN([AM_DEP_TRACK],
! [AC_ARG_ENABLE([dependency-tracking], [dnl
! AS_HELP_STRING(
!   [--enable-dependency-tracking],
!   [do not reject slow dependency extractors])
! AS_HELP_STRING(
!   [--disable-dependency-tracking],
!   [speeds up one-time build])])
  if test "x$enable_dependency_tracking" != xno; then
    am_depcomp="$ac_aux_dir/depcomp"
    AMDEPBACKSLASH='\'
+   am__nodep='_no'
  fi
  AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
  AC_SUBST([AMDEPBACKSLASH])dnl
  _AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
+ AC_SUBST([am__nodep])dnl
+ _AM_SUBST_NOTMAKE([am__nodep])dnl
  ])
  
  # Generate code to set up dependency tracking.              -*- Autoconf -*-
  
! # Copyright (C) 1999-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 6
  
  # _AM_OUTPUT_DEPENDENCY_COMMANDS
  # ------------------------------
*************** AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS
*** 354,360 ****
      # Strip MF so we end up with the name of the file.
      mf=`echo "$mf" | sed -e 's/:.*$//'`
      # Check whether this is an Automake generated Makefile or not.
!     # We used to match only the files named `Makefile.in', but
      # some people rename them; so instead we look at the file content.
      # Grep'ing the first line is not enough: some people post-process
      # each Makefile.in and add a new line on top of each file to say so.
--- 364,370 ----
      # Strip MF so we end up with the name of the file.
      mf=`echo "$mf" | sed -e 's/:.*$//'`
      # Check whether this is an Automake generated Makefile or not.
!     # We used to match only the files named 'Makefile.in', but
      # some people rename them; so instead we look at the file content.
      # Grep'ing the first line is not enough: some people post-process
      # each Makefile.in and add a new line on top of each file to say so.
*************** AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS
*** 366,386 ****
        continue
      fi
      # Extract the definition of DEPDIR, am__include, and am__quote
!     # from the Makefile without running `make'.
      DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
      test -z "$DEPDIR" && continue
      am__include=`sed -n 's/^am__include = //p' < "$mf"`
      test -z "am__include" && continue
      am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-     # When using ansi2knr, U may be empty or an underscore; expand it
-     U=`sed -n 's/^U = //p' < "$mf"`
      # Find all dependency output files, they are included files with
      # $(DEPDIR) in their names.  We invoke sed twice because it is the
      # simplest approach to changing $(DEPDIR) to its actual value in the
      # expansion.
      for file in `sed -n "
        s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
! 	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
        # Make sure the directory exists.
        test -f "$dirpart/$file" && continue
        fdir=`AS_DIRNAME(["$file"])`
--- 376,394 ----
        continue
      fi
      # Extract the definition of DEPDIR, am__include, and am__quote
!     # from the Makefile without running 'make'.
      DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
      test -z "$DEPDIR" && continue
      am__include=`sed -n 's/^am__include = //p' < "$mf"`
      test -z "am__include" && continue
      am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
      # Find all dependency output files, they are included files with
      # $(DEPDIR) in their names.  We invoke sed twice because it is the
      # simplest approach to changing $(DEPDIR) to its actual value in the
      # expansion.
      for file in `sed -n "
        s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
! 	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
        # Make sure the directory exists.
        test -f "$dirpart/$file" && continue
        fdir=`AS_DIRNAME(["$file"])`
*************** AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS
*** 398,404 ****
  # This macro should only be invoked once -- use via AC_REQUIRE.
  #
  # This code is only required when automatic dependency tracking
! # is enabled.  FIXME.  This creates each `.P' file that we will
  # need in order to bootstrap the dependency handling code.
  AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
  [AC_CONFIG_COMMANDS([depfiles],
--- 406,412 ----
  # This macro should only be invoked once -- use via AC_REQUIRE.
  #
  # This code is only required when automatic dependency tracking
! # is enabled.  FIXME.  This creates each '.P' file that we will
  # need in order to bootstrap the dependency handling code.
  AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
  [AC_CONFIG_COMMANDS([depfiles],
*************** AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS]
*** 408,421 ****
  
  # Do all the work for Automake.                             -*- Autoconf -*-
  
! # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
! # 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 16
  
  # This macro actually does too much.  Some checks are only needed if
  # your package does certain things.  But this isn't really a big deal.
--- 416,428 ----
  
  # Do all the work for Automake.                             -*- Autoconf -*-
  
! # Copyright (C) 1996-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 19
  
  # This macro actually does too much.  Some checks are only needed if
  # your package does certain things.  But this isn't really a big deal.
*************** AC_SUBST([CYGPATH_W])
*** 461,491 ****
  # Define the identity of the package.
  dnl Distinguish between old-style and new-style calls.
  m4_ifval([$2],
! [m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
   AC_SUBST([PACKAGE], [$1])dnl
   AC_SUBST([VERSION], [$2])],
  [_AM_SET_OPTIONS([$1])dnl
  dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
! m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
    [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
   AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
   AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
  
  _AM_IF_OPTION([no-define],,
! [AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
!  AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
  
  # Some tools Automake needs.
  AC_REQUIRE([AM_SANITY_CHECK])dnl
  AC_REQUIRE([AC_ARG_PROGRAM])dnl
! AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
! AM_MISSING_PROG(AUTOCONF, autoconf)
! AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
! AM_MISSING_PROG(AUTOHEADER, autoheader)
! AM_MISSING_PROG(MAKEINFO, makeinfo)
  AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
  AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
! AC_REQUIRE([AM_PROG_MKDIR_P])dnl
  # We need awk for the "check" target.  The system "awk" is bad on
  # some platforms.
  AC_REQUIRE([AC_PROG_AWK])dnl
--- 468,503 ----
  # Define the identity of the package.
  dnl Distinguish between old-style and new-style calls.
  m4_ifval([$2],
! [AC_DIAGNOSE([obsolete],
! [$0: two- and three-arguments forms are deprecated.  For more info, see:
! http://www.gnu.org/software/automake/manual/automake.html#Modernize-AM_INIT_AUTOMAKE-invocation])
! m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
   AC_SUBST([PACKAGE], [$1])dnl
   AC_SUBST([VERSION], [$2])],
  [_AM_SET_OPTIONS([$1])dnl
  dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
! m4_if(
!   m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),
!   [ok:ok],,
    [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
   AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
   AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
  
  _AM_IF_OPTION([no-define],,
! [AC_DEFINE_UNQUOTED([PACKAGE], ["$PACKAGE"], [Name of package])
!  AC_DEFINE_UNQUOTED([VERSION], ["$VERSION"], [Version number of package])])dnl
  
  # Some tools Automake needs.
  AC_REQUIRE([AM_SANITY_CHECK])dnl
  AC_REQUIRE([AC_ARG_PROGRAM])dnl
! AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])
! AM_MISSING_PROG([AUTOCONF], [autoconf])
! AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])
! AM_MISSING_PROG([AUTOHEADER], [autoheader])
! AM_MISSING_PROG([MAKEINFO], [makeinfo])
  AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
  AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
! AC_REQUIRE([AC_PROG_MKDIR_P])dnl
  # We need awk for the "check" target.  The system "awk" is bad on
  # some platforms.
  AC_REQUIRE([AC_PROG_AWK])dnl
*************** _AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR
*** 496,523 ****
  			     [_AM_PROG_TAR([v7])])])
  _AM_IF_OPTION([no-dependencies],,
  [AC_PROVIDE_IFELSE([AC_PROG_CC],
! 		  [_AM_DEPENDENCIES(CC)],
! 		  [define([AC_PROG_CC],
! 			  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
  AC_PROVIDE_IFELSE([AC_PROG_CXX],
! 		  [_AM_DEPENDENCIES(CXX)],
! 		  [define([AC_PROG_CXX],
! 			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
  AC_PROVIDE_IFELSE([AC_PROG_OBJC],
! 		  [_AM_DEPENDENCIES(OBJC)],
! 		  [define([AC_PROG_OBJC],
! 			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
  ])
  _AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl
! dnl The `parallel-tests' driver may need to know about EXEEXT, so add the
! dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
  dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.
  AC_CONFIG_COMMANDS_PRE(dnl
  [m4_provide_if([_AM_COMPILER_EXEEXT],
    [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
  ])
  
! dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
  dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
  dnl mangled by Autoconf and run in a shell conditional statement.
  m4_define([_AC_COMPILER_EXEEXT],
--- 508,542 ----
  			     [_AM_PROG_TAR([v7])])])
  _AM_IF_OPTION([no-dependencies],,
  [AC_PROVIDE_IFELSE([AC_PROG_CC],
! 		  [_AM_DEPENDENCIES([CC])],
! 		  [m4_define([AC_PROG_CC],
! 			     m4_defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl
  AC_PROVIDE_IFELSE([AC_PROG_CXX],
! 		  [_AM_DEPENDENCIES([CXX])],
! 		  [m4_define([AC_PROG_CXX],
! 			     m4_defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl
  AC_PROVIDE_IFELSE([AC_PROG_OBJC],
! 		  [_AM_DEPENDENCIES([OBJC])],
! 		  [m4_define([AC_PROG_OBJC],
! 			     m4_defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl
! dnl Support for Objective C++ was only introduced in Autoconf 2.65,
! dnl but we still cater to Autoconf 2.62.
! m4_ifdef([AC_PROG_OBJCXX],
! [AC_PROVIDE_IFELSE([AC_PROG_OBJCXX],
! 		  [_AM_DEPENDENCIES([OBJCXX])],
! 		  [m4_define([AC_PROG_OBJCXX],
! 			     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])])dnl
  ])
  _AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl
! dnl The 'parallel-tests' driver may need to know about EXEEXT, so add the
! dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
  dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.
  AC_CONFIG_COMMANDS_PRE(dnl
  [m4_provide_if([_AM_COMPILER_EXEEXT],
    [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
  ])
  
! dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
  dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
  dnl mangled by Autoconf and run in a shell conditional statement.
  m4_define([_AC_COMPILER_EXEEXT],
*************** for _am_header in $config_headers :; do
*** 545,556 ****
  done
  echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
  
! # Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
  # AM_PROG_INSTALL_SH
  # ------------------
  # Define $install_sh.
--- 564,577 ----
  done
  echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
  
! # Copyright (C) 2001-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
+ # serial 8
+ 
  # AM_PROG_INSTALL_SH
  # ------------------
  # Define $install_sh.
*************** if test x"${install_sh}" != xset; then
*** 564,572 ****
      install_sh="\${SHELL} $am_aux_dir/install-sh"
    esac
  fi
! AC_SUBST(install_sh)])
  
! # Copyright (C) 2003, 2005  Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
--- 585,593 ----
      install_sh="\${SHELL} $am_aux_dir/install-sh"
    esac
  fi
! AC_SUBST([install_sh])])
  
! # Copyright (C) 2003-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
*************** AC_SUBST([am__leading_dot])])
*** 589,601 ****
  
  # Check to see how 'make' treats includes.	            -*- Autoconf -*-
  
! # Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 4
  
  # AM_MAKE_INCLUDE()
  # -----------------
--- 610,622 ----
  
  # Check to see how 'make' treats includes.	            -*- Autoconf -*-
  
! # Copyright (C) 2001-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 5
  
  # AM_MAKE_INCLUDE()
  # -----------------
*************** am__quote=
*** 614,620 ****
  _am_result=none
  # First try GNU make style include.
  echo "include confinc" > confmf
! # Ignore all kinds of additional output from `make'.
  case `$am_make -s -f confmf 2> /dev/null` in #(
  *the\ am__doit\ target*)
    am__include=include
--- 635,641 ----
  _am_result=none
  # First try GNU make style include.
  echo "include confinc" > confmf
! # Ignore all kinds of additional output from 'make'.
  case `$am_make -s -f confmf 2> /dev/null` in #(
  *the\ am__doit\ target*)
    am__include=include
*************** AC_MSG_RESULT([$_am_result])
*** 639,646 ****
  rm -f confinc confmf
  ])
  
! # Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2008
! # Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
--- 660,666 ----
  rm -f confinc confmf
  ])
  
! # Copyright (C) 1999-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
*************** m4_define([AC_PROG_CC],
*** 676,689 ****
  
  # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
  
! # Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008
! # Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 6
  
  # AM_MISSING_PROG(NAME, PROGRAM)
  # ------------------------------
--- 696,708 ----
  
  # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
  
! # Copyright (C) 1997-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 7
  
  # AM_MISSING_PROG(NAME, PROGRAM)
  # ------------------------------
*************** if eval "$MISSING --run true"; then
*** 713,757 ****
    am_missing_run="$MISSING --run "
  else
    am_missing_run=
!   AC_MSG_WARN([`missing' script is too old or missing])
  fi
  ])
  
- # Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
- #
- # This file is free software; the Free Software Foundation
- # gives unlimited permission to copy and/or distribute it,
- # with or without modifications, as long as this notice is preserved.
- 
- # AM_PROG_MKDIR_P
- # ---------------
- # Check for `mkdir -p'.
- AC_DEFUN([AM_PROG_MKDIR_P],
- [AC_PREREQ([2.60])dnl
- AC_REQUIRE([AC_PROG_MKDIR_P])dnl
- dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,
- dnl while keeping a definition of mkdir_p for backward compatibility.
- dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.
- dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of
- dnl Makefile.ins that do not define MKDIR_P, so we do our own
- dnl adjustment using top_builddir (which is defined more often than
- dnl MKDIR_P).
- AC_SUBST([mkdir_p], ["$MKDIR_P"])dnl
- case $mkdir_p in
-   [[\\/$]]* | ?:[[\\/]]*) ;;
-   */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
- esac
- ])
- 
  # Helper functions for option handling.                     -*- Autoconf -*-
  
! # Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 4
  
  # _AM_MANGLE_OPTION(NAME)
  # -----------------------
--- 732,750 ----
    am_missing_run="$MISSING --run "
  else
    am_missing_run=
!   AC_MSG_WARN(['missing' script is too old or missing])
  fi
  ])
  
  # Helper functions for option handling.                     -*- Autoconf -*-
  
! # Copyright (C) 2001-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 6
  
  # _AM_MANGLE_OPTION(NAME)
  # -----------------------
*************** AC_DEFUN([_AM_MANGLE_OPTION],
*** 759,771 ****
  [[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
  
  # _AM_SET_OPTION(NAME)
! # ------------------------------
  # Set option NAME.  Presently that only means defining a flag for this option.
  AC_DEFUN([_AM_SET_OPTION],
! [m4_define(_AM_MANGLE_OPTION([$1]), 1)])
  
  # _AM_SET_OPTIONS(OPTIONS)
! # ----------------------------------
  # OPTIONS is a space-separated list of Automake options.
  AC_DEFUN([_AM_SET_OPTIONS],
  [m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
--- 752,764 ----
  [[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
  
  # _AM_SET_OPTION(NAME)
! # --------------------
  # Set option NAME.  Presently that only means defining a flag for this option.
  AC_DEFUN([_AM_SET_OPTION],
! [m4_define(_AM_MANGLE_OPTION([$1]), [1])])
  
  # _AM_SET_OPTIONS(OPTIONS)
! # ------------------------
  # OPTIONS is a space-separated list of Automake options.
  AC_DEFUN([_AM_SET_OPTIONS],
  [m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
*************** AC_DEFUN([_AM_IF_OPTION],
*** 778,799 ****
  
  # Check to make sure that the build environment is sane.    -*- Autoconf -*-
  
! # Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008
! # Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 5
  
  # AM_SANITY_CHECK
  # ---------------
  AC_DEFUN([AM_SANITY_CHECK],
  [AC_MSG_CHECKING([whether build environment is sane])
- # Just in case
- sleep 1
- echo timestamp > conftest.file
  # Reject unsafe characters in $srcdir or the absolute working directory
  # name.  Accept space and tab only in the latter.
  am_lf='
--- 771,788 ----
  
  # Check to make sure that the build environment is sane.    -*- Autoconf -*-
  
! # Copyright (C) 1996-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 9
  
  # AM_SANITY_CHECK
  # ---------------
  AC_DEFUN([AM_SANITY_CHECK],
  [AC_MSG_CHECKING([whether build environment is sane])
  # Reject unsafe characters in $srcdir or the absolute working directory
  # name.  Accept space and tab only in the latter.
  am_lf='
*************** case `pwd` in
*** 804,835 ****
  esac
  case $srcdir in
    *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
!     AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;
  esac
  
! # Do `set' in a subshell so we don't clobber the current shell's
  # arguments.  Must try -L first in case configure is actually a
  # symlink; some systems play weird games with the mod time of symlinks
  # (eg FreeBSD returns the mod time of the symlink's containing
  # directory).
  if (
!    set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
!    if test "$[*]" = "X"; then
!       # -L didn't work.
!       set X `ls -t "$srcdir/configure" conftest.file`
!    fi
!    rm -f conftest.file
!    if test "$[*]" != "X $srcdir/configure conftest.file" \
!       && test "$[*]" != "X conftest.file $srcdir/configure"; then
! 
!       # If neither matched, then we have a broken ls.  This can happen
!       # if, for instance, CONFIG_SHELL is bash and it inherits a
!       # broken ls alias from the environment.  This has actually
!       # happened.  Such a system could not be considered "sane".
!       AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
! alias in your environment])
!    fi
! 
     test "$[2]" = conftest.file
     )
  then
--- 793,832 ----
  esac
  case $srcdir in
    *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
!     AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;
  esac
  
! # Do 'set' in a subshell so we don't clobber the current shell's
  # arguments.  Must try -L first in case configure is actually a
  # symlink; some systems play weird games with the mod time of symlinks
  # (eg FreeBSD returns the mod time of the symlink's containing
  # directory).
  if (
!    am_has_slept=no
!    for am_try in 1 2; do
!      echo "timestamp, slept: $am_has_slept" > conftest.file
!      set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
!      if test "$[*]" = "X"; then
! 	# -L didn't work.
! 	set X `ls -t "$srcdir/configure" conftest.file`
!      fi
!      if test "$[*]" != "X $srcdir/configure conftest.file" \
! 	&& test "$[*]" != "X conftest.file $srcdir/configure"; then
! 
! 	# If neither matched, then we have a broken ls.  This can happen
! 	# if, for instance, CONFIG_SHELL is bash and it inherits a
! 	# broken ls alias from the environment.  This has actually
! 	# happened.  Such a system could not be considered "sane".
! 	AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
!   alias in your environment])
!      fi
!      if test "$[2]" = conftest.file || test $am_try -eq 2; then
!        break
!      fi
!      # Just in case.
!      sleep 1
!      am_has_slept=yes
!    done
     test "$[2]" = conftest.file
     )
  then
*************** else
*** 839,881 ****
     AC_MSG_ERROR([newly created file is older than distributed files!
  Check your system clock])
  fi
! AC_MSG_RESULT(yes)])
  
! # Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
  # AM_PROG_INSTALL_STRIP
  # ---------------------
! # One issue with vendor `install' (even GNU) is that you can't
  # specify the program used to strip binaries.  This is especially
  # annoying in cross-compiling environments, where the build's strip
  # is unlikely to handle the host's binaries.
  # Fortunately install-sh will honor a STRIPPROG variable, so we
! # always use install-sh in `make install-strip', and initialize
  # STRIPPROG with the value of the STRIP variable (set by the user).
  AC_DEFUN([AM_PROG_INSTALL_STRIP],
  [AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
! # Installed binaries are usually stripped using `strip' when the user
! # run `make install-strip'.  However `strip' might not be the right
  # tool to use in cross-compilation environments, therefore Automake
! # will honor the `STRIP' environment variable to overrule this program.
! dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
  if test "$cross_compiling" != no; then
    AC_CHECK_TOOL([STRIP], [strip], :)
  fi
  INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
  AC_SUBST([INSTALL_STRIP_PROGRAM])])
  
! # Copyright (C) 2006, 2008  Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 2
  
  # _AM_SUBST_NOTMAKE(VARIABLE)
  # ---------------------------
--- 836,896 ----
     AC_MSG_ERROR([newly created file is older than distributed files!
  Check your system clock])
  fi
! AC_MSG_RESULT([yes])
! # If we didn't sleep, we still need to ensure time stamps of config.status and
! # generated files are strictly newer.
! am_sleep_pid=
! if grep 'slept: no' conftest.file >/dev/null 2>&1; then
!   ( sleep 1 ) &
!   am_sleep_pid=$!
! fi
! AC_CONFIG_COMMANDS_PRE(
!   [AC_MSG_CHECKING([that generated files are newer than configure])
!    if test -n "$am_sleep_pid"; then
!      # Hide warnings about reused PIDs.
!      wait $am_sleep_pid 2>/dev/null
!    fi
!    AC_MSG_RESULT([done])])
! rm -f conftest.file
! ])
  
! # Copyright (C) 2001-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
+ # serial 2
+ 
  # AM_PROG_INSTALL_STRIP
  # ---------------------
! # One issue with vendor 'install' (even GNU) is that you can't
  # specify the program used to strip binaries.  This is especially
  # annoying in cross-compiling environments, where the build's strip
  # is unlikely to handle the host's binaries.
  # Fortunately install-sh will honor a STRIPPROG variable, so we
! # always use install-sh in "make install-strip", and initialize
  # STRIPPROG with the value of the STRIP variable (set by the user).
  AC_DEFUN([AM_PROG_INSTALL_STRIP],
  [AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
! # Installed binaries are usually stripped using 'strip' when the user
! # run "make install-strip".  However 'strip' might not be the right
  # tool to use in cross-compilation environments, therefore Automake
! # will honor the 'STRIP' environment variable to overrule this program.
! dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.
  if test "$cross_compiling" != no; then
    AC_CHECK_TOOL([STRIP], [strip], :)
  fi
  INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
  AC_SUBST([INSTALL_STRIP_PROGRAM])])
  
! # Copyright (C) 2006-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 3
  
  # _AM_SUBST_NOTMAKE(VARIABLE)
  # ---------------------------
*************** AC_SUBST([INSTALL_STRIP_PROGRAM])])
*** 884,907 ****
  AC_DEFUN([_AM_SUBST_NOTMAKE])
  
  # AM_SUBST_NOTMAKE(VARIABLE)
! # ---------------------------
  # Public sister of _AM_SUBST_NOTMAKE.
  AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
  
  # Check how to create a tarball.                            -*- Autoconf -*-
  
! # Copyright (C) 2004, 2005  Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 2
  
  # _AM_PROG_TAR(FORMAT)
  # --------------------
  # Check how to create a tarball in format FORMAT.
! # FORMAT should be one of `v7', `ustar', or `pax'.
  #
  # Substitute a variable $(am__tar) that is a command
  # writing to stdout a FORMAT-tarball containing the directory
--- 899,922 ----
  AC_DEFUN([_AM_SUBST_NOTMAKE])
  
  # AM_SUBST_NOTMAKE(VARIABLE)
! # --------------------------
  # Public sister of _AM_SUBST_NOTMAKE.
  AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
  
  # Check how to create a tarball.                            -*- Autoconf -*-
  
! # Copyright (C) 2004-2012 Free Software Foundation, Inc.
  #
  # This file is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.
  
! # serial 3
  
  # _AM_PROG_TAR(FORMAT)
  # --------------------
  # Check how to create a tarball in format FORMAT.
! # FORMAT should be one of 'v7', 'ustar', or 'pax'.
  #
  # Substitute a variable $(am__tar) that is a command
  # writing to stdout a FORMAT-tarball containing the directory
*************** AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_
*** 912,921 ****
  # a tarball read from stdin.
  #     $(am__untar) < result.tar
  AC_DEFUN([_AM_PROG_TAR],
! [# Always define AMTAR for backward compatibility.
! AM_MISSING_PROG([AMTAR], [tar])
  m4_if([$1], [v7],
!      [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
       [m4_case([$1], [ustar],, [pax],,
                [m4_fatal([Unknown tar format])])
  AC_MSG_CHECKING([how to create a $1 tar archive])
--- 927,937 ----
  # a tarball read from stdin.
  #     $(am__untar) < result.tar
  AC_DEFUN([_AM_PROG_TAR],
! [# Always define AMTAR for backward compatibility.  Yes, it's still used
! # in the wild :-(  We should find a proper way to deprecate it ...
! AC_SUBST([AMTAR], ['$${TAR-tar}'])
  m4_if([$1], [v7],
!      [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],
       [m4_case([$1], [ustar],, [pax],,
                [m4_fatal([Unknown tar format])])
  AC_MSG_CHECKING([how to create a $1 tar archive])
*************** AC_MSG_CHECKING([how to create a $1 tar 
*** 923,929 ****
  _am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
  _am_tools=${am_cv_prog_tar_$1-$_am_tools}
  # Do not fold the above two line into one, because Tru64 sh and
! # Solaris sh will not grok spaces in the rhs of `-'.
  for _am_tool in $_am_tools
  do
    case $_am_tool in
--- 939,945 ----
  _am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
  _am_tools=${am_cv_prog_tar_$1-$_am_tools}
  # Do not fold the above two line into one, because Tru64 sh and
! # Solaris sh will not grok spaces in the rhs of '-'.
  for _am_tool in $_am_tools
  do
    case $_am_tool in
*************** m4_include([m4/gl-comp.m4])
*** 996,1002 ****
  m4_include([m4/gnulib-common.m4])
  m4_include([m4/include_next.m4])
  m4_include([m4/inttypes.m4])
- m4_include([m4/largefile.m4])
  m4_include([m4/longlong.m4])
  m4_include([m4/lstat.m4])
  m4_include([m4/md5.m4])
--- 1012,1017 ----

=== modified file 'src/config.in'
*** src/config.in	2012-01-19 07:21:25 +0000
--- src/config.in	2012-05-17 03:16:09 +0000
*************** along with GNU Emacs.  If not, see <http
*** 118,123 ****
--- 118,126 ----
  /* Define to 1 if GCC-style __attribute__ ((__aligned__ (expr))) works. */
  #undef HAVE_ATTRIBUTE_ALIGNED
  
+ /* Define to 1 if you have the <AvailabilityMacros.h> header file. */
+ #undef HAVE_AVAILABILITYMACROS_H
+ 
  /* Define to 1 if strtold conforms to C99. */
  #undef HAVE_C99_STRTOLD
  
*************** along with GNU Emacs.  If not, see <http
*** 504,509 ****
--- 507,515 ----
  /* Define to 1 if using libm17n-flt. */
  #undef HAVE_M17N_FLT
  
+ /* Define to 1 if you are using GUI on Mac OS X. */
+ #undef HAVE_MACGUI
+ 
  /* Define to 1 if you have the <machine/soundcard.h> header file. */
  #undef HAVE_MACHINE_SOUNDCARD_H
  
*************** along with GNU Emacs.  If not, see <http
*** 1062,1070 ****
  /* If using the C implementation of alloca, define if you know the
     direction of stack growth for your system; otherwise it will be
     automatically deduced at runtime.
!         STACK_DIRECTION > 0 => grows toward higher addresses
!         STACK_DIRECTION < 0 => grows toward lower addresses
!         STACK_DIRECTION = 0 => direction of growth unknown */
  #undef STACK_DIRECTION
  
  /* Define to 1 if the `S_IS*' macros in <sys/stat.h> do not work properly. */
--- 1068,1076 ----
  /* If using the C implementation of alloca, define if you know the
     direction of stack growth for your system; otherwise it will be
     automatically deduced at runtime.
! 	STACK_DIRECTION > 0 => grows toward higher addresses
! 	STACK_DIRECTION < 0 => grows toward lower addresses
! 	STACK_DIRECTION = 0 => direction of growth unknown */
  #undef STACK_DIRECTION
  
  /* Define to 1 if the `S_IS*' macros in <sys/stat.h> do not work properly. */
*************** along with GNU Emacs.  If not, see <http
*** 1107,1112 ****
--- 1113,1121 ----
  /* Define to 1 if using the Lucid X toolkit. */
  #undef USE_LUCID
  
+ /* Define if use the Image I/O framework for reading images. */
+ #undef USE_MAC_IMAGE_IO
+ 
  /* Define to use mmap to allocate buffer text. */
  #undef USE_MMAP_FOR_BUFFERS
  
*************** along with GNU Emacs.  If not, see <http
*** 1155,1161 ****
     XPointer or XPointer*. */
  #undef XRegisterIMInstantiateCallback_arg6
  
! /* Enable large inode numbers on Mac OS X.  */
  #ifndef _DARWIN_USE_64_BIT_INODE
  # define _DARWIN_USE_64_BIT_INODE 1
  #endif
--- 1164,1170 ----
     XPointer or XPointer*. */
  #undef XRegisterIMInstantiateCallback_arg6
  
! /* Enable large inode numbers on Mac OS X 10.5.  */
  #ifndef _DARWIN_USE_64_BIT_INODE
  # define _DARWIN_USE_64_BIT_INODE 1
  #endif

=== modified file 'configure'
*** configure	2012-06-01 11:18:14 +0000
--- configure	2012-06-10 07:58:38 +0000
***************
*** 1,11 ****
  #! /bin/sh
  # Guess values for system-dependent variables and create Makefiles.
! # Generated by GNU Autoconf 2.68 for emacs 24.1.
  #
  #
! # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
! # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
! # Foundation, Inc.
  #
  #
  # This configure script is free software; the Free Software Foundation
--- 1,9 ----
  #! /bin/sh
  # Guess values for system-dependent variables and create Makefiles.
! # Generated by GNU Autoconf 2.69 for emacs 24.1.
  #
  #
! # Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
  #
  #
  # This configure script is free software; the Free Software Foundation
*************** export LANGUAGE
*** 134,139 ****
--- 132,162 ----
  # CDPATH.
  (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
  
+ # Use a proper internal environment variable to ensure we don't fall
+   # into an infinite loop, continuously re-executing ourselves.
+   if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+     _as_can_reexec=no; export _as_can_reexec;
+     # We cannot yet assume a decent shell, so we have to provide a
+ # neutralization value for shells without unset; and this also
+ # works around shells that cannot unset nonexistent variables.
+ # Preserve -v and -x to the replacement shell.
+ BASH_ENV=/dev/null
+ ENV=/dev/null
+ (unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+ case $- in # ((((
+   *v*x* | *x*v* ) as_opts=-vx ;;
+   *v* ) as_opts=-v ;;
+   *x* ) as_opts=-x ;;
+   * ) as_opts= ;;
+ esac
+ exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+ # Admittedly, this is quite paranoid, since all the known shells bail
+ # out after a failed `exec'.
+ $as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+ as_fn_exit 255
+   fi
+   # We don't want this to propagate to other subprocesses.
+           { _as_can_reexec=; unset _as_can_reexec;}
  if test "x$CONFIG_SHELL" = x; then
    as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
    emulate sh
*************** if ( set x; as_fn_ret_success y && test 
*** 167,173 ****
  else
    exitcode=1; echo positional parameters were not saved.
  fi
! test x\$exitcode = x0 || exit 1"
    as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
    as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
    eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
--- 190,197 ----
  else
    exitcode=1; echo positional parameters were not saved.
  fi
! test x\$exitcode = x0 || exit 1
! test -x / || exit 1"
    as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
    as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
    eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
*************** IFS=$as_save_IFS
*** 212,232 ****
  
  
        if test "x$CONFIG_SHELL" != x; then :
!   # We cannot yet assume a decent shell, so we have to provide a
! 	# neutralization value for shells without unset; and this also
! 	# works around shells that cannot unset nonexistent variables.
! 	# Preserve -v and -x to the replacement shell.
! 	BASH_ENV=/dev/null
! 	ENV=/dev/null
! 	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
! 	export CONFIG_SHELL
! 	case $- in # ((((
! 	  *v*x* | *x*v* ) as_opts=-vx ;;
! 	  *v* ) as_opts=-v ;;
! 	  *x* ) as_opts=-x ;;
! 	  * ) as_opts= ;;
! 	esac
! 	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
  fi
  
      if test x$as_have_required = xno; then :
--- 236,260 ----
  
  
        if test "x$CONFIG_SHELL" != x; then :
!   export CONFIG_SHELL
!              # We cannot yet assume a decent shell, so we have to provide a
! # neutralization value for shells without unset; and this also
! # works around shells that cannot unset nonexistent variables.
! # Preserve -v and -x to the replacement shell.
! BASH_ENV=/dev/null
! ENV=/dev/null
! (unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
! case $- in # ((((
!   *v*x* | *x*v* ) as_opts=-vx ;;
!   *v* ) as_opts=-v ;;
!   *x* ) as_opts=-x ;;
!   * ) as_opts= ;;
! esac
! exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
! # Admittedly, this is quite paranoid, since all the known shells bail
! # out after a failed `exec'.
! $as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
! exit 255
  fi
  
      if test x$as_have_required = xno; then :
*************** $as_echo X"$as_dir" |
*** 328,333 ****
--- 356,369 ----
  
  
  } # as_fn_mkdir_p
+ 
+ # as_fn_executable_p FILE
+ # -----------------------
+ # Test if FILE is an executable regular file.
+ as_fn_executable_p ()
+ {
+   test -f "$1" && test -x "$1"
+ } # as_fn_executable_p
  # as_fn_append VAR VALUE
  # ----------------------
  # Append the text in VALUE to the end of the definition contained in VAR. Take
*************** as_cr_alnum=$as_cr_Letters$as_cr_digits
*** 449,454 ****
--- 485,494 ----
    chmod +x "$as_me.lineno" ||
      { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
  
+   # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+   # already done that, so ensure we don't try to do so again and fall
+   # in an infinite loop.  This has already happened in practice.
+   _as_can_reexec=no; export _as_can_reexec
    # Don't try to exec as it changes $[0], causing all sort of problems
    # (the dirname of $[0] is not the place where we might find the
    # original and so on.  Autoconf is especially sensitive to this).
*************** if (echo >conf$$.file) 2>/dev/null; then
*** 483,498 ****
      # ... but there are two gotchas:
      # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
      # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
!     # In both cases, we have to default to `cp -p'.
      ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
!       as_ln_s='cp -p'
    elif ln conf$$.file conf$$ 2>/dev/null; then
      as_ln_s=ln
    else
!     as_ln_s='cp -p'
    fi
  else
!   as_ln_s='cp -p'
  fi
  rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
  rmdir conf$$.dir 2>/dev/null
--- 523,538 ----
      # ... but there are two gotchas:
      # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
      # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
!     # In both cases, we have to default to `cp -pR'.
      ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
!       as_ln_s='cp -pR'
    elif ln conf$$.file conf$$ 2>/dev/null; then
      as_ln_s=ln
    else
!     as_ln_s='cp -pR'
    fi
  else
!   as_ln_s='cp -pR'
  fi
  rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
  rmdir conf$$.dir 2>/dev/null
*************** else
*** 504,531 ****
    as_mkdir_p=false
  fi
  
! if test -x / >/dev/null 2>&1; then
!   as_test_x='test -x'
! else
!   if ls -dL / >/dev/null 2>&1; then
!     as_ls_L_option=L
!   else
!     as_ls_L_option=
!   fi
!   as_test_x='
!     eval sh -c '\''
!       if test -d "$1"; then
! 	test -d "$1/.";
!       else
! 	case $1 in #(
! 	-*)set "./$1";;
! 	esac;
! 	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
! 	???[sx]*):;;*)false;;esac;fi
!     '\'' sh
!   '
! fi
! as_executable_p=$as_test_x
  
  # Sed expression to map a string onto a valid CPP name.
  as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
--- 544,551 ----
    as_mkdir_p=false
  fi
  
! as_test_x='test -x'
! as_executable_p=as_fn_executable_p
  
  # Sed expression to map a string onto a valid CPP name.
  as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
*************** ns_appsrc
*** 1092,1097 ****
--- 1112,1118 ----
  ns_appresdir
  ns_appbindir
  ns_appdir
+ mac_appdir
  S_FILE
  M_FILE
  X_TOOLKIT_TYPE
*************** HAVE_XSERVER
*** 1170,1175 ****
--- 1191,1198 ----
  LIB_STANDARD
  NS_OBJC_OBJ
  NS_OBJ
+ MAC_OBJC_OBJ
+ MAC_OBJ
  TEMACS_LDFLAGS2
  LD_SWITCH_X_SITE_AUX_RPATH
  LD_SWITCH_X_SITE_AUX
*************** CPP
*** 1203,1208 ****
--- 1226,1232 ----
  am__fastdepCC_FALSE
  am__fastdepCC_TRUE
  CCDEPMODE
+ am__nodep
  AMDEPBACKSLASH
  AMDEP_FALSE
  AMDEP_TRUE
*************** AMTAR
*** 1234,1240 ****
  am__leading_dot
  SET_MAKE
  AWK
- mkdir_p
  MKDIR_P
  INSTALL_STRIP_PROGRAM
  STRIP
--- 1258,1263 ----
*************** PATH_SEPARATOR
*** 1291,1296 ****
--- 1314,1320 ----
  SHELL'
  ac_subst_files='deps_frag
  lisp_frag
+ mac_frag
  ns_frag'
  ac_user_opts='
  enable_option_checking
*************** with_m17n_flt
*** 1319,1324 ****
--- 1343,1349 ----
  with_toolkit_scroll_bars
  with_xaw3d
  with_xim
+ with_mac
  with_ns
  with_gpm
  with_dbus
*************** with_compress_info
*** 1331,1336 ****
--- 1356,1362 ----
  with_pkg_config_prog
  with_crt_dir
  with_gameuser
+ enable_mac_app
  with_gnustep_conf
  enable_ns_self_contained
  enable_asserts
*************** target=$target_alias
*** 1809,1816 ****
  if test "x$host_alias" != x; then
    if test "x$build_alias" = x; then
      cross_compiling=maybe
-     $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
-     If a cross compiler is detected then cross compile mode will be used" >&2
    elif test "x$build_alias" != "x$host_alias"; then
      cross_compiling=yes
    fi
--- 1835,1840 ----
*************** Optional Features:
*** 1978,1983 ****
--- 2002,2009 ----
    --disable-option-checking  ignore unrecognized --enable/--with options
    --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
    --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+   --enable-mac-app[=DIR]  specify install directory for Emacs.app on Mac OS X
+                           [DIR=/Application]
    --disable-ns-self-contained
                            disable self contained build under NeXTstep
    --enable-asserts        compile code with asserts enabled
*************** Optional Features:
*** 2001,2008 ****
    --enable-autodepend     automatically generate dependencies to .h-files.
                            Requires GNU Make and Gcc. Enabled if GNU Make and
                            Gcc is found
!   --disable-dependency-tracking  speeds up one-time build
!   --enable-dependency-tracking   do not reject slow dependency extractors
    --disable-largefile     omit support for large files
  
  Optional Packages:
--- 2027,2036 ----
    --enable-autodepend     automatically generate dependencies to .h-files.
                            Requires GNU Make and Gcc. Enabled if GNU Make and
                            Gcc is found
!   --enable-dependency-tracking
!                           do not reject slow dependency extractors
!   --disable-dependency-tracking
!                           speeds up one-time build
    --disable-largefile     omit support for large files
  
  Optional Packages:
*************** Optional Packages:
*** 2036,2041 ****
--- 2064,2070 ----
                            don't use Motif or Xaw3d scroll bars
    --without-xaw3d         don't use Xaw3d
    --without-xim           don't use X11 XIM
+   --with-mac              use GUI on Mac OS X.
    --with-ns               use NeXTstep (Cocoa or GNUstep) windowing system
    --without-gpm           don't use -lgpm for mouse support on a GNU/Linux
                            console
*************** test -n "$ac_init_help" && exit $ac_stat
*** 2134,2142 ****
  if $ac_init_version; then
    cat <<\_ACEOF
  emacs configure 24.1
! generated by GNU Autoconf 2.68
  
! Copyright (C) 2010 Free Software Foundation, Inc.
  This configure script is free software; the Free Software Foundation
  gives unlimited permission to copy, distribute and modify it.
  _ACEOF
--- 2163,2171 ----
  if $ac_init_version; then
    cat <<\_ACEOF
  emacs configure 24.1
! generated by GNU Autoconf 2.69
  
! Copyright (C) 2012 Free Software Foundation, Inc.
  This configure script is free software; the Free Software Foundation
  gives unlimited permission to copy, distribute and modify it.
  _ACEOF
*************** $as_echo "$ac_try_echo"; } >&5
*** 2409,2415 ****
  	 test ! -s conftest.err
         } && test -s conftest$ac_exeext && {
  	 test "$cross_compiling" = yes ||
! 	 $as_test_x conftest$ac_exeext
         }; then :
    ac_retval=0
  else
--- 2438,2444 ----
  	 test ! -s conftest.err
         } && test -s conftest$ac_exeext && {
  	 test "$cross_compiling" = yes ||
! 	 test -x conftest$ac_exeext
         }; then :
    ac_retval=0
  else
*************** int
*** 2698,2704 ****
  main ()
  {
  static int test_array [1 - 2 * !(($2) >= 0)];
! test_array [0] = 0
  
    ;
    return 0;
--- 2727,2734 ----
  main ()
  {
  static int test_array [1 - 2 * !(($2) >= 0)];
! test_array [0] = 0;
! return test_array [0];
  
    ;
    return 0;
*************** int
*** 2714,2720 ****
  main ()
  {
  static int test_array [1 - 2 * !(($2) <= $ac_mid)];
! test_array [0] = 0
  
    ;
    return 0;
--- 2744,2751 ----
  main ()
  {
  static int test_array [1 - 2 * !(($2) <= $ac_mid)];
! test_array [0] = 0;
! return test_array [0];
  
    ;
    return 0;
*************** int
*** 2740,2746 ****
  main ()
  {
  static int test_array [1 - 2 * !(($2) < 0)];
! test_array [0] = 0
  
    ;
    return 0;
--- 2771,2778 ----
  main ()
  {
  static int test_array [1 - 2 * !(($2) < 0)];
! test_array [0] = 0;
! return test_array [0];
  
    ;
    return 0;
*************** int
*** 2756,2762 ****
  main ()
  {
  static int test_array [1 - 2 * !(($2) >= $ac_mid)];
! test_array [0] = 0
  
    ;
    return 0;
--- 2788,2795 ----
  main ()
  {
  static int test_array [1 - 2 * !(($2) >= $ac_mid)];
! test_array [0] = 0;
! return test_array [0];
  
    ;
    return 0;
*************** int
*** 2790,2796 ****
  main ()
  {
  static int test_array [1 - 2 * !(($2) <= $ac_mid)];
! test_array [0] = 0
  
    ;
    return 0;
--- 2823,2830 ----
  main ()
  {
  static int test_array [1 - 2 * !(($2) <= $ac_mid)];
! test_array [0] = 0;
! return test_array [0];
  
    ;
    return 0;
*************** This file contains any messages produced
*** 2863,2869 ****
  running configure, to aid debugging if configure makes a mistake.
  
  It was created by emacs $as_me 24.1, which was
! generated by GNU Autoconf 2.68.  Invocation command line was
  
    $ $0 $@
  
--- 2897,2903 ----
  running configure, to aid debugging if configure makes a mistake.
  
  It was created by emacs $as_me 24.1, which was
! generated by GNU Autoconf 2.69.  Invocation command line was
  
    $ $0 $@
  
*************** ac_config_sub="$SHELL $ac_aux_dir/config
*** 3263,3269 ****
  ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
  
  
! am__api_version='1.11'
  
  # Find a good install program.  We prefer a C program (faster),
  # so one script is as good as another.  But avoid the broken or
--- 3297,3303 ----
  ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
  
  
! am__api_version='1.12'
  
  # Find a good install program.  We prefer a C program (faster),
  # so one script is as good as another.  But avoid the broken or
*************** case $as_dir/ in #((
*** 3302,3308 ****
      # by default.
      for ac_prog in ginstall scoinst install; do
        for ac_exec_ext in '' $ac_executable_extensions; do
! 	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
  	  if test $ac_prog = install &&
  	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
  	    # AIX install.  It has an incompatible calling convention.
--- 3336,3342 ----
      # by default.
      for ac_prog in ginstall scoinst install; do
        for ac_exec_ext in '' $ac_executable_extensions; do
! 	if as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
  	  if test $ac_prog = install &&
  	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
  	    # AIX install.  It has an incompatible calling convention.
*************** test -z "$INSTALL_DATA" && INSTALL_DATA=
*** 3360,3368 ****
  
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
  $as_echo_n "checking whether build environment is sane... " >&6; }
- # Just in case
- sleep 1
- echo timestamp > conftest.file
  # Reject unsafe characters in $srcdir or the absolute working directory
  # name.  Accept space and tab only in the latter.
  am_lf='
--- 3394,3399 ----
*************** case `pwd` in
*** 3373,3404 ****
  esac
  case $srcdir in
    *[\\\"\#\$\&\'\`$am_lf\ \	]*)
!     as_fn_error $? "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
  esac
  
! # Do `set' in a subshell so we don't clobber the current shell's
  # arguments.  Must try -L first in case configure is actually a
  # symlink; some systems play weird games with the mod time of symlinks
  # (eg FreeBSD returns the mod time of the symlink's containing
  # directory).
  if (
!    set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
!    if test "$*" = "X"; then
!       # -L didn't work.
!       set X `ls -t "$srcdir/configure" conftest.file`
!    fi
!    rm -f conftest.file
!    if test "$*" != "X $srcdir/configure conftest.file" \
!       && test "$*" != "X conftest.file $srcdir/configure"; then
! 
!       # If neither matched, then we have a broken ls.  This can happen
!       # if, for instance, CONFIG_SHELL is bash and it inherits a
!       # broken ls alias from the environment.  This has actually
!       # happened.  Such a system could not be considered "sane".
!       as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
! alias in your environment" "$LINENO" 5
!    fi
  
     test "$2" = conftest.file
     )
  then
--- 3404,3443 ----
  esac
  case $srcdir in
    *[\\\"\#\$\&\'\`$am_lf\ \	]*)
!     as_fn_error $? "unsafe srcdir value: '$srcdir'" "$LINENO" 5;;
  esac
  
! # Do 'set' in a subshell so we don't clobber the current shell's
  # arguments.  Must try -L first in case configure is actually a
  # symlink; some systems play weird games with the mod time of symlinks
  # (eg FreeBSD returns the mod time of the symlink's containing
  # directory).
  if (
!    am_has_slept=no
!    for am_try in 1 2; do
!      echo "timestamp, slept: $am_has_slept" > conftest.file
!      set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
!      if test "$*" = "X"; then
! 	# -L didn't work.
! 	set X `ls -t "$srcdir/configure" conftest.file`
!      fi
!      if test "$*" != "X $srcdir/configure conftest.file" \
! 	&& test "$*" != "X conftest.file $srcdir/configure"; then
  
+ 	# If neither matched, then we have a broken ls.  This can happen
+ 	# if, for instance, CONFIG_SHELL is bash and it inherits a
+ 	# broken ls alias from the environment.  This has actually
+ 	# happened.  Such a system could not be considered "sane".
+ 	as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
+   alias in your environment" "$LINENO" 5
+      fi
+      if test "$2" = conftest.file || test $am_try -eq 2; then
+        break
+      fi
+      # Just in case.
+      sleep 1
+      am_has_slept=yes
+    done
     test "$2" = conftest.file
     )
  then
*************** Check your system clock" "$LINENO" 5
*** 3410,3415 ****
--- 3449,3464 ----
  fi
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
  $as_echo "yes" >&6; }
+ # If we didn't sleep, we still need to ensure time stamps of config.status and
+ # generated files are strictly newer.
+ am_sleep_pid=
+ if grep 'slept: no' conftest.file >/dev/null 2>&1; then
+   ( sleep 1 ) &
+   am_sleep_pid=$!
+ fi
+ 
+ rm -f conftest.file
+ 
  test "$program_prefix" != NONE &&
    program_transform_name="s&^&$program_prefix&;$program_transform_name"
  # Use a double $ so make ignores it.
*************** if eval "$MISSING --run true"; then
*** 3436,3443 ****
    am_missing_run="$MISSING --run "
  else
    am_missing_run=
!   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
! $as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
  fi
  
  if test x"${install_sh}" != xset; then
--- 3485,3492 ----
    am_missing_run="$MISSING --run "
  else
    am_missing_run=
!   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: 'missing' script is too old or missing" >&5
! $as_echo "$as_me: WARNING: 'missing' script is too old or missing" >&2;}
  fi
  
  if test x"${install_sh}" != xset; then
*************** if test x"${install_sh}" != xset; then
*** 3449,3458 ****
    esac
  fi
  
! # Installed binaries are usually stripped using `strip' when the user
! # run `make install-strip'.  However `strip' might not be the right
  # tool to use in cross-compilation environments, therefore Automake
! # will honor the `STRIP' environment variable to overrule this program.
  if test "$cross_compiling" != no; then
    if test -n "$ac_tool_prefix"; then
    # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
--- 3498,3507 ----
    esac
  fi
  
! # Installed binaries are usually stripped using 'strip' when the user
! # run "make install-strip".  However 'strip' might not be the right
  # tool to use in cross-compilation environments, therefore Automake
! # will honor the 'STRIP' environment variable to overrule this program.
  if test "$cross_compiling" != no; then
    if test -n "$ac_tool_prefix"; then
    # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
*************** do
*** 3471,3477 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_STRIP="${ac_tool_prefix}strip"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 3520,3526 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_STRIP="${ac_tool_prefix}strip"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 3511,3517 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_ac_ct_STRIP="strip"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 3560,3566 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_ac_ct_STRIP="strip"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 3562,3568 ****
    test -z "$as_dir" && as_dir=.
      for ac_prog in mkdir gmkdir; do
  	 for ac_exec_ext in '' $ac_executable_extensions; do
! 	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
  	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
  	     'mkdir (GNU coreutils) '* | \
  	     'mkdir (coreutils) '* | \
--- 3611,3617 ----
    test -z "$as_dir" && as_dir=.
      for ac_prog in mkdir gmkdir; do
  	 for ac_exec_ext in '' $ac_executable_extensions; do
! 	   as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext" || continue
  	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
  	     'mkdir (GNU coreutils) '* | \
  	     'mkdir (coreutils) '* | \
*************** fi
*** 3592,3603 ****
  $as_echo "$MKDIR_P" >&6; }
  
  
- mkdir_p="$MKDIR_P"
- case $mkdir_p in
-   [\\/$]* | ?:[\\/]*) ;;
-   */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
- esac
- 
  for ac_prog in gawk mawk nawk awk
  do
    # Extract the first word of "$ac_prog", so it can be a program name with args.
--- 3641,3646 ----
*************** do
*** 3616,3622 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_AWK="$ac_prog"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 3659,3665 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_AWK="$ac_prog"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** MAKEINFO=${MAKEINFO-"${am_missing_run}ma
*** 3732,3742 ****
  
  # We need awk for the "check" target.  The system "awk" is bad on
  # some platforms.
! # Always define AMTAR for backward compatibility.
! 
! AMTAR=${AMTAR-"${am_missing_run}tar"}
  
! am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
  
  
  
--- 3775,3785 ----
  
  # We need awk for the "check" target.  The system "awk" is bad on
  # some platforms.
! # Always define AMTAR for backward compatibility.  Yes, it's still used
! # in the wild :-(  We should find a proper way to deprecate it ...
! AMTAR='$${TAR-tar}'
  
! am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
  
  
  
*************** else
*** 4028,4033 ****
--- 4071,4084 ----
  fi
  
  
+ # Check whether --with-mac was given.
+ if test "${with_mac+set}" = set; then :
+   withval=$with_mac;
+ else
+       with_mac=no
+ fi
+ 
+ 
  # Check whether --with-ns was given.
  if test "${with_ns+set}" = set; then :
    withval=$with_ns;
*************** test "X${with_gameuser}" != X && test "$
*** 4147,4152 ****
--- 4198,4209 ----
    && gameuser="${with_gameuser}"
  test "X$gameuser" = X && gameuser=games
  
+ # Check whether --enable-mac-app was given.
+ if test "${enable_mac_app+set}" = set; then :
+   enableval=$enable_mac_app;  mac_appdir_x=${enableval}
+ fi
+ 
+ 
  
  # Check whether --with-gnustep-conf was given.
  if test "${with_gnustep_conf+set}" = set; then :
*************** do
*** 4660,4666 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_CC="${ac_tool_prefix}gcc"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 4717,4723 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_CC="${ac_tool_prefix}gcc"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 4700,4706 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_ac_ct_CC="gcc"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 4757,4763 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_ac_ct_CC="gcc"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 4753,4759 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_CC="${ac_tool_prefix}cc"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 4810,4816 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_CC="${ac_tool_prefix}cc"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 4794,4800 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
         ac_prog_rejected=yes
         continue
--- 4851,4857 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
         ac_prog_rejected=yes
         continue
*************** do
*** 4852,4858 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 4909,4915 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 4896,4902 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_ac_ct_CC="$ac_prog"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 4953,4959 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_ac_ct_CC="$ac_prog"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** cat confdefs.h - <<_ACEOF >conftest.$ac_
*** 5342,5349 ****
  /* end confdefs.h.  */
  #include <stdarg.h>
  #include <stdio.h>
! #include <sys/types.h>
! #include <sys/stat.h>
  /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
  struct buf { int x; };
  FILE * (*rcsopen) (struct buf *, struct stat *, int);
--- 5399,5405 ----
  /* end confdefs.h.  */
  #include <stdarg.h>
  #include <stdio.h>
! struct stat;
  /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
  struct buf { int x; };
  FILE * (*rcsopen) (struct buf *, struct stat *, int);
*************** am__quote=
*** 5446,5452 ****
  _am_result=none
  # First try GNU make style include.
  echo "include confinc" > confmf
! # Ignore all kinds of additional output from `make'.
  case `$am_make -s -f confmf 2> /dev/null` in #(
  *the\ am__doit\ target*)
    am__include=include
--- 5502,5508 ----
  _am_result=none
  # First try GNU make style include.
  echo "include confinc" > confmf
! # Ignore all kinds of additional output from 'make'.
  case `$am_make -s -f confmf 2> /dev/null` in #(
  *the\ am__doit\ target*)
    am__include=include
*************** fi
*** 5479,5484 ****
--- 5535,5541 ----
  if test "x$enable_dependency_tracking" != xno; then
    am_depcomp="$ac_aux_dir/depcomp"
    AMDEPBACKSLASH='\'
+   am__nodep='_no'
  fi
   if test "x$enable_dependency_tracking" != xno; then
    AMDEP_TRUE=
*************** else
*** 5501,5508 ****
    # We make a subdir and do the tests there.  Otherwise we can end up
    # making bogus files that we don't know about and never remove.  For
    # instance it was reported that on HP-UX the gcc test will end up
!   # making a dummy file named `D' -- because `-MD' means `put the output
!   # in D'.
    mkdir conftest.dir
    # Copy depcomp to subdir because otherwise we won't find it if we're
    # using a relative directory.
--- 5558,5566 ----
    # We make a subdir and do the tests there.  Otherwise we can end up
    # making bogus files that we don't know about and never remove.  For
    # instance it was reported that on HP-UX the gcc test will end up
!   # making a dummy file named 'D' -- because '-MD' means "put the output
!   # in D".
!   rm -rf conftest.dir
    mkdir conftest.dir
    # Copy depcomp to subdir because otherwise we won't find it if we're
    # using a relative directory.
*************** else
*** 5536,5551 ****
      : > sub/conftest.c
      for i in 1 2 3 4 5 6; do
        echo '#include "conftst'$i'.h"' >> sub/conftest.c
!       # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
!       # Solaris 8's {/usr,}/bin/sh.
!       touch sub/conftst$i.h
      done
      echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
  
!     # We check with `-c' and `-o' for the sake of the "dashmstdout"
      # mode.  It turns out that the SunPro C++ compiler does not properly
!     # handle `-M -o', and we need to detect this.  Also, some Intel
!     # versions had trouble with output in subdirs
      am__obj=sub/conftest.${OBJEXT-o}
      am__minus_obj="-o $am__obj"
      case $depmode in
--- 5594,5609 ----
      : > sub/conftest.c
      for i in 1 2 3 4 5 6; do
        echo '#include "conftst'$i'.h"' >> sub/conftest.c
!       # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
!       # Solaris 10 /bin/sh.
!       echo '/* dummy */' > sub/conftst$i.h
      done
      echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
  
!     # We check with '-c' and '-o' for the sake of the "dashmstdout"
      # mode.  It turns out that the SunPro C++ compiler does not properly
!     # handle '-M -o', and we need to detect this.  Also, some Intel
!     # versions had trouble with output in subdirs.
      am__obj=sub/conftest.${OBJEXT-o}
      am__minus_obj="-o $am__obj"
      case $depmode in
*************** else
*** 5554,5569 ****
        test "$am__universal" = false || continue
        ;;
      nosideeffect)
!       # after this tag, mechanisms are not by side-effect, so they'll
!       # only be used when explicitly requested
        if test "x$enable_dependency_tracking" = xyes; then
  	continue
        else
  	break
        fi
        ;;
!     msvisualcpp | msvcmsys)
!       # This compiler won't grok `-c -o', but also, the minuso test has
        # not run yet.  These depmodes are late enough in the game, and
        # so weak that their functioning should not be impacted.
        am__obj=conftest.${OBJEXT-o}
--- 5612,5627 ----
        test "$am__universal" = false || continue
        ;;
      nosideeffect)
!       # After this tag, mechanisms are not by side-effect, so they'll
!       # only be used when explicitly requested.
        if test "x$enable_dependency_tracking" = xyes; then
  	continue
        else
  	break
        fi
        ;;
!     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
!       # This compiler won't grok '-c -o', but also, the minuso test has
        # not run yet.  These depmodes are late enough in the game, and
        # so weak that their functioning should not be impacted.
        am__obj=conftest.${OBJEXT-o}
*************** do
*** 5900,5906 ****
      for ac_prog in grep ggrep; do
      for ac_exec_ext in '' $ac_executable_extensions; do
        ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
!       { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
  # Check for GNU ac_path_GREP and select it if it is found.
    # Check for GNU $ac_path_GREP
  case `"$ac_path_GREP" --version 2>&1` in
--- 5958,5964 ----
      for ac_prog in grep ggrep; do
      for ac_exec_ext in '' $ac_executable_extensions; do
        ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
!       as_fn_executable_p "$ac_path_GREP" || continue
  # Check for GNU ac_path_GREP and select it if it is found.
    # Check for GNU $ac_path_GREP
  case `"$ac_path_GREP" --version 2>&1` in
*************** do
*** 5966,5972 ****
      for ac_prog in egrep; do
      for ac_exec_ext in '' $ac_executable_extensions; do
        ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
!       { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
  # Check for GNU ac_path_EGREP and select it if it is found.
    # Check for GNU $ac_path_EGREP
  case `"$ac_path_EGREP" --version 2>&1` in
--- 6024,6030 ----
      for ac_prog in egrep; do
      for ac_exec_ext in '' $ac_executable_extensions; do
        ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
!       as_fn_executable_p "$ac_path_EGREP" || continue
  # Check for GNU ac_path_EGREP and select it if it is found.
    # Check for GNU $ac_path_EGREP
  case `"$ac_path_EGREP" --version 2>&1` in
*************** do
*** 6066,6072 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_AR="${ac_tool_prefix}ar"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 6124,6130 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_AR="${ac_tool_prefix}ar"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 6106,6112 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_ac_ct_AR="ar"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 6164,6170 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_ac_ct_AR="ar"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 6173,6179 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 6231,6237 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 6213,6219 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_ac_ct_RANLIB="ranlib"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 6271,6277 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_ac_ct_RANLIB="ranlib"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** else
*** 6476,6484 ****
       if test "$GCC" != yes; then
         ac_save_CC=$CC
         while :; do
!          # IRIX 6.2 and later do not support large files by default,
!          # so use the C compiler's -n32 option if that helps.
!          cat confdefs.h - <<_ACEOF >conftest.$ac_ext
  /* end confdefs.h.  */
  #include <sys/types.h>
   /* Check that off_t can represent 2**63 - 1 correctly.
--- 6534,6542 ----
       if test "$GCC" != yes; then
         ac_save_CC=$CC
         while :; do
! 	 # IRIX 6.2 and later do not support large files by default,
! 	 # so use the C compiler's -n32 option if that helps.
! 	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
  /* end confdefs.h.  */
  #include <sys/types.h>
   /* Check that off_t can represent 2**63 - 1 correctly.
*************** else
*** 6487,6494 ****
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
!                        && LARGE_OFF_T % 2147483647 == 1)
!                       ? 1 : -1];
  int
  main ()
  {
--- 6545,6552 ----
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
  int
  main ()
  {
*************** main ()
*** 6497,6512 ****
    return 0;
  }
  _ACEOF
!          if ac_fn_c_try_compile "$LINENO"; then :
    break
  fi
  rm -f core conftest.err conftest.$ac_objext
!          CC="$CC -n32"
!          if ac_fn_c_try_compile "$LINENO"; then :
    ac_cv_sys_largefile_CC=' -n32'; break
  fi
  rm -f core conftest.err conftest.$ac_objext
!          break
         done
         CC=$ac_save_CC
         rm -f conftest.$ac_ext
--- 6555,6570 ----
    return 0;
  }
  _ACEOF
! 	 if ac_fn_c_try_compile "$LINENO"; then :
    break
  fi
  rm -f core conftest.err conftest.$ac_objext
! 	 CC="$CC -n32"
! 	 if ac_fn_c_try_compile "$LINENO"; then :
    ac_cv_sys_largefile_CC=' -n32'; break
  fi
  rm -f core conftest.err conftest.$ac_objext
! 	 break
         done
         CC=$ac_save_CC
         rm -f conftest.$ac_ext
*************** else
*** 6533,6540 ****
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
!                        && LARGE_OFF_T % 2147483647 == 1)
!                       ? 1 : -1];
  int
  main ()
  {
--- 6591,6598 ----
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
  int
  main ()
  {
*************** rm -f core conftest.err conftest.$ac_obj
*** 6557,6564 ****
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
!                        && LARGE_OFF_T % 2147483647 == 1)
!                       ? 1 : -1];
  int
  main ()
  {
--- 6615,6622 ----
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
  int
  main ()
  {
*************** else
*** 6602,6609 ****
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
!                        && LARGE_OFF_T % 2147483647 == 1)
!                       ? 1 : -1];
  int
  main ()
  {
--- 6660,6667 ----
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
  int
  main ()
  {
*************** rm -f core conftest.err conftest.$ac_obj
*** 6626,6633 ****
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
!                        && LARGE_OFF_T % 2147483647 == 1)
!                       ? 1 : -1];
  int
  main ()
  {
--- 6684,6691 ----
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
  int
  main ()
  {
*************** main ()
*** 6810,6816 ****
    return 0;
  }
  _ACEOF
! for ac_arg in '' -std=gnu99 -std=c99 -c99 -AC99 -xc99=all -qlanglvl=extc99
  do
    CC="$ac_save_CC $ac_arg"
    if ac_fn_c_try_compile "$LINENO"; then :
--- 6868,6874 ----
    return 0;
  }
  _ACEOF
! for ac_arg in '' -std=gnu99 -std=c99 -c99 -AC99 -D_STDC_C99= -qlanglvl=extc99
  do
    CC="$ac_save_CC $ac_arg"
    if ac_fn_c_try_compile "$LINENO"; then :
*************** cat confdefs.h - <<_ACEOF >conftest.$ac_
*** 6850,6857 ****
  /* end confdefs.h.  */
  #include <stdarg.h>
  #include <stdio.h>
! #include <sys/types.h>
! #include <sys/stat.h>
  /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
  struct buf { int x; };
  FILE * (*rcsopen) (struct buf *, struct stat *, int);
--- 6908,6914 ----
  /* end confdefs.h.  */
  #include <stdarg.h>
  #include <stdio.h>
! struct stat;
  /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
  struct buf { int x; };
  FILE * (*rcsopen) (struct buf *, struct stat *, int);
*************** do
*** 7340,7346 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 7397,7403 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 7380,7386 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_ac_ct_RANLIB="ranlib"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 7437,7443 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_ac_ct_RANLIB="ranlib"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 7452,7458 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_INSTALL_INFO="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 7509,7515 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_INSTALL_INFO="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 7492,7498 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_INSTALL_INFO="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 7549,7555 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_INSTALL_INFO="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 7532,7538 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_INSTALL_INFO="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 7589,7595 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_INSTALL_INFO="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 7573,7579 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_GZIP_PROG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 7630,7636 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_GZIP_PROG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 7616,7622 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_MAKEINFO="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 7673,7679 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_MAKEINFO="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** else
*** 7888,7896 ****
       if test "$GCC" != yes; then
         ac_save_CC=$CC
         while :; do
!          # IRIX 6.2 and later do not support large files by default,
!          # so use the C compiler's -n32 option if that helps.
!          cat confdefs.h - <<_ACEOF >conftest.$ac_ext
  /* end confdefs.h.  */
  #include <sys/types.h>
   /* Check that off_t can represent 2**63 - 1 correctly.
--- 7945,7953 ----
       if test "$GCC" != yes; then
         ac_save_CC=$CC
         while :; do
! 	 # IRIX 6.2 and later do not support large files by default,
! 	 # so use the C compiler's -n32 option if that helps.
! 	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
  /* end confdefs.h.  */
  #include <sys/types.h>
   /* Check that off_t can represent 2**63 - 1 correctly.
*************** else
*** 7899,7906 ****
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
!                        && LARGE_OFF_T % 2147483647 == 1)
!                       ? 1 : -1];
  int
  main ()
  {
--- 7956,7963 ----
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
  int
  main ()
  {
*************** main ()
*** 7909,7924 ****
    return 0;
  }
  _ACEOF
!          if ac_fn_c_try_compile "$LINENO"; then :
    break
  fi
  rm -f core conftest.err conftest.$ac_objext
!          CC="$CC -n32"
!          if ac_fn_c_try_compile "$LINENO"; then :
    ac_cv_sys_largefile_CC=' -n32'; break
  fi
  rm -f core conftest.err conftest.$ac_objext
!          break
         done
         CC=$ac_save_CC
         rm -f conftest.$ac_ext
--- 7966,7981 ----
    return 0;
  }
  _ACEOF
! 	 if ac_fn_c_try_compile "$LINENO"; then :
    break
  fi
  rm -f core conftest.err conftest.$ac_objext
! 	 CC="$CC -n32"
! 	 if ac_fn_c_try_compile "$LINENO"; then :
    ac_cv_sys_largefile_CC=' -n32'; break
  fi
  rm -f core conftest.err conftest.$ac_objext
! 	 break
         done
         CC=$ac_save_CC
         rm -f conftest.$ac_ext
*************** else
*** 7945,7952 ****
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
!                        && LARGE_OFF_T % 2147483647 == 1)
!                       ? 1 : -1];
  int
  main ()
  {
--- 8002,8009 ----
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
  int
  main ()
  {
*************** rm -f core conftest.err conftest.$ac_obj
*** 7969,7976 ****
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
!                        && LARGE_OFF_T % 2147483647 == 1)
!                       ? 1 : -1];
  int
  main ()
  {
--- 8026,8033 ----
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
  int
  main ()
  {
*************** else
*** 8014,8021 ****
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
!                        && LARGE_OFF_T % 2147483647 == 1)
!                       ? 1 : -1];
  int
  main ()
  {
--- 8071,8078 ----
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
  int
  main ()
  {
*************** rm -f core conftest.err conftest.$ac_obj
*** 8038,8045 ****
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
!                        && LARGE_OFF_T % 2147483647 == 1)
!                       ? 1 : -1];
  int
  main ()
  {
--- 8095,8102 ----
      incorrectly reject 9223372036854775807.  */
  #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
    int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
  int
  main ()
  {
*************** do
*** 8301,8307 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 8358,8364 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** else
*** 8987,8997 ****
  int
  main ()
  {
! /* FIXME: Include the comments suggested by Paul. */
  #ifndef __cplusplus
!   /* Ultrix mips cc rejects this.  */
    typedef int charset[2];
!   const charset cs;
    /* SunOS 4.1.1 cc rejects this.  */
    char const *const *pcpcc;
    char **ppc;
--- 9044,9054 ----
  int
  main ()
  {
! 
  #ifndef __cplusplus
!   /* Ultrix mips cc rejects this sort of thing.  */
    typedef int charset[2];
!   const charset cs = { 0, 0 };
    /* SunOS 4.1.1 cc rejects this.  */
    char const *const *pcpcc;
    char **ppc;
*************** main ()
*** 9008,9015 ****
    ++pcpcc;
    ppc = (char**) pcpcc;
    pcpcc = (char const *const *) ppc;
!   { /* SCO 3.2v4 cc rejects this.  */
!     char *t;
      char const *s = 0 ? (char *) 0 : (char const *) 0;
  
      *t++ = 0;
--- 9065,9073 ----
    ++pcpcc;
    ppc = (char**) pcpcc;
    pcpcc = (char const *const *) ppc;
!   { /* SCO 3.2v4 cc rejects this sort of thing.  */
!     char tx;
!     char *t = &tx;
      char const *s = 0 ? (char *) 0 : (char const *) 0;
  
      *t++ = 0;
*************** main ()
*** 9025,9034 ****
      iptr p = 0;
      ++p;
    }
!   { /* AIX XL C 1.02.0.0 rejects this saying
         "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
!     struct s { int j; const int *ap[3]; };
!     struct s *b; b->j = 5;
    }
    { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
      const int foo = 10;
--- 9083,9092 ----
      iptr p = 0;
      ++p;
    }
!   { /* AIX XL C 1.02.0.0 rejects this sort of thing, saying
         "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
!     struct s { int j; const int *ap[3]; } bx;
!     struct s *b = &bx; b->j = 5;
    }
    { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
      const int foo = 10;
*************** else
*** 9744,9749 ****
--- 9802,9818 ----
    fi
  fi
  
+ HAVE_MACGUI=no
+ if test "${with_mac}" != no; then
+   ac_fn_c_check_header_mongrel "$LINENO" "Carbon/Carbon.h" "ac_cv_header_Carbon_Carbon_h" "$ac_includes_default"
+ if test "x$ac_cv_header_Carbon_Carbon_h" = xyes; then :
+   HAVE_MACGUI=yes
+ fi
+ 
+ 
+   test "${HAVE_MACGUI}" = yes && window_system=mac
+ fi
+ 
  HAVE_NS=no
  NS_IMPL_COCOA=no
  NS_IMPL_GNUSTEP=no
*************** rm -f core conftest.err conftest.$ac_obj
*** 9852,9861 ****
--- 9921,9943 ----
  fi
  
  
+ mac_frag=/dev/null
+ MAC_OBJ=
+ MAC_OBJC_OBJ=
+ if test "${HAVE_MACGUI}" = yes; then
+   mac_frag=$srcdir/src/mac.mk
+   MAC_OBJ="mac.o macterm.o macfns.o macmenu.o macselect.o macfont.o fontset.o fringe.o image.o"
+   MAC_OBJC_OBJ="macappkit.o"
+ fi
+ 
+ 
+ 
+ 
  ns_frag=/dev/null
  NS_OBJ=
  NS_OBJC_OBJ=
  if test "${HAVE_NS}" = yes; then
+   test "${window_system}" = mac && HAVE_MACGUI=no
    if test "$with_toolkit_scroll_bars" = "no"; then
      as_fn_error $? "Non-toolkit scroll bars are not implemented for Nextstep." "$LINENO" 5
    fi
*************** case "${window_system}" in
*** 9894,9900 ****
        * ) USE_X_TOOLKIT=maybe ;;
      esac
    ;;
!   nextstep | none )
      HAVE_X_WINDOWS=no
      HAVE_X11=no
      USE_X_TOOLKIT=none
--- 9976,9982 ----
        * ) USE_X_TOOLKIT=maybe ;;
      esac
    ;;
!   mac | nextstep | none )
      HAVE_X_WINDOWS=no
      HAVE_X11=no
      USE_X_TOOLKIT=none
*************** do
*** 9918,9924 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_HAVE_XSERVER="true"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 10000,10006 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_HAVE_XSERVER="true"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** fi
*** 10713,10719 ****
  
  ### Use -lrsvg-2 if available, unless `--with-rsvg=no' is specified.
  HAVE_RSVG=no
! if test "${HAVE_X11}" = "yes" || test "${HAVE_NS}" = "yes"; then
    if test "${with_rsvg}" != "no"; then
      RSVG_REQUIRED=2.11.0
      RSVG_MODULE="librsvg-2.0 >= $RSVG_REQUIRED"
--- 10795,10801 ----
  
  ### Use -lrsvg-2 if available, unless `--with-rsvg=no' is specified.
  HAVE_RSVG=no
! if test "${HAVE_X11}" = "yes" || test "${HAVE_MACGUI}" = "yes" || test "${HAVE_NS}" = "yes"; then
    if test "${with_rsvg}" != "no"; then
      RSVG_REQUIRED=2.11.0
      RSVG_MODULE="librsvg-2.0 >= $RSVG_REQUIRED"
*************** do
*** 10739,10745 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 10821,10827 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** $as_echo "#define HAVE_RSVG 1" >>confdef
*** 10826,10832 ****
  fi
  
  HAVE_IMAGEMAGICK=no
! if test "${HAVE_X11}" = "yes"; then
    if test "${with_imagemagick}" != "no"; then
      ## 6.2.8 is the earliest version known to work, but earlier versions
      ## might work - let us know if you find one.
--- 10908,10914 ----
  fi
  
  HAVE_IMAGEMAGICK=no
! if test "${HAVE_X11}" = "yes" || test "${HAVE_MACGUI}" = "yes"; then
    if test "${with_imagemagick}" != "no"; then
      ## 6.2.8 is the earliest version known to work, but earlier versions
      ## might work - let us know if you find one.
*************** do
*** 10853,10859 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 10935,10941 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 10979,10985 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 11061,11067 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 11089,11095 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 11171,11177 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 11290,11296 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 11372,11378 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 11407,11413 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 11489,11495 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 11512,11518 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 11594,11600 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 11695,11701 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 11777,11783 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** if test "${with_toolkit_scroll_bars}" !=
*** 12239,12244 ****
--- 12321,12330 ----
      $as_echo "#define USE_TOOLKIT_SCROLL_BARS 1" >>confdefs.h
  
      USE_TOOLKIT_SCROLL_BARS=yes
+   elif test "${HAVE_MACGUI}" = "yes"; then
+     $as_echo "#define USE_TOOLKIT_SCROLL_BARS 1" >>confdefs.h
+ 
+     USE_TOOLKIT_SCROLL_BARS=yes
    elif test "${HAVE_NS}" = "yes"; then
      $as_echo "#define USE_TOOLKIT_SCROLL_BARS 1" >>confdefs.h
  
*************** do
*** 12349,12355 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 12435,12441 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 12451,12457 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 12537,12543 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 12662,12668 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 12748,12754 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 12766,12772 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 12852,12858 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 12918,12924 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 13004,13010 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** fi
*** 13525,13530 ****
--- 13611,13649 ----
  
  
  C_SWITCH_X_SYSTEM=
+ ### Use Mac OS X GUI.
+ if test "${HAVE_MACGUI}" = "yes"; then
+ 
+ $as_echo "#define HAVE_MACGUI 1" >>confdefs.h
+ 
+   for ac_header in AvailabilityMacros.h
+ do :
+   ac_fn_c_check_header_mongrel "$LINENO" "AvailabilityMacros.h" "ac_cv_header_AvailabilityMacros_h" "$ac_includes_default"
+ if test "x$ac_cv_header_AvailabilityMacros_h" = xyes; then :
+   cat >>confdefs.h <<_ACEOF
+ #define HAVE_AVAILABILITYMACROS_H 1
+ _ACEOF
+ 
+ fi
+ 
+ done
+ 
+   C_SWITCH_X_SYSTEM="-fconstant-cfstrings"
+   ## Specify the install directory
+   mac_appdir=
+   if test "${mac_appdir_x}" != ""; then
+     case ${mac_appdir_x} in
+       y | ye | yes)  mac_appdir=/Applications ;;
+       * ) mac_appdir=${mac_appdir_x} ;;
+     esac
+   fi
+   # We also have mouse menus.
+   HAVE_MENUS=yes
+   # Tell src/Makefile.in to create files in the Mac OS X application
+   # bundle mac/Emacs.app.
+   OTHER_FILES=macosx-app
+ fi
+ 
  ### Use NeXTstep API to implement GUI.
  if test "${HAVE_NS}" = "yes"; then
  
*************** do
*** 13644,13650 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 13763,13769 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** do
*** 13977,13983 ****
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
      ac_cv_prog_liblockfile="yes"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
--- 14096,14102 ----
    IFS=$as_save_IFS
    test -z "$as_dir" && as_dir=.
      for ac_exec_ext in '' $ac_executable_extensions; do
!   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
      ac_cv_prog_liblockfile="yes"
      $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
      break 2
*************** case "$opsys" in
*** 14377,14387 ****
    ##  The ncurses library has been moved out of the System framework in
    ##  Mac OS X 10.2.  So if configure detects it, set the command-line
    ##  option to use it.
!   darwin|gnu*)
      ## (HAVE_LIBNCURSES was not always true, but is since 2010-03-18.)
      if test "x$HAVE_LIBNCURSES" = "xyes"; then
        TERMINFO=yes
        LIBS_TERMCAP="-lncurses"
      fi
      ;;
  
--- 14496,14547 ----
    ##  The ncurses library has been moved out of the System framework in
    ##  Mac OS X 10.2.  So if configure detects it, set the command-line
    ##  option to use it.
!   darwin)
      ## (HAVE_LIBNCURSES was not always true, but is since 2010-03-18.)
      if test "x$HAVE_LIBNCURSES" = "xyes"; then
        TERMINFO=yes
        LIBS_TERMCAP="-lncurses"
+       if test "${HAVE_MACGUI}" = "yes"; then
+         { $as_echo "$as_me:${as_lineno-$LINENO}: checking Mac OS X version min required >= 10.4" >&5
+ $as_echo_n "checking Mac OS X version min required >= 10.4... " >&6; }
+         if ${emacs_cv_mac_os_x_min_required_10_4+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+ /* end confdefs.h.  */
+ 
+ #ifdef HAVE_AVAILABILITYMACROS_H
+ #include <AvailabilityMacros.h>
+ #endif
+ int
+ main ()
+ {
+ #if MAC_OS_X_VERSION_MIN_REQUIRED < 1040 && MAC_OS_X_VERSION_MIN_REQUIRED >= 1020
+ fail;
+ #endif
+ 
+   ;
+   return 0;
+ }
+ _ACEOF
+ if ac_fn_c_try_link "$LINENO"; then :
+   emacs_cv_mac_os_x_min_required_10_4=yes
+ else
+   emacs_cv_mac_os_x_min_required_10_4=no
+ fi
+ rm -f core conftest.err conftest.$ac_objext \
+     conftest$ac_exeext conftest.$ac_ext
+ fi
+ 
+         if test $emacs_cv_mac_os_x_min_required_10_4 = yes; then
+           { $as_echo "$as_me:${as_lineno-$LINENO}: result: 10.4 or later" >&5
+ $as_echo "10.4 or later" >&6; }
+         else
+           { $as_echo "$as_me:${as_lineno-$LINENO}: result: before 10.4" >&5
+ $as_echo "before 10.4" >&6; }
+           LIBS_TERMCAP="-lncurses.5"
+         fi
+       fi
      fi
      ;;
  
*************** $as_echo "$emacs_cv_freebsd_terminfo" >&
*** 14426,14431 ****
--- 14586,14599 ----
      fi
      ;;
  
+   gnu*)
+     ## (HAVE_LIBNCURSES was not always true, but is since 2010-03-18.)
+     if test "x$HAVE_LIBNCURSES" = "xyes"; then
+       TERMINFO=yes
+       LIBS_TERMCAP="-lncurses"
+     fi
+     ;;
+ 
    netbsd)
      if test "x$LIBS_TERMCAP" = "x-lterminfo"; then
        TERMINFO=yes
*************** S_FILE="\$(srcdir)/${opsysfile}"
*** 15796,15801 ****
--- 15964,15970 ----
  
  
  
+ 
  cat >>confdefs.h <<_ACEOF
  #define EMACS_CONFIGURATION "${canonical}"
  _ACEOF
*************** case "$opsys" in
*** 22294,22307 ****
     ## end of the header for adding load commands.  Needed for dumping.
     ## 0x690 is the total size of 30 segment load commands (at 56
     ## each); under Cocoa 31 commands are required.
!    if test "$HAVE_NS" = "yes"; then
!      libs_nsgui="-framework AppKit"
       headerpad_extra=6C8
     else
!      libs_nsgui=
       headerpad_extra=690
     fi
!    LD_SWITCH_SYSTEM_TEMACS="-fno-pie -prebind $libs_nsgui -Xlinker -headerpad -Xlinker $headerpad_extra"
  
     ## This is here because src/Makefile.in did some extra fiddling around
     ## with LD_SWITCH_SYSTEM.  The cpp logic was:
--- 22463,22567 ----
     ## end of the header for adding load commands.  Needed for dumping.
     ## 0x690 is the total size of 30 segment load commands (at 56
     ## each); under Cocoa 31 commands are required.
!    if test "$HAVE_MACGUI" = "yes"; then
!      # Check if the Image I/O framework is always available at
!      # runtime.  If not, fall back on QuickTime.
!      { $as_echo "$as_me:${as_lineno-$LINENO}: checking Mac OS X version >= 10.4" >&5
! $as_echo_n "checking Mac OS X version >= 10.4... " >&6; }
!      if ${emacs_cv_mac_os_x_10_4+:} false; then :
!   $as_echo_n "(cached) " >&6
! else
!   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
! /* end confdefs.h.  */
! 
! #ifdef HAVE_AVAILABILITYMACROS_H
! #include <AvailabilityMacros.h>
! #endif
! int
! main ()
! {
! #if MAC_OS_X_VERSION_MAX_ALLOWED >= 1040 && (MAC_OS_X_VERSION_MIN_REQUIRED >= 1040 || MAC_OS_X_VERSION_MIN_REQUIRED < 1020)
! fail;
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! if ac_fn_c_try_link "$LINENO"; then :
!   emacs_cv_mac_os_x_10_4=no
! else
!   emacs_cv_mac_os_x_10_4=yes
! fi
! rm -f core conftest.err conftest.$ac_objext \
!     conftest$ac_exeext conftest.$ac_ext
! fi
! 
!      if test $emacs_cv_mac_os_x_10_4 = yes; then
!        { $as_echo "$as_me:${as_lineno-$LINENO}: result: always 10.4 or later" >&5
! $as_echo "always 10.4 or later" >&6; }
! 
! $as_echo "#define USE_MAC_IMAGE_IO 1" >>confdefs.h
! 
!        libs_image="-framework WebKit"
!      else
!        { $as_echo "$as_me:${as_lineno-$LINENO}: result: not always 10.4 or later" >&5
! $as_echo "not always 10.4 or later" >&6; }
!        libs_image="-framework QuickTime"
!      fi
!      # Check if the Quartz Core framework is necessary and always
!      # available at runtime.
!      { $as_echo "$as_me:${as_lineno-$LINENO}: checking Mac OS X version max allowed >= 10.5" >&5
! $as_echo_n "checking Mac OS X version max allowed >= 10.5... " >&6; }
!      if ${emacs_cv_mac_os_x_max_allowed_10_5+:} false; then :
!   $as_echo_n "(cached) " >&6
! else
!   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
! /* end confdefs.h.  */
! 
! #ifdef HAVE_AVAILABILITYMACROS_H
! #include <AvailabilityMacros.h>
! #endif
! int
! main ()
! {
! #if MAC_OS_X_VERSION_MAX_ALLOWED >= 1050 && MAC_OS_X_VERSION_MIN_REQUIRED > 1020
! fail;
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! if ac_fn_c_try_link "$LINENO"; then :
!   emacs_cv_mac_os_x_max_allowed_10_5=no
! else
!   emacs_cv_mac_os_x_max_allowed_10_5=yes
! fi
! rm -f core conftest.err conftest.$ac_objext \
!     conftest$ac_exeext conftest.$ac_ext
! fi
! 
!      if test $emacs_cv_mac_os_x_max_allowed_10_5 = yes; then
!        { $as_echo "$as_me:${as_lineno-$LINENO}: result: 10.5 or later" >&5
! $as_echo "10.5 or later" >&6; }
!        libs_quartz_core="-framework QuartzCore"
!      else
!        { $as_echo "$as_me:${as_lineno-$LINENO}: result: before 10.5" >&5
! $as_echo "before 10.5" >&6; }
!        libs_quartz_core=
!      fi
!      # Whether to use the Cocoa framework.
!      libs_macgui="-framework Carbon $libs_image $libs_quartz_core -framework Cocoa"
!      headerpad_extra=690
!    elif test "$HAVE_NS" = "yes"; then
!      libs_macgui="-framework AppKit"
       headerpad_extra=6C8
     else
!      libs_macgui=
       headerpad_extra=690
     fi
!    LD_SWITCH_SYSTEM_TEMACS="-fno-pie -prebind $libs_macgui -Xlinker -headerpad -Xlinker $headerpad_extra"
  
     ## This is here because src/Makefile.in did some extra fiddling around
     ## with LD_SWITCH_SYSTEM.  The cpp logic was:
*************** fi
*** 22420,22426 ****
  
  
  ## If we're using X11/GNUstep, define some consequences.
! if test "$HAVE_X_WINDOWS" = "yes" || test "$HAVE_NS" = "yes"; then
  
  $as_echo "#define HAVE_WINDOW_SYSTEM 1" >>confdefs.h
  
--- 22680,22686 ----
  
  
  ## If we're using X11/GNUstep, define some consequences.
! if test "$HAVE_X_WINDOWS" = "yes" || test "$HAVE_MACGUI" = "yes" || test "$HAVE_NS" = "yes"; then
  
  $as_echo "#define HAVE_WINDOW_SYSTEM 1" >>confdefs.h
  
*************** LIBOBJS=$ac_libobjs
*** 22665,22670 ****
--- 22925,22938 ----
  LTLIBOBJS=$ac_ltlibobjs
  
  
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking that generated files are newer than configure" >&5
+ $as_echo_n "checking that generated files are newer than configure... " >&6; }
+    if test -n "$am_sleep_pid"; then
+      # Hide warnings about reused PIDs.
+      wait $am_sleep_pid 2>/dev/null
+    fi
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: done" >&5
+ $as_echo "done" >&6; }
   if test -n "$EXEEXT"; then
    am__EXEEXT_TRUE=
    am__EXEEXT_FALSE='#'
*************** if (echo >conf$$.file) 2>/dev/null; then
*** 23069,23084 ****
      # ... but there are two gotchas:
      # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
      # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
!     # In both cases, we have to default to `cp -p'.
      ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
!       as_ln_s='cp -p'
    elif ln conf$$.file conf$$ 2>/dev/null; then
      as_ln_s=ln
    else
!     as_ln_s='cp -p'
    fi
  else
!   as_ln_s='cp -p'
  fi
  rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
  rmdir conf$$.dir 2>/dev/null
--- 23337,23352 ----
      # ... but there are two gotchas:
      # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
      # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
!     # In both cases, we have to default to `cp -pR'.
      ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
!       as_ln_s='cp -pR'
    elif ln conf$$.file conf$$ 2>/dev/null; then
      as_ln_s=ln
    else
!     as_ln_s='cp -pR'
    fi
  else
!   as_ln_s='cp -pR'
  fi
  rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
  rmdir conf$$.dir 2>/dev/null
*************** else
*** 23138,23165 ****
    as_mkdir_p=false
  fi
  
! if test -x / >/dev/null 2>&1; then
!   as_test_x='test -x'
! else
!   if ls -dL / >/dev/null 2>&1; then
!     as_ls_L_option=L
!   else
!     as_ls_L_option=
!   fi
!   as_test_x='
!     eval sh -c '\''
!       if test -d "$1"; then
! 	test -d "$1/.";
!       else
! 	case $1 in #(
! 	-*)set "./$1";;
! 	esac;
! 	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
! 	???[sx]*):;;*)false;;esac;fi
!     '\'' sh
!   '
! fi
! as_executable_p=$as_test_x
  
  # Sed expression to map a string onto a valid CPP name.
  as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
--- 23406,23421 ----
    as_mkdir_p=false
  fi
  
! 
! # as_fn_executable_p FILE
! # -----------------------
! # Test if FILE is an executable regular file.
! as_fn_executable_p ()
! {
!   test -f "$1" && test -x "$1"
! } # as_fn_executable_p
! as_test_x='test -x'
! as_executable_p=as_fn_executable_p
  
  # Sed expression to map a string onto a valid CPP name.
  as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
*************** cat >>$CONFIG_STATUS <<\_ACEOF || ac_wri
*** 23181,23187 ****
  # values after options handling.
  ac_log="
  This file was extended by emacs $as_me 24.1, which was
! generated by GNU Autoconf 2.68.  Invocation command line was
  
    CONFIG_FILES    = $CONFIG_FILES
    CONFIG_HEADERS  = $CONFIG_HEADERS
--- 23437,23443 ----
  # values after options handling.
  ac_log="
  This file was extended by emacs $as_me 24.1, which was
! generated by GNU Autoconf 2.69.  Invocation command line was
  
    CONFIG_FILES    = $CONFIG_FILES
    CONFIG_HEADERS  = $CONFIG_HEADERS
*************** cat >>$CONFIG_STATUS <<_ACEOF || ac_writ
*** 23247,23256 ****
  ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
  ac_cs_version="\\
  emacs config.status 24.1
! configured by $0, generated by GNU Autoconf 2.68,
    with options \\"\$ac_cs_config\\"
  
! Copyright (C) 2010 Free Software Foundation, Inc.
  This config.status script is free software; the Free Software Foundation
  gives unlimited permission to copy, distribute and modify it."
  
--- 23503,23512 ----
  ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
  ac_cs_version="\\
  emacs config.status 24.1
! configured by $0, generated by GNU Autoconf 2.69,
    with options \\"\$ac_cs_config\\"
  
! Copyright (C) 2012 Free Software Foundation, Inc.
  This config.status script is free software; the Free Software Foundation
  gives unlimited permission to copy, distribute and modify it."
  
*************** fi
*** 23341,23347 ****
  _ACEOF
  cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
  if \$ac_cs_recheck; then
!   set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
    shift
    \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
    CONFIG_SHELL='$SHELL'
--- 23597,23603 ----
  _ACEOF
  cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
  if \$ac_cs_recheck; then
!   set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
    shift
    \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
    CONFIG_SHELL='$SHELL'
*************** $as_echo "$as_me: executing $ac_file com
*** 24042,24048 ****
      # Strip MF so we end up with the name of the file.
      mf=`echo "$mf" | sed -e 's/:.*$//'`
      # Check whether this is an Automake generated Makefile or not.
!     # We used to match only the files named `Makefile.in', but
      # some people rename them; so instead we look at the file content.
      # Grep'ing the first line is not enough: some people post-process
      # each Makefile.in and add a new line on top of each file to say so.
--- 24298,24304 ----
      # Strip MF so we end up with the name of the file.
      mf=`echo "$mf" | sed -e 's/:.*$//'`
      # Check whether this is an Automake generated Makefile or not.
!     # We used to match only the files named 'Makefile.in', but
      # some people rename them; so instead we look at the file content.
      # Grep'ing the first line is not enough: some people post-process
      # each Makefile.in and add a new line on top of each file to say so.
*************** $as_echo X"$mf" |
*** 24076,24096 ****
        continue
      fi
      # Extract the definition of DEPDIR, am__include, and am__quote
!     # from the Makefile without running `make'.
      DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
      test -z "$DEPDIR" && continue
      am__include=`sed -n 's/^am__include = //p' < "$mf"`
      test -z "am__include" && continue
      am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-     # When using ansi2knr, U may be empty or an underscore; expand it
-     U=`sed -n 's/^U = //p' < "$mf"`
      # Find all dependency output files, they are included files with
      # $(DEPDIR) in their names.  We invoke sed twice because it is the
      # simplest approach to changing $(DEPDIR) to its actual value in the
      # expansion.
      for file in `sed -n "
        s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
! 	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
        # Make sure the directory exists.
        test -f "$dirpart/$file" && continue
        fdir=`$as_dirname -- "$file" ||
--- 24332,24350 ----
        continue
      fi
      # Extract the definition of DEPDIR, am__include, and am__quote
!     # from the Makefile without running 'make'.
      DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
      test -z "$DEPDIR" && continue
      am__include=`sed -n 's/^am__include = //p' < "$mf"`
      test -z "am__include" && continue
      am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
      # Find all dependency output files, they are included files with
      # $(DEPDIR) in their names.  We invoke sed twice because it is the
      # simplest approach to changing $(DEPDIR) to its actual value in the
      # expansion.
      for file in `sed -n "
        s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
! 	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
        # Make sure the directory exists.
        test -f "$dirpart/$file" && continue
        fdir=`$as_dirname -- "$file" ||

=== modified file 'src/stamp-h.in'
*** src/stamp-h.in	2002-04-15 13:14:45 +0000
--- src/stamp-h.in	2012-03-02 04:47:26 +0000
***************
*** 1 ****
--- 1,2 ----
  timestamp
+ # patch-mac modified this file.

